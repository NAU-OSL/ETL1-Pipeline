""	"author"	"file_name"	"text"	"body"	"title"
"1"	"Olaf Lenz"	"[src/java/net/sf/jabref/FileSortTab.java, src/java/net/sf/jabref/FileTab.java, src/java/net/sf/jabref/JabRefPreferences.java, src/java/net/sf/jabref/PrefsDialog3.java, src/java/net/sf/jabref/TablePrefsTab.java, src/java/net/sf/jabref/export/FileActions.java, src/java/net/sf/jabref/gui/ImportInspectionDialog.java, src/java/net/sf/jabref/gui/MainTable.java, ]"	"[@@ -0,0 +1,387 @@
+/*  Copyright (C) 2013 JabRef contributors.
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+package net.sf.jabref;
+
+import java.awt.*;
+import javax.swing.*;
+
+import com.jgoodies.forms.builder.DefaultFormBuilder;
+import com.jgoodies.forms.layout.FormLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.ArrayList;
+
+/**
+ * Preference tab for file sorting options.
+ */
+public class FileSortTab extends JPanel implements PrefsTab {
+
+    JabRefPreferences _prefs;
+    JabRefFrame _frame;
+    private JRadioButton saveInOriginalOrder, saveInTableOrder, saveInSpecifiedOrder;
+    private JCheckBox savePriDesc, saveSecDesc, saveTerDesc;
+    private JTextField savePriField, saveSecField, saveTerField;
+    private JComboBox savePriSort, saveSecSort, saveTerSort;
+    private JPanel saveSpecPanel;
+
+    private JRadioButton exportInOriginalOrder, exportInTableOrder, exportInSpecifiedOrder;
+    private JCheckBox exportPriDesc, exportSecDesc, exportTerDesc;
+    private JTextField exportPriField, exportSecField, exportTerField;
+    private JComboBox exportPriSort, exportSecSort, exportTerSort;
+    private JPanel exportSpecPanel;
+
+    public FileSortTab(JabRefFrame frame, JabRefPreferences prefs) {
+        this._prefs = prefs;
+        this._frame = frame;
+        FormLayout layout = new FormLayout(\"4dlu, left:pref, 4dlu, fill:pref\", \"\");
+        DefaultFormBuilder builder = new DefaultFormBuilder(layout);
+        builder.setLeadingColumnOffset(1);
+
+        { // SAVE SORT ORDER
+            // create Components
+            saveInOriginalOrder = new JRadioButton(Globals.lang(\"Save entries in their original order\"));
+            saveInTableOrder = new JRadioButton(Globals.lang(\"Save in current table sort order\"));
+            saveInSpecifiedOrder = new JRadioButton(Globals.lang(\"Save entries ordered as specified\"));
+
+            ButtonGroup bg = new ButtonGroup();
+            bg.add(saveInOriginalOrder);
+            bg.add(saveInTableOrder);
+            bg.add(saveInSpecifiedOrder);
+
+            ActionListener listener = new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    boolean selected = e.getSource() == saveInSpecifiedOrder;
+                    savePriSort.setEnabled(selected);
+                    savePriField.setEnabled(selected);
+                    savePriDesc.setEnabled(selected);
+                    saveSecSort.setEnabled(selected);
+                    saveSecField.setEnabled(selected);
+                    saveSecDesc.setEnabled(selected);
+                    saveTerSort.setEnabled(selected);
+                    saveTerField.setEnabled(selected);
+                    saveTerDesc.setEnabled(selected);
+                }
+            };
+            saveInOriginalOrder.addActionListener(listener);
+            saveInTableOrder.addActionListener(listener);
+            saveInSpecifiedOrder.addActionListener(listener);
+
+            ArrayList<String> v = new ArrayList<String>(Arrays.asList(BibtexFields.getAllFieldNames()));
+            v.add(BibtexFields.KEY_FIELD);
+            Collections.sort(v);
+            Object[] allPlusKey = v.toArray();
+            savePriSort = new JComboBox(allPlusKey);
+            saveSecSort = new JComboBox(allPlusKey);
+            saveTerSort = new JComboBox(allPlusKey);
+
+            savePriField = new JTextField(10);
+            saveSecField = new JTextField(10);
+            saveTerField = new JTextField(10);
+
+            savePriSort.insertItemAt(Globals.lang(\"<select>\"), 0);
+            saveSecSort.insertItemAt(Globals.lang(\"<select>\"), 0);
+            saveTerSort.insertItemAt(Globals.lang(\"<select>\"), 0);
+
+            savePriSort.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    if (savePriSort.getSelectedIndex() > 0) {
+                        savePriField.setText(savePriSort.getSelectedItem().toString());
+                        savePriSort.setSelectedIndex(0);
+                    }
+                }
+            });
+            saveSecSort.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    if (saveSecSort.getSelectedIndex() > 0) {
+                        saveSecField.setText(saveSecSort.getSelectedItem().toString());
+                        saveSecSort.setSelectedIndex(0);
+                    }
+                }
+            });
+            saveTerSort.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    if (saveTerSort.getSelectedIndex() > 0) {
+                        saveTerField.setText(saveTerSort.getSelectedItem().toString());
+                        saveTerSort.setSelectedIndex(0);
+                    }
+                }
+            });
+
+            savePriDesc = new JCheckBox(Globals.lang(\"Descending\"));
+            saveSecDesc = new JCheckBox(Globals.lang(\"Descending\"));
+            saveTerDesc = new JCheckBox(Globals.lang(\"Descending\"));
+
+            // create GUI
+            JLabel lab;
+
+            builder.appendSeparator(Globals.lang(\"Save sort order\"));
+            builder.append(saveInOriginalOrder, 1);
+            builder.nextLine();
+            builder.append(saveInTableOrder, 1);
+            builder.nextLine();
+            builder.append(saveInSpecifiedOrder, 1);
+            builder.nextLine();
+
+            // Create a new panel with its own FormLayout for these items:
+            FormLayout layout2 = new FormLayout(
+                    \"right:pref, 8dlu, fill:pref, 4dlu, fill:60dlu, 4dlu, left:pref\", \"\");
+            DefaultFormBuilder builder2 = new DefaultFormBuilder(layout2);
+            lab = new JLabel(Globals.lang(\"Primary sort criterion\"));
+            builder2.append(lab);
+            builder2.append(savePriSort);
+            builder2.append(savePriField);
+            builder2.append(savePriDesc);
+            builder2.nextLine();
+            lab = new JLabel(Globals.lang(\"Secondary sort criterion\"));
+            builder2.append(lab);
+            builder2.append(saveSecSort);
+            builder2.append(saveSecField);
+            builder2.append(saveSecDesc);
+            builder2.nextLine();
+            lab = new JLabel(Globals.lang(\"Tertiary sort criterion\"));
+            builder2.append(lab);
+            builder2.append(saveTerSort);
+            builder2.append(saveTerField);
+            builder2.append(saveTerDesc);
+
+            saveSpecPanel = builder2.getPanel();
+            builder.append(saveSpecPanel);
+            builder.nextLine();
+        }
+
+        { // EXPORT SORT ORDER
+            // create Components
+            exportInOriginalOrder = new JRadioButton(Globals.lang(\"Export entries in their original order\"));
+            exportInTableOrder = new JRadioButton(Globals.lang(\"Export in current table sort order\"));
+            exportInSpecifiedOrder = new JRadioButton(Globals.lang(\"Export entries ordered as specified\"));
+
+            ButtonGroup bg = new ButtonGroup();
+            bg.add(exportInOriginalOrder);
+            bg.add(exportInTableOrder);
+            bg.add(exportInSpecifiedOrder);
+            
+            ActionListener listener = new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    boolean selected = e.getSource() == exportInSpecifiedOrder;
+                    exportPriSort.setEnabled(selected);
+                    exportPriField.setEnabled(selected);
+                    exportPriDesc.setEnabled(selected);
+                    exportSecSort.setEnabled(selected);
+                    exportSecField.setEnabled(selected);
+                    exportSecDesc.setEnabled(selected);
+                    exportTerSort.setEnabled(selected);
+                    exportTerField.setEnabled(selected);
+                    exportTerDesc.setEnabled(selected);
+                }
+            };
+            exportInOriginalOrder.addActionListener(listener);
+            exportInTableOrder.addActionListener(listener);
+            exportInSpecifiedOrder.addActionListener(listener);
+
+            ArrayList<String> v = new ArrayList<String>(Arrays.asList(BibtexFields.getAllFieldNames()));
+            v.add(BibtexFields.KEY_FIELD);
+            Collections.sort(v);
+            Object[] allPlusKey = v.toArray();
+            exportPriSort = new JComboBox(allPlusKey);
+            exportSecSort = new JComboBox(allPlusKey);
+            exportTerSort = new JComboBox(allPlusKey);
+
+            exportPriField = new JTextField(10);
+            exportSecField = new JTextField(10);
+            exportTerField = new JTextField(10);
+
+            exportPriSort.insertItemAt(Globals.lang(\"<select>\"), 0);
+            exportSecSort.insertItemAt(Globals.lang(\"<select>\"), 0);
+            exportTerSort.insertItemAt(Globals.lang(\"<select>\"), 0);
+
+            exportPriSort.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    if (exportPriSort.getSelectedIndex() > 0) {
+                        exportPriField.setText(exportPriSort.getSelectedItem().toString());
+                        exportPriSort.setSelectedIndex(0);
+                    }
+                }
+            });
+            exportSecSort.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    if (exportSecSort.getSelectedIndex() > 0) {
+                        exportSecField.setText(exportSecSort.getSelectedItem().toString());
+                        exportSecSort.setSelectedIndex(0);
+                    }
+                }
+            });
+            exportTerSort.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    if (exportTerSort.getSelectedIndex() > 0) {
+                        exportTerField.setText(exportTerSort.getSelectedItem().toString());
+                        exportTerSort.setSelectedIndex(0);
+                    }
+                }
+            });
+
+            exportPriDesc = new JCheckBox(Globals.lang(\"Descending\"));
+            exportSecDesc = new JCheckBox(Globals.lang(\"Descending\"));
+            exportTerDesc = new JCheckBox(Globals.lang(\"Descending\"));
+
+
+            // create GUI
+            JLabel lab;
+
+            builder.appendSeparator(Globals.lang(\"Export sort order\"));
+            builder.append(exportInOriginalOrder, 1);
+            builder.nextLine();
+            builder.append(exportInTableOrder, 1);
+            builder.nextLine();
+            builder.append(exportInSpecifiedOrder, 1);
+            builder.nextLine();
+            
+
+            // Create a new panel with its own FormLayout for these items:
+            FormLayout layout2 = new FormLayout(
+                    \"right:pref, 8dlu, fill:pref, 4dlu, fill:60dlu, 4dlu, left:pref\", \"\");
+            DefaultFormBuilder builder2 = new DefaultFormBuilder(layout2);
+            lab = new JLabel(Globals.lang(\"Primary sort criterion\"));
+            builder2.append(lab);
+            builder2.append(exportPriSort);
+            builder2.append(exportPriField);
+            builder2.append(exportPriDesc);
+            builder2.nextLine();
+            lab = new JLabel(Globals.lang(\"Secondary sort criterion\"));
+            builder2.append(lab);
+            builder2.append(exportSecSort);
+            builder2.append(exportSecField);
+            builder2.append(exportSecDesc);
+            builder2.nextLine();
+            lab = new JLabel(Globals.lang(\"Tertiary sort criterion\"));
+            builder2.append(lab);
+            builder2.append(exportTerSort);
+            builder2.append(exportTerField);
+            builder2.append(exportTerDesc);
+
+            builder.append(builder2.getPanel());
+            builder.nextLine();
+        }
+
+        // COMBINE EVERYTHING
+        JPanel pan = builder.getPanel();
+        pan.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
+        setLayout(new BorderLayout());
+        add(pan, BorderLayout.CENTER);
+    }
+
+    public void setValues() {
+        if (_prefs.getBoolean(JabRefPreferences.SAVE_IN_ORIGINAL_ORDER)) {
+            saveInOriginalOrder.setSelected(true);
+        } else if (_prefs.getBoolean(JabRefPreferences.SAVE_IN_SPECIFIED_ORDER)) {
+            saveInSpecifiedOrder.setSelected(true);
+        } else {
+            saveInTableOrder.setSelected(true);
+        }
+
+        {
+            boolean selected = _prefs.getBoolean(JabRefPreferences.SAVE_IN_SPECIFIED_ORDER);
+            savePriSort.setEnabled(selected);
+            savePriField.setEnabled(selected);
+            savePriDesc.setEnabled(selected);
+            saveSecSort.setEnabled(selected);
+            saveSecField.setEnabled(selected);
+            saveSecDesc.setEnabled(selected);
+            saveTerSort.setEnabled(selected);
+            saveTerField.setEnabled(selected);
+            saveTerDesc.setEnabled(selected);
+        }
+
+        savePriField.setText(_prefs.get(JabRefPreferences.SAVE_PRIMARY_SORT_FIELD));
+        saveSecField.setText(_prefs.get(JabRefPreferences.SAVE_SECONDARY_SORT_FIELD));
+        saveTerField.setText(_prefs.get(JabRefPreferences.SAVE_TERTIARY_SORT_FIELD));
+
+        savePriSort.setSelectedIndex(0);
+        saveSecSort.setSelectedIndex(0);
+        saveTerSort.setSelectedIndex(0);
+
+        savePriDesc.setSelected(_prefs.getBoolean(JabRefPreferences.SAVE_PRIMARY_SORT_DESCENDING));
+        saveSecDesc.setSelected(_prefs.getBoolean(JabRefPreferences.SAVE_SECONDARY_SORT_DESCENDING));
+        saveTerDesc.setSelected(_prefs.getBoolean(JabRefPreferences.SAVE_TERTIARY_SORT_DESCENDING));
+
+        if (_prefs.getBoolean(JabRefPreferences.EXPORT_IN_ORIGINAL_ORDER)) {
+            exportInOriginalOrder.setSelected(true);
+        } else if (_prefs.getBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER)) {
+            exportInSpecifiedOrder.setSelected(true);
+        } else {
+            exportInTableOrder.setSelected(true);
+        }
+
+        {
+            boolean selected = _prefs.getBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER);
+            exportPriSort.setEnabled(selected);
+            exportPriField.setEnabled(selected);
+            exportPriDesc.setEnabled(selected);
+            exportSecSort.setEnabled(selected);
+            exportSecField.setEnabled(selected);
+            exportSecDesc.setEnabled(selected);
+            exportTerSort.setEnabled(selected);
+            exportTerField.setEnabled(selected);
+            exportTerDesc.setEnabled(selected);
+        }
+
+        exportPriField.setText(_prefs.get(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD));
+        exportSecField.setText(_prefs.get(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD));
+        exportTerField.setText(_prefs.get(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD));
+
+        exportPriSort.setSelectedIndex(0);
+        exportSecSort.setSelectedIndex(0);
+        exportTerSort.setSelectedIndex(0);
+
+        exportPriDesc.setSelected(_prefs.getBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING));
+        exportSecDesc.setSelected(_prefs.getBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING));
+        exportTerDesc.setSelected(_prefs.getBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING));
+    }
+
+    public void storeSettings() {
+        _prefs.putBoolean(JabRefPreferences.SAVE_IN_ORIGINAL_ORDER, saveInOriginalOrder.isSelected());
+        _prefs.putBoolean(JabRefPreferences.SAVE_IN_SPECIFIED_ORDER, saveInSpecifiedOrder.isSelected());
+
+        _prefs.putBoolean(JabRefPreferences.SAVE_PRIMARY_SORT_DESCENDING, savePriDesc.isSelected());
+        _prefs.putBoolean(JabRefPreferences.SAVE_SECONDARY_SORT_DESCENDING, saveSecDesc.isSelected());
+        _prefs.putBoolean(JabRefPreferences.SAVE_TERTIARY_SORT_DESCENDING, saveTerDesc.isSelected());
+
+        _prefs.put(JabRefPreferences.SAVE_PRIMARY_SORT_FIELD, savePriField.getText().toLowerCase().trim());
+        _prefs.put(JabRefPreferences.SAVE_SECONDARY_SORT_FIELD, saveSecField.getText().toLowerCase().trim());
+        _prefs.put(JabRefPreferences.SAVE_TERTIARY_SORT_FIELD, saveTerField.getText().toLowerCase().trim());
+
+        _prefs.putBoolean(JabRefPreferences.EXPORT_IN_ORIGINAL_ORDER, exportInOriginalOrder.isSelected());
+        _prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, exportInSpecifiedOrder.isSelected());
+
+        _prefs.putBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING, exportPriDesc.isSelected());
+        _prefs.putBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING, exportSecDesc.isSelected());
+        _prefs.putBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING, exportTerDesc.isSelected());
+
+        _prefs.put(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD, exportPriField.getText().toLowerCase().trim());
+        _prefs.put(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD, exportSecField.getText().toLowerCase().trim());
+        _prefs.put(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD, exportTerField.getText().toLowerCase().trim());
+
+    }
+
+    public boolean readyToClose() {
+        return true;
+    }
+
+    public String getTabName() {
+        return Globals.lang(\"File Sorting\");
+    }
+}, @@ -39,8 +39,6 @@
             promptBeforeUsingAutoSave, includeEmptyFields, camelCase, sameColumn;
     private JComboBox valueDelimiter;
     private JRadioButton
-        saveOriginalOrder, saveAuthorOrder, saveTableOrder, saveTitleOrder,
-        exportOriginalOrder, exportAuthorOrder, exportTableOrder, exportTitleOrder,
         resolveStringsStandard, resolveStringsAll;
     private JTextField bracesAroundCapitalsFields, nonWrappableFields,
             doNotResolveStringsFor;
@@ -56,14 +54,6 @@ public FileTab(JabRefFrame frame, JabRefPreferences prefs) {
                 GUIGlobals.getIconUrl(\"helpSmall\"));
         openLast = new JCheckBox(Globals.lang(\"Open last edited databases at startup\"));
         backup = new JCheckBox(Globals.lang(\"Backup old file when saving\"));
-        saveAuthorOrder = new JRadioButton(Globals.lang(\"Save ordered by author/editor/year\"));
-        exportAuthorOrder = new JRadioButton(Globals.lang(\"Export ordered by author/editor/year\"));
-        saveOriginalOrder = new JRadioButton(Globals.lang(\"Save entries in their original order\"));
-        exportOriginalOrder = new JRadioButton(Globals.lang(\"Export entries in their original order\"));
-        saveTableOrder = new JRadioButton(Globals.lang(\"Save in current table sort order\"));
-        exportTableOrder = new JRadioButton(Globals.lang(\"Export in current table sort order\"));
-        saveTitleOrder = new JRadioButton(Globals.lang(\"Save entries ordered by title\"));
-        exportTitleOrder = new JRadioButton(Globals.lang(\"Export entries ordered by title\"));
         autoSave = new JCheckBox(Globals.lang(\"Autosave\"));
         promptBeforeUsingAutoSave = new JCheckBox(Globals.lang(\"Prompt before recovering a database from an autosave file\"));
         autoSaveInterval = new JSpinner(new SpinnerNumberModel(1, 1, 60, 1));
@@ -73,19 +63,9 @@ public FileTab(JabRefFrame frame, JabRefPreferences prefs) {
         includeEmptyFields = new JCheckBox(Globals.lang(\"Include empty fields\"));
         sameColumn = new JCheckBox(Globals.lang(\"Start field contents in same column\"));
         camelCase = new JCheckBox(Globals.lang(\"Use camel case for field names (e.g., \\"HowPublished\\" instead of \\"howpublished\\")\"));
-        ButtonGroup bg = new ButtonGroup();
-        bg.add(saveAuthorOrder);
-        bg.add(saveOriginalOrder);
-        bg.add(saveTableOrder);
-        bg.add(saveTitleOrder);
-        bg = new ButtonGroup();
-        bg.add(exportAuthorOrder);
-        bg.add(exportOriginalOrder);
-        bg.add(exportTableOrder);
-        bg.add(exportTitleOrder);
         resolveStringsAll = new JRadioButton(Globals.lang(\"Resolve strings for all fields except\")+\":\");
         resolveStringsStandard = new JRadioButton(Globals.lang(\"Resolve strings for standard BibTeX fields only\"));
-        bg = new ButtonGroup();
+        ButtonGroup bg = new ButtonGroup();
         bg.add(resolveStringsAll);
         bg.add(resolveStringsStandard);
 
@@ -144,19 +124,6 @@ public void stateChanged(ChangeEvent changeEvent) {
         builder.nextLine();
         builder.append(promptBeforeUsingAutoSave);
         builder.nextLine();
-        builder.appendSeparator(Globals.lang(\"Sort order\"));
-        builder.append(saveAuthorOrder, 1);
-        builder.append(exportAuthorOrder, 1);
-        builder.nextLine();
-        builder.append(saveTableOrder, 1);
-        builder.append(exportTableOrder, 1);
-        builder.nextLine();
-        builder.append(saveOriginalOrder, 1);
-        builder.append(exportOriginalOrder, 1);
-        builder.nextLine();
-        builder.append(saveTitleOrder, 1);
-        builder.append(exportTitleOrder, 1);
-        builder.nextLine();
         builder.appendSeparator(Globals.lang(\"Field saving options\"));
         builder.nextLine();
         builder.append(camelCase);
@@ -184,23 +151,7 @@ public void stateChanged(ChangeEvent changeEvent) {
     public void setValues() {
         openLast.setSelected(_prefs.getBoolean(\"openLastEdited\"));
         backup.setSelected(_prefs.getBoolean(\"backup\"));
-        if (_prefs.getBoolean(\"saveInStandardOrder\"))
-            saveAuthorOrder.setSelected(true);
-        else if (_prefs.getBoolean(\"saveInOriginalOrder\"))
-            saveOriginalOrder.setSelected(true);
-        else if (_prefs.getBoolean(\"saveInTitleOrder\"))
-            saveTitleOrder.setSelected(true);
-        else
-            saveTableOrder.setSelected(true);
-        if (_prefs.getBoolean(\"exportInStandardOrder\"))
-            exportAuthorOrder.setSelected(true);
-        else if (_prefs.getBoolean(\"exportInOriginalOrder\"))
-            exportOriginalOrder.setSelected(true);
-        else if (_prefs.getBoolean(\"exportInTitleOrder\"))
-            exportTitleOrder.setSelected(true);
-        else
-            exportTableOrder.setSelected(true);
-
+        
         //preserveFormatting.setSelected(_prefs.getBoolean(\"preserveFieldFormatting\"));
         autoDoubleBraces.setSelected(_prefs.getBoolean(\"autoDoubleBraces\"));
         resolveStringsAll.setSelected(_prefs.getBoolean(\"resolveStringsAllFields\"));
@@ -222,12 +173,6 @@ else if (_prefs.getBoolean(\"exportInTitleOrder\"))
     public void storeSettings() {
         _prefs.putBoolean(\"backup\", backup.isSelected());
         _prefs.putBoolean(\"openLastEdited\", openLast.isSelected());
-        _prefs.putBoolean(\"saveInStandardOrder\", saveAuthorOrder.isSelected());
-        _prefs.putBoolean(\"saveInOriginalOrder\", saveOriginalOrder.isSelected());
-        _prefs.putBoolean(\"saveInTitleOrder\", saveTitleOrder.isSelected());
-        _prefs.putBoolean(\"exportInStandardOrder\", exportAuthorOrder.isSelected());
-        _prefs.putBoolean(\"exportInOriginalOrder\", exportOriginalOrder.isSelected());
-        _prefs.putBoolean(\"exportInTitleOrder\", exportTitleOrder.isSelected());
         _prefs.putBoolean(\"autoDoubleBraces\", autoDoubleBraces.isSelected());
         _prefs.putBoolean(\"resolveStringsAllFields\", resolveStringsAll.isSelected());
         _prefs.put(\"doNotResolveStringsFor\", doNotResolveStringsFor.getText().trim());, @@ -1,18 +1,18 @@
 /*  Copyright (C) 2003-2012 JabRef contributors.
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-*/
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 package net.sf.jabref;
 
 import java.awt.Color;
@@ -54,69 +54,84 @@
 
 public class JabRefPreferences {
 
-    public final static String
-        CUSTOM_TYPE_NAME = \"customTypeName_\",
-        CUSTOM_TYPE_REQ = \"customTypeReq_\",
-        CUSTOM_TYPE_OPT = \"customTypeOpt_\",
-        CUSTOM_TYPE_PRIOPT = \"customTypePriOpt_\",
-        CUSTOM_TAB_NAME = \"customTabName_\",
-        CUSTOM_TAB_FIELDS = \"customTabFields_\",
-        EMACS_PATH = \"emacsPath\",
-        EMACS_ADDITIONAL_PARAMETERS = \"emacsParameters\",
-        EMACS_23 = \"emacsUseV23InsertString\",
-        EDIT_GROUP_MEMBERSHIP_MODE = \"groupEditGroupMembershipMode\",
-        
-        PDF_PREVIEW = \"pdfPreview\",
-
-        SHOWONELETTERHEADINGFORICONCOLUMNS = \"showOneLetterHeadingForIconColumns\",
-
-        EDITOR_EMACS_KEYBINDINGS = \"editorEMACSkeyBindings\",
-        EDITOR_EMACS_KEYBINDINGS_REBIND_CA = \"editorEMACSkeyBindingsRebindCA\",
-
-        SHORTEST_TO_COMPLETE = \"shortestToComplete\",
-        AUTOCOMPLETE_FIRSTNAME_MODE = \"autoCompFirstNameMode\",
-        // here are the possible values for _MODE:
-        AUTOCOMPLETE_FIRSTNAME_MODE_BOTH = \"both\",
-        AUTOCOMPLETE_FIRSTNAME_MODE_ONLY_FULL = \"fullOnly\",
-        AUTOCOMPLETE_FIRSTNAME_MODE_ONLY_ABBR = \"abbrOnly\",
-
-        WRITEFIELD_ADDSPACES = \"writeFieldAddSpaces\",
-        WRITEFIELD_CAMELCASENAME = \"writeFieldCamelCase\",
-
-        UPDATE_TIMESTAMP = \"updateTimestamp\";
+    public final static String CUSTOM_TYPE_NAME = \"customTypeName_\",
+            CUSTOM_TYPE_REQ = \"customTypeReq_\",
+            CUSTOM_TYPE_OPT = \"customTypeOpt_\",
+            CUSTOM_TYPE_PRIOPT = \"customTypePriOpt_\",
+            CUSTOM_TAB_NAME = \"customTabName_\",
+            CUSTOM_TAB_FIELDS = \"customTabFields_\",
+            EMACS_PATH = \"emacsPath\",
+            EMACS_ADDITIONAL_PARAMETERS = \"emacsParameters\",
+            EMACS_23 = \"emacsUseV23InsertString\",
+            EDIT_GROUP_MEMBERSHIP_MODE = \"groupEditGroupMembershipMode\",
+            PDF_PREVIEW = \"pdfPreview\",
+            SHOWONELETTERHEADINGFORICONCOLUMNS = \"showOneLetterHeadingForIconColumns\",
+            EDITOR_EMACS_KEYBINDINGS = \"editorEMACSkeyBindings\",
+            EDITOR_EMACS_KEYBINDINGS_REBIND_CA = \"editorEMACSkeyBindingsRebindCA\",
+            SHORTEST_TO_COMPLETE = \"shortestToComplete\",
+            AUTOCOMPLETE_FIRSTNAME_MODE = \"autoCompFirstNameMode\",
+            // here are the possible values for _MODE:
+            AUTOCOMPLETE_FIRSTNAME_MODE_BOTH = \"both\",
+            AUTOCOMPLETE_FIRSTNAME_MODE_ONLY_FULL = \"fullOnly\",
+            AUTOCOMPLETE_FIRSTNAME_MODE_ONLY_ABBR = \"abbrOnly\",
+            WRITEFIELD_ADDSPACES = \"writeFieldAddSpaces\",
+            WRITEFIELD_CAMELCASENAME = \"writeFieldCamelCase\",
+            UPDATE_TIMESTAMP = \"updateTimestamp\",
+            PRIMARY_SORT_FIELD = \"priSort\",
+            PRIMARY_SORT_DESCENDING = \"priDescending\",
+            SECONDARY_SORT_FIELD = \"secSort\",
+            SECONDARY_SORT_DESCENDING = \"secDescending\",
+            TERTIARY_SORT_FIELD = \"terSort\",
+            TERTIARY_SORT_DESCENDING = \"terDescending\",
+            SAVE_IN_ORIGINAL_ORDER = \"saveInOriginalOrder\",
+            SAVE_IN_SPECIFIED_ORDER = \"saveInSpecifiedOrder\",
+            SAVE_PRIMARY_SORT_FIELD = \"savePriSort\",
+            SAVE_PRIMARY_SORT_DESCENDING = \"savePriDescending\",
+            SAVE_SECONDARY_SORT_FIELD = \"saveSecSort\",
+            SAVE_SECONDARY_SORT_DESCENDING = \"saveSecDescending\",
+            SAVE_TERTIARY_SORT_FIELD = \"saveTerSort\",
+            SAVE_TERTIARY_SORT_DESCENDING = \"saveTerDescending\",
+            EXPORT_IN_ORIGINAL_ORDER = \"exportInOriginalOrder\",
+            EXPORT_IN_SPECIFIED_ORDER = \"exportInSpecifiedOrder\",
+            EXPORT_PRIMARY_SORT_FIELD = \"exportPriSort\",
+            EXPORT_PRIMARY_SORT_DESCENDING = \"exportPriDescending\",
+            EXPORT_SECONDARY_SORT_FIELD = \"exportSecSort\",
+            EXPORT_SECONDARY_SORT_DESCENDING = \"exportSecDescending\",
+            EXPORT_TERTIARY_SORT_FIELD = \"exportTerSort\",
+            EXPORT_TERTIARY_SORT_DESCENDING = \"exportTerDescending\";
 
     // This String is used in the encoded list in prefs of external file type
     // modifications, in order to indicate a removed default file type:
     public static final String FILE_TYPE_REMOVED_FLAG = \"REMOVED\";
 
-    private static final char[][] VALUE_DELIMITERS =
-            new char[][]{ {'\"', '\"'}, {'{', '}'} };
+    private static final char[][] VALUE_DELIMITERS
+            = new char[][]{{'\"', '\"'}, {'{', '}'}};
 
     public String WRAPPED_USERNAME, MARKING_WITH_NUMBER_PATTERN;
 
     Preferences prefs;
     public HashMap<String, Object> defaults = new HashMap<String, Object>();
-    public HashMap<String, String>
-        keyBinds = new HashMap<String, String>(),
-        defKeyBinds = new HashMap<String, String>();
+    public HashMap<String, String> keyBinds = new HashMap<String, String>(),
+            defKeyBinds = new HashMap<String, String>();
     private HashSet<String> putBracesAroundCapitalsFields = new HashSet<String>(4);
     private HashSet<String> nonWrappableFields = new HashSet<String>(5);
     private static LabelPattern keyPattern;
 
     // Object containing custom export formats:
     public CustomExportList customExports;
 
-    /** Set with all custom {@link net.sf.jabref.imports.ImportFormat}s */
+    /**
+     * Set with all custom {@link net.sf.jabref.imports.ImportFormat}s
+     */
     public CustomImportList customImports;
 
     // Object containing info about customized entry editor tabs.
     private EntryEditorTabList tabList = null;
-
     // Map containing all registered external file types:
     private TreeSet<ExternalFileType> externalFileTypes = new TreeSet<ExternalFileType>();
 
-    public final ExternalFileType HTML_FALLBACK_TYPE =
-            new ExternalFileType(\"URL\", \"html\", \"text/html\", \"\", \"www\");
+    public final ExternalFileType HTML_FALLBACK_TYPE
+            = new ExternalFileType(\"URL\", \"html\", \"text/html\", \"\", \"www\");
 
     // The following field is used as a global variable during the export of a database.
     // By setting this field to the path of the database's default file directory, formatters
@@ -133,69 +148,120 @@
     // The following field is used as a global variable during the export of a database.
     // It is used to hold custom name formatters defined by a custom export filter.
     // It is set before the export starts:
-    public HashMap<String,String> customExportNameFormatters = null;
+    public HashMap<String, String> customExportNameFormatters = null;
 
     // The only instance of this class:
     private static JabRefPreferences singleton = null;
 
     public static JabRefPreferences getInstance() {
-		if (singleton == null)
-			singleton = new JabRefPreferences();
-		return singleton;
-	}
+        if (singleton == null) {
+            singleton = new JabRefPreferences();
+        }
+        return singleton;
+    }
+
+    // Upgrade the preferences for the current version
+    // The old preference is kept in case an old version of JabRef is used with 
+    // these preferences, but it is only used when the new preference does not 
+    // exist
+    private void upgradeOldPreferences() {
+        if (prefs.get(SAVE_IN_SPECIFIED_ORDER, null) == null) {
+            if (prefs.getBoolean(\"saveInStandardOrder\", false)) {
+                putBoolean(SAVE_IN_SPECIFIED_ORDER, true);
+                put(SAVE_PRIMARY_SORT_FIELD, \"author\");
+                put(SAVE_SECONDARY_SORT_FIELD, \"editor\");
+                put(SAVE_TERTIARY_SORT_FIELD, \"year\");
+                putBoolean(SAVE_PRIMARY_SORT_DESCENDING, false);
+                putBoolean(SAVE_SECONDARY_SORT_DESCENDING, false);
+                putBoolean(SAVE_TERTIARY_SORT_DESCENDING, false);
+            } else if (prefs.getBoolean(\"saveInTitleOrder\", false)) {
+                // saveInTitleOrder => title, author, editor
+                putBoolean(SAVE_IN_SPECIFIED_ORDER, true);
+                put(SAVE_PRIMARY_SORT_FIELD, \"title\");
+                put(SAVE_SECONDARY_SORT_FIELD, \"author\");
+                put(SAVE_TERTIARY_SORT_FIELD, \"editor\");
+                putBoolean(SAVE_PRIMARY_SORT_DESCENDING, false);
+                putBoolean(SAVE_SECONDARY_SORT_DESCENDING, false);
+                putBoolean(SAVE_TERTIARY_SORT_DESCENDING, false);
+            }
+        }
+        
+        if (prefs.get(EXPORT_IN_SPECIFIED_ORDER, null) == null) {
+            if (prefs.getBoolean(\"exportInStandardOrder\", false)) {
+                putBoolean(EXPORT_IN_SPECIFIED_ORDER, true);
+                put(EXPORT_PRIMARY_SORT_FIELD, \"author\");
+                put(EXPORT_SECONDARY_SORT_FIELD, \"editor\");
+                put(EXPORT_TERTIARY_SORT_FIELD, \"year\");
+                putBoolean(EXPORT_PRIMARY_SORT_DESCENDING, false);
+                putBoolean(EXPORT_SECONDARY_SORT_DESCENDING, false);
+                putBoolean(EXPORT_TERTIARY_SORT_DESCENDING, false);
+            } else if (prefs.getBoolean(\"exportInTitleOrder\", false)) {
+                // exportInTitleOrder => title, author, editor
+                putBoolean(EXPORT_IN_SPECIFIED_ORDER, true);
+                put(EXPORT_PRIMARY_SORT_FIELD, \"title\");
+                put(EXPORT_SECONDARY_SORT_FIELD, \"author\");
+                put(EXPORT_TERTIARY_SORT_FIELD, \"editor\");
+                putBoolean(EXPORT_PRIMARY_SORT_DESCENDING, false);
+                putBoolean(EXPORT_SECONDARY_SORT_DESCENDING, false);
+                putBoolean(EXPORT_TERTIARY_SORT_DESCENDING, false);
+            }
+        }
+    }
 
     // The constructor is made private to enforce this as a singleton class:
     private JabRefPreferences() {
 
         try {
-            if (new File(\"jabref.xml\").exists()){
+            if (new File(\"jabref.xml\").exists()) {
                 importPreferences(\"jabref.xml\");
             }
         } catch (IOException e) {
             Globals.logger(\"Could not import preferences from jabref.xml:\" + e.getLocalizedMessage());
         }
-        
+
+        // load user preferences 
         prefs = Preferences.userNodeForPackage(JabRef.class);
-        
+        upgradeOldPreferences();
+
         if (Globals.osName.equals(Globals.MAC)) {
-			//defaults.put(\"pdfviewer\", \"/Applications/Preview.app\");
-			//defaults.put(\"psviewer\", \"/Applications/Preview.app\");
-			//defaults.put(\"htmlviewer\", \"/Applications/Safari.app\");
-        	defaults.put(EMACS_PATH, \"emacsclient\");
-        	defaults.put(EMACS_23, true);
-        	defaults.put(EMACS_ADDITIONAL_PARAMETERS, \"-n -e\");
+            //defaults.put(\"pdfviewer\", \"/Applications/Preview.app\");
+            //defaults.put(\"psviewer\", \"/Applications/Preview.app\");
+            //defaults.put(\"htmlviewer\", \"/Applications/Safari.app\");
+            defaults.put(EMACS_PATH, \"emacsclient\");
+            defaults.put(EMACS_23, true);
+            defaults.put(EMACS_ADDITIONAL_PARAMETERS, \"-n -e\");
             defaults.put(\"fontFamily\", \"SansSerif\");
 
-		} else if (Globals.osName.toLowerCase().startsWith(\"windows\")) {
-			//defaults.put(\"pdfviewer\", \"cmd.exe /c start /b\");
-			//defaults.put(\"psviewer\", \"cmd.exe /c start /b\");
-			//defaults.put(\"htmlviewer\", \"cmd.exe /c start /b\");
-			defaults.put(\"lookAndFeel\", \"com.jgoodies.looks.windows.WindowsLookAndFeel\");
+        } else if (Globals.osName.toLowerCase().startsWith(\"windows\")) {
+            //defaults.put(\"pdfviewer\", \"cmd.exe /c start /b\");
+            //defaults.put(\"psviewer\", \"cmd.exe /c start /b\");
+            //defaults.put(\"htmlviewer\", \"cmd.exe /c start /b\");
+            defaults.put(\"lookAndFeel\", \"com.jgoodies.looks.windows.WindowsLookAndFeel\");
             defaults.put(\"winEdtPath\", \"C:\\Program Files\\WinEdt Team\\WinEdt\\WinEdt.exe\");
             defaults.put(\"latexEditorPath\", \"C:\\Program Files\\LEd\\LEd.exe\");
-        	defaults.put(EMACS_PATH, \"emacsclient.exe\");
-        	defaults.put(EMACS_23, true);
-        	defaults.put(EMACS_ADDITIONAL_PARAMETERS, \"-n -e\");
+            defaults.put(EMACS_PATH, \"emacsclient.exe\");
+            defaults.put(EMACS_23, true);
+            defaults.put(EMACS_ADDITIONAL_PARAMETERS, \"-n -e\");
             defaults.put(\"fontFamily\", \"Arial\");
 
         } else {
-			//defaults.put(\"pdfviewer\", \"evince\");
-			//defaults.put(\"psviewer\", \"gv\");
-			//defaults.put(\"htmlviewer\", \"firefox\");
-			defaults.put(\"lookAndFeel\", \"com.jgoodies.plaf.plastic.Plastic3DLookAndFeel\");
+            //defaults.put(\"pdfviewer\", \"evince\");
+            //defaults.put(\"psviewer\", \"gv\");
+            //defaults.put(\"htmlviewer\", \"firefox\");
+            defaults.put(\"lookAndFeel\", \"com.jgoodies.plaf.plastic.Plastic3DLookAndFeel\");
             defaults.put(\"fontFamily\", \"SansSerif\");
-            
-        	// linux
-        	defaults.put(EMACS_PATH, \"gnuclient\");
-        	defaults.put(EMACS_23, false);
-        	defaults.put(EMACS_ADDITIONAL_PARAMETERS, \"-batch -eval\");
-		}
-		defaults.put(\"useProxy\", Boolean.FALSE);
+
+            // linux
+            defaults.put(EMACS_PATH, \"gnuclient\");
+            defaults.put(EMACS_23, false);
+            defaults.put(EMACS_ADDITIONAL_PARAMETERS, \"-batch -eval\");
+        }
+        defaults.put(\"useProxy\", Boolean.FALSE);
         defaults.put(\"proxyHostname\", \"my proxy host\");
         defaults.put(\"proxyPort\", \"my proxy port\");
         defaults.put(PDF_PREVIEW, Boolean.FALSE);
         defaults.put(\"useDefaultLookAndFeel\", Boolean.TRUE);
-        defaults.put(\"lyxpipe\", System.getProperty(\"user.home\")+File.separator+\".lyx/lyxpipe\");
+        defaults.put(\"lyxpipe\", System.getProperty(\"user.home\") + File.separator + \".lyx/lyxpipe\");
         defaults.put(\"vim\", \"vim\");
         defaults.put(\"vimServer\", \"vim\");
         defaults.put(\"posX\", new Integer(0));
@@ -215,20 +281,38 @@ private JabRefPreferences() {
         defaults.put(\"namesLastOnly\", Boolean.TRUE); // \"Show last names only\"
         defaults.put(\"language\", \"en\");
         defaults.put(\"showShort\", Boolean.TRUE);
-        defaults.put(\"priSort\", \"author\");
-        defaults.put(\"priDescending\", Boolean.FALSE);
-        defaults.put(\"priBinary\", Boolean.FALSE);
-        defaults.put(\"secSort\", \"year\");
-        defaults.put(\"secDescending\", Boolean.TRUE);
-        defaults.put(\"terSort\", \"author\");
-        defaults.put(\"terDescending\", Boolean.FALSE);
+
+        // Sorting preferences
+        defaults.put(PRIMARY_SORT_FIELD, \"author\");
+        defaults.put(PRIMARY_SORT_DESCENDING, Boolean.FALSE);
+        defaults.put(SECONDARY_SORT_FIELD, \"year\");
+        defaults.put(SECONDARY_SORT_DESCENDING, Boolean.TRUE);
+        defaults.put(TERTIARY_SORT_FIELD, \"author\");
+        defaults.put(TERTIARY_SORT_DESCENDING, Boolean.FALSE);
+        defaults.put(SAVE_IN_ORIGINAL_ORDER, Boolean.FALSE);
+        defaults.put(SAVE_IN_SPECIFIED_ORDER, Boolean.FALSE);
+        defaults.put(SAVE_PRIMARY_SORT_FIELD, \"bibtexkey\");
+        defaults.put(SAVE_PRIMARY_SORT_DESCENDING, Boolean.FALSE);
+        defaults.put(SAVE_SECONDARY_SORT_FIELD, \"author\");
+        defaults.put(SAVE_SECONDARY_SORT_DESCENDING, Boolean.TRUE);
+        defaults.put(SAVE_TERTIARY_SORT_FIELD, \"\");
+        defaults.put(SAVE_TERTIARY_SORT_DESCENDING, Boolean.TRUE);
+        defaults.put(EXPORT_IN_ORIGINAL_ORDER, Boolean.FALSE);
+        defaults.put(EXPORT_IN_SPECIFIED_ORDER, Boolean.FALSE);
+        defaults.put(EXPORT_PRIMARY_SORT_FIELD, \"bibtexkey\");
+        defaults.put(EXPORT_PRIMARY_SORT_DESCENDING, Boolean.FALSE);
+        defaults.put(EXPORT_SECONDARY_SORT_FIELD, \"author\");
+        defaults.put(EXPORT_SECONDARY_SORT_DESCENDING, Boolean.TRUE);
+        defaults.put(EXPORT_TERTIARY_SORT_FIELD, \"\");
+        defaults.put(EXPORT_TERTIARY_SORT_DESCENDING, Boolean.TRUE);
+
         defaults.put(\"columnNames\", \"entrytype;author;title;year;journal;owner;timestamp;bibtexkey\");
-        defaults.put(\"columnWidths\",\"75;280;400;60;100;100;100;100\");
-        defaults.put(PersistenceTableColumnListener.ACTIVATE_PREF_KEY, 
-        		new Boolean(PersistenceTableColumnListener.DEFAULT_ENABLED));
+        defaults.put(\"columnWidths\", \"75;280;400;60;100;100;100;100\");
+        defaults.put(PersistenceTableColumnListener.ACTIVATE_PREF_KEY,
+                new Boolean(PersistenceTableColumnListener.DEFAULT_ENABLED));
         defaults.put(\"xmpPrivacyFilters\", \"pdf;timestamp;keywords;owner;note;review\");
         defaults.put(\"useXmpPrivacyFilter\", Boolean.FALSE);
-        defaults.put(\"numberColWidth\",new Integer(GUIGlobals.NUMBER_COL_LENGTH));
+        defaults.put(\"numberColWidth\", new Integer(GUIGlobals.NUMBER_COL_LENGTH));
         defaults.put(\"workingDirectory\", System.getProperty(\"user.home\"));
         defaults.put(\"exportWorkingDirectory\", System.getProperty(\"user.home\"));
         defaults.put(\"importWorkingDirectory\", System.getProperty(\"user.home\"));
@@ -253,12 +337,7 @@ private JabRefPreferences() {
         defaults.put(\"searchAll\", Boolean.FALSE);
         defaults.put(\"incrementS\", Boolean.FALSE);
         defaults.put(\"searchAutoComplete\", Boolean.TRUE);
-        defaults.put(\"saveInStandardOrder\", Boolean.TRUE);
-        defaults.put(\"saveInOriginalOrder\", Boolean.FALSE);
-        defaults.put(\"saveInTitleOrder\", Boolean.FALSE);
-        defaults.put(\"exportInStandardOrder\", Boolean.TRUE);
-        defaults.put(\"exportInOriginalOrder\", Boolean.FALSE);
-        defaults.put(\"exportInTitleOrder\", Boolean.FALSE);
+
         defaults.put(\"selectS\", Boolean.FALSE);
         defaults.put(\"regExpSearch\", Boolean.TRUE);
         defaults.put(\"highLightWords\", Boolean.TRUE);
@@ -284,7 +363,7 @@ private JabRefPreferences() {
         defaults.put(\"groupExpandTree\", Boolean.TRUE);
         defaults.put(\"groupAutoShow\", Boolean.TRUE);
         defaults.put(\"groupAutoHide\", Boolean.TRUE);
-        defaults.put(JabRefPreferences.GROUP_SHOW_NUMBER_OF_ELEMENTS, Boolean.FALSE);
+        defaults.put(GROUP_SHOW_NUMBER_OF_ELEMENTS, Boolean.FALSE);
         defaults.put(\"autoAssignGroup\", Boolean.TRUE);
         defaults.put(\"groupKeywordSeparator\", \", \");
         defaults.put(EDIT_GROUP_MEMBERSHIP_MODE, Boolean.FALSE);
@@ -298,9 +377,9 @@ private JabRefPreferences() {
         defaults.put(\"memoryStickMode\", Boolean.FALSE);
         defaults.put(\"renameOnMoveFileToFileDir\", Boolean.TRUE);
 
-    // The general fields stuff is made obsolete by the CUSTOM_TAB_... entries.
-        defaults.put(\"generalFields\", \"crossref;keywords;file;doi;url;urldate;\"+
-                     \"pdf;comment;owner\");
+        // The general fields stuff is made obsolete by the CUSTOM_TAB_... entries.
+        defaults.put(\"generalFields\", \"crossref;keywords;file;doi;url;urldate;\"
+                + \"pdf;comment;owner\");
 
         defaults.put(\"useCustomIconTheme\", Boolean.FALSE);
         defaults.put(\"customIconThemeFile\", \"/home/alver/div/crystaltheme_16/Icons.properties\");
@@ -344,18 +423,18 @@ private JabRefPreferences() {
         defaults.put(\"preferUrlDoi\", Boolean.FALSE);
         defaults.put(\"fileColumn\", Boolean.TRUE);
         defaults.put(\"arxivColumn\", Boolean.FALSE);
-        
+
         defaults.put(SpecialFieldsUtils.PREF_SPECIALFIELDSENABLED, SpecialFieldsUtils.PREF_SPECIALFIELDSENABLED_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_SHOWCOLUMN_PRIORITY, SpecialFieldsUtils.PREF_SHOWCOLUMN_PRIORITY_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_SHOWCOLUMN_QUALITY, SpecialFieldsUtils.PREF_SHOWCOLUMN_QUALITY_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_SHOWCOLUMN_RANKING, SpecialFieldsUtils.PREF_SHOWCOLUMN_RANKING_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_RANKING_COMPACT, SpecialFieldsUtils.PREF_RANKING_COMPACT_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_SHOWCOLUMN_RELEVANCE, SpecialFieldsUtils.PREF_SHOWCOLUMN_RELEVANCE_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_AUTOSYNCSPECIALFIELDSTOKEYWORDS, SpecialFieldsUtils.PREF_AUTOSYNCSPECIALFIELDSTOKEYWORDS_DEFAULT);
-    	defaults.put(SpecialFieldsUtils.PREF_SERIALIZESPECIALFIELDS, SpecialFieldsUtils.PREF_SERIALIZESPECIALFIELDS_DEFAULT);
-    	
-    	defaults.put(SHOWONELETTERHEADINGFORICONCOLUMNS, Boolean.FALSE);
-        
+        defaults.put(SpecialFieldsUtils.PREF_SERIALIZESPECIALFIELDS, SpecialFieldsUtils.PREF_SERIALIZESPECIALFIELDS_DEFAULT);
+
+        defaults.put(SHOWONELETTERHEADINGFORICONCOLUMNS, Boolean.FALSE);
+
         defaults.put(\"useOwner\", Boolean.TRUE);
         defaults.put(\"overwriteOwner\", Boolean.FALSE);
         defaults.put(\"allowTableEditing\", Boolean.FALSE);
@@ -373,49 +452,48 @@ private JabRefPreferences() {
         defaults.put(\"previewEnabled\", Boolean.TRUE);
         defaults.put(\"activePreview\", 0);
         defaults.put(\"preview0\", \"<font face=\\"arial\\">\"
-                     +\"<b><i>\\bibtextype</i><a name=\\"\\bibtexkey\\">\\begin{bibtexkey} (\\bibtexkey)</a>\"
-                     +\"\\end{bibtexkey}</b><br>__NEWLINE__\"
-                     +\"\\begin{author} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\author}<BR>\\end{author}__NEWLINE__\"
-                     +\"\\begin{editor} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\editor} \"
-                     +\"<i>(\\format[IfPlural(Eds.,Ed.)]{\\editor})</i><BR>\\end{editor}__NEWLINE__\"
-                     +\"\\begin{title} \\format[HTMLChars]{\\title} \\end{title}<BR>__NEWLINE__\"
-                     +\"\\begin{chapter} \\format[HTMLChars]{\\chapter}<BR>\\end{chapter}__NEWLINE__\"
-                     +\"\\begin{journal} <em>\\format[HTMLChars]{\\journal}, </em>\\end{journal}__NEWLINE__\"
-                     // Include the booktitle field for @inproceedings, @proceedings, etc.
-                     +\"\\begin{booktitle} <em>\\format[HTMLChars]{\\booktitle}, </em>\\end{booktitle}__NEWLINE__\"
-                     +\"\\begin{school} <em>\\format[HTMLChars]{\\school}, </em>\\end{school}__NEWLINE__\"
-                     +\"\\begin{institution} <em>\\format[HTMLChars]{\\institution}, </em>\\end{institution}__NEWLINE__\"
-                     +\"\\begin{publisher} <em>\\format[HTMLChars]{\\publisher}, </em>\\end{publisher}__NEWLINE__\"
-                     +\"\\begin{year}<b>\\year</b>\\end{year}\\begin{volume}<i>, \\volume</i>\\end{volume}\"
-                     +\"\\begin{pages}, \\format[FormatPagesForHTML]{\\pages} \\end{pages}__NEWLINE__\"
-                     +\"\\begin{abstract}<BR><BR><b>Abstract: </b> \\format[HTMLChars]{\\abstract} \\end{abstract}__NEWLINE__\"
-                     +\"\\begin{review}<BR><BR><b>Review: </b> \\format[HTMLChars]{\\review} \\end{review}\"
-                     +\"</dd>__NEWLINE__<p></p></font>\");
+                + \"<b><i>\\bibtextype</i><a name=\\"\\bibtexkey\\">\\begin{bibtexkey} (\\bibtexkey)</a>\"
+                + \"\\end{bibtexkey}</b><br>__NEWLINE__\"
+                + \"\\begin{author} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\author}<BR>\\end{author}__NEWLINE__\"
+                + \"\\begin{editor} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\editor} \"
+                + \"<i>(\\format[IfPlural(Eds.,Ed.)]{\\editor})</i><BR>\\end{editor}__NEWLINE__\"
+                + \"\\begin{title} \\format[HTMLChars]{\\title} \\end{title}<BR>__NEWLINE__\"
+                + \"\\begin{chapter} \\format[HTMLChars]{\\chapter}<BR>\\end{chapter}__NEWLINE__\"
+                + \"\\begin{journal} <em>\\format[HTMLChars]{\\journal}, </em>\\end{journal}__NEWLINE__\"
+                // Include the booktitle field for @inproceedings, @proceedings, etc.
+                + \"\\begin{booktitle} <em>\\format[HTMLChars]{\\booktitle}, </em>\\end{booktitle}__NEWLINE__\"
+                + \"\\begin{school} <em>\\format[HTMLChars]{\\school}, </em>\\end{school}__NEWLINE__\"
+                + \"\\begin{institution} <em>\\format[HTMLChars]{\\institution}, </em>\\end{institution}__NEWLINE__\"
+                + \"\\begin{publisher} <em>\\format[HTMLChars]{\\publisher}, </em>\\end{publisher}__NEWLINE__\"
+                + \"\\begin{year}<b>\\year</b>\\end{year}\\begin{volume}<i>, \\volume</i>\\end{volume}\"
+                + \"\\begin{pages}, \\format[FormatPagesForHTML]{\\pages} \\end{pages}__NEWLINE__\"
+                + \"\\begin{abstract}<BR><BR><b>Abstract: </b> \\format[HTMLChars]{\\abstract} \\end{abstract}__NEWLINE__\"
+                + \"\\begin{review}<BR><BR><b>Review: </b> \\format[HTMLChars]{\\review} \\end{review}\"
+                + \"</dd>__NEWLINE__<p></p></font>\");
         defaults.put(\"preview1\", \"<font face=\\"arial\\">\"
-                     +\"<b><i>\\bibtextype</i><a name=\\"\\bibtexkey\\">\\begin{bibtexkey} (\\bibtexkey)</a>\"
-                     +\"\\end{bibtexkey}</b><br>__NEWLINE__\"
-                     +\"\\begin{author} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\author}<BR>\\end{author}__NEWLINE__\"
-                     +\"\\begin{editor} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\editor} \"
-                     +\"<i>(\\format[IfPlural(Eds.,Ed.)]{\\editor})</i><BR>\\end{editor}__NEWLINE__\"
-                     +\"\\begin{title} \\format[HTMLChars]{\\title} \\end{title}<BR>__NEWLINE__\"
-                     +\"\\begin{chapter} \\format[HTMLChars]{\\chapter}<BR>\\end{chapter}__NEWLINE__\"
-                     +\"\\begin{journal} <em>\\format[HTMLChars]{\\journal}, </em>\\end{journal}__NEWLINE__\"
-                     // Include the booktitle field for @inproceedings, @proceedings, etc.
-                     +\"\\begin{booktitle} <em>\\format[HTMLChars]{\\booktitle}, </em>\\end{booktitle}__NEWLINE__\"
-                     +\"\\begin{school} <em>\\format[HTMLChars]{\\school}, </em>\\end{school}__NEWLINE__\"
-                     +\"\\begin{institution} <em>\\format[HTMLChars]{\\institution}, </em>\\end{institution}__NEWLINE__\"
-                     +\"\\begin{publisher} <em>\\format[HTMLChars]{\\publisher}, </em>\\end{publisher}__NEWLINE__\"
-                     +\"\\begin{year}<b>\\year</b>\\end{year}\\begin{volume}<i>, \\volume</i>\\end{volume}\"
-                     +\"\\begin{pages}, \\format[FormatPagesForHTML]{\\pages} \\end{pages}\"
-                     +\"</dd>__NEWLINE__<p></p></font>\");
-
+                + \"<b><i>\\bibtextype</i><a name=\\"\\bibtexkey\\">\\begin{bibtexkey} (\\bibtexkey)</a>\"
+                + \"\\end{bibtexkey}</b><br>__NEWLINE__\"
+                + \"\\begin{author} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\author}<BR>\\end{author}__NEWLINE__\"
+                + \"\\begin{editor} \\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\editor} \"
+                + \"<i>(\\format[IfPlural(Eds.,Ed.)]{\\editor})</i><BR>\\end{editor}__NEWLINE__\"
+                + \"\\begin{title} \\format[HTMLChars]{\\title} \\end{title}<BR>__NEWLINE__\"
+                + \"\\begin{chapter} \\format[HTMLChars]{\\chapter}<BR>\\end{chapter}__NEWLINE__\"
+                + \"\\begin{journal} <em>\\format[HTMLChars]{\\journal}, </em>\\end{journal}__NEWLINE__\"
+                // Include the booktitle field for @inproceedings, @proceedings, etc.
+                + \"\\begin{booktitle} <em>\\format[HTMLChars]{\\booktitle}, </em>\\end{booktitle}__NEWLINE__\"
+                + \"\\begin{school} <em>\\format[HTMLChars]{\\school}, </em>\\end{school}__NEWLINE__\"
+                + \"\\begin{institution} <em>\\format[HTMLChars]{\\institution}, </em>\\end{institution}__NEWLINE__\"
+                + \"\\begin{publisher} <em>\\format[HTMLChars]{\\publisher}, </em>\\end{publisher}__NEWLINE__\"
+                + \"\\begin{year}<b>\\year</b>\\end{year}\\begin{volume}<i>, \\volume</i>\\end{volume}\"
+                + \"\\begin{pages}, \\format[FormatPagesForHTML]{\\pages} \\end{pages}\"
+                + \"</dd>__NEWLINE__<p></p></font>\");
 
         // TODO: Currently not possible to edit this setting:
         defaults.put(\"previewPrintButton\", Boolean.FALSE);
         defaults.put(\"autoDoubleBraces\", Boolean.FALSE);
         defaults.put(\"doNotResolveStringsFor\", \"url\");
         defaults.put(\"resolveStringsAllFields\", Boolean.FALSE);
-        defaults.put(\"putBracesAroundCapitals\",\"\");//\"title;journal;booktitle;review;abstract\");
+        defaults.put(\"putBracesAroundCapitals\", \"\");//\"title;journal;booktitle;review;abstract\");
         defaults.put(\"nonWrappableFields\", \"pdf;ps;url;doi;file\");
         defaults.put(\"useImportInspectionDialog\", Boolean.TRUE);
         defaults.put(\"useImportInspectionDialogForSingle\", Boolean.TRUE);
@@ -486,36 +564,32 @@ private JabRefPreferences() {
         defaults.put(\"dbConnectDatabase\", \"jabref\");
         defaults.put(\"dbConnectUsername\", \"root\");
         CleanUpAction.putDefaults(defaults);
-        
+
         // defaults for DroppedFileHandler UI
-    	defaults.put(DroppedFileHandler.DFH_LEAVE, Boolean.FALSE);
-    	defaults.put(DroppedFileHandler.DFH_COPY, Boolean.TRUE);
-    	defaults.put(DroppedFileHandler.DFH_MOVE, Boolean.FALSE);
-    	defaults.put(DroppedFileHandler.DFH_RENAME, Boolean.FALSE);
-        
+        defaults.put(DroppedFileHandler.DFH_LEAVE, Boolean.FALSE);
+        defaults.put(DroppedFileHandler.DFH_COPY, Boolean.TRUE);
+        defaults.put(DroppedFileHandler.DFH_MOVE, Boolean.FALSE);
+        defaults.put(DroppedFileHandler.DFH_RENAME, Boolean.FALSE);
+
         //defaults.put(\"lastAutodetectedImport\", \"\");
-        
         //defaults.put(\"autoRemoveExactDuplicates\", Boolean.FALSE);
         //defaults.put(\"confirmAutoRemoveExactDuplicates\", Boolean.TRUE);
-        
         //defaults.put(\"tempDir\", System.getProperty(\"java.io.tmpdir\"));
         //Util.pr(System.getProperty(\"java.io.tempdir\"));
-
         //defaults.put(\"keyPattern\", new LabelPattern(KEY_PATTERN));
-        
         defaults.put(ImportSettingsTab.PREF_IMPORT_ALWAYSUSE, Boolean.FALSE);
         defaults.put(ImportSettingsTab.PREF_IMPORT_DEFAULT_PDF_IMPORT_STYLE, ImportSettingsTab.DEFAULT_STYLE);
         defaults.put(ImportSettingsTab.PREF_IMPORT_FILENAMEPATTERN, ImportSettingsTab.DEFAULT_FILENAMEPATTERNS[0]);
-        
+
         restoreKeyBindings();
 
         customExports = new CustomExportList(new ExportComparator());
         customImports = new CustomImportList(this);
 
         //defaults.put(\"oooWarning\", Boolean.TRUE);
         updateSpecialFieldHandling();
-        WRAPPED_USERNAME = \"[\"+get(\"defaultOwner\")+\"]\";
-        MARKING_WITH_NUMBER_PATTERN = \"\\[\"+get(\"defaultOwner\").replaceAll(\"\\\\\",\"\\\\\\\\\")+\":(\\d+)\\]\";
+        WRAPPED_USERNAME = \"[\" + get(\"defaultOwner\") + \"]\";
+        MARKING_WITH_NUMBER_PATTERN = \"\\[\" + get(\"defaultOwner\").replaceAll(\"\\\\\", \"\\\\\\\\\") + \":(\\d+)\\]\";
 
         String defaultExpression = \"**/.*[bibtexkey].*\\\\.[extension]\";
         defaults.put(DEFAULT_REG_EXP_SEARCH_EXPRESSION_KEY, defaultExpression);
@@ -526,47 +600,45 @@ private JabRefPreferences() {
         defaults.put(\"useCaseKeeperOnSearch\", Boolean.TRUE);
         defaults.put(\"useUnitFormatterOnSearch\", Boolean.TRUE);
 
-	defaults.put(\"userFileDir\", GUIGlobals.FILE_FIELD + \"Directory\");
-	try {
-	    defaults.put(\"userFileDirInd_Legacy\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\") + \"@\" + InetAddress.getLocalHost().getHostName()); // Legacy setting name - was a bug: @ not allowed inside BibTeX comment text. Retained for backward comp.
-	    defaults.put(\"userFileDirIndividual\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\") + \"-\" + InetAddress.getLocalHost().getHostName()); // Valid setting name
-	}
-	catch(UnknownHostException ex) {
-	    Globals.logger(\"Hostname not found.\");
-	    defaults.put(\"userFileDirInd_Legacy\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\"));
-	    defaults.put(\"userFileDirIndividual\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\"));
-	}
+        defaults.put(\"userFileDir\", GUIGlobals.FILE_FIELD + \"Directory\");
+        try {
+            defaults.put(\"userFileDirInd_Legacy\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\") + \"@\" + InetAddress.getLocalHost().getHostName()); // Legacy setting name - was a bug: @ not allowed inside BibTeX comment text. Retained for backward comp.
+            defaults.put(\"userFileDirIndividual\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\") + \"-\" + InetAddress.getLocalHost().getHostName()); // Valid setting name
+        } catch (UnknownHostException ex) {
+            Globals.logger(\"Hostname not found.\");
+            defaults.put(\"userFileDirInd_Legacy\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\"));
+            defaults.put(\"userFileDirIndividual\", GUIGlobals.FILE_FIELD + \"Directory\" + \"-\" + get(\"defaultOwner\"));
+        }
     }
 
     public void setLanguageDependentDefaultValues() {
 
         // Entry editor tab 0:
-        defaults.put(CUSTOM_TAB_NAME+\"_def0\", Globals.lang(\"General\"));
-            defaults.put(CUSTOM_TAB_FIELDS+\"_def0\", \"crossref;keywords;file;doi;url;\"+
-                         \"comment;owner;timestamp\");
+        defaults.put(CUSTOM_TAB_NAME + \"_def0\", Globals.lang(\"General\"));
+        defaults.put(CUSTOM_TAB_FIELDS + \"_def0\", \"crossref;keywords;file;doi;url;\"
+                + \"comment;owner;timestamp\");
 
         // Entry editor tab 1:
-            defaults.put(CUSTOM_TAB_FIELDS+\"_def1\", \"abstract\");
-        defaults.put(CUSTOM_TAB_NAME+\"_def1\", Globals.lang(\"Abstract\"));
+        defaults.put(CUSTOM_TAB_FIELDS + \"_def1\", \"abstract\");
+        defaults.put(CUSTOM_TAB_NAME + \"_def1\", Globals.lang(\"Abstract\"));
 
-      // Entry editor tab 2: Review Field - used for research comments, etc.
-            defaults.put(CUSTOM_TAB_FIELDS+\"_def2\", \"review\");
-        defaults.put(CUSTOM_TAB_NAME+\"_def2\", Globals.lang(\"Review\"));
+        // Entry editor tab 2: Review Field - used for research comments, etc.
+        defaults.put(CUSTOM_TAB_FIELDS + \"_def2\", \"review\");
+        defaults.put(CUSTOM_TAB_NAME + \"_def2\", Globals.lang(\"Review\"));
 
     }
-    
+
     public static final String DEFAULT_REG_EXP_SEARCH_EXPRESSION_KEY = \"defaultRegExpSearchExpression\";
     public static final String REG_EXP_SEARCH_EXPRESSION_KEY = \"regExpSearchExpression\";
     public static final String USE_REG_EXP_SEARCH_KEY = \"useRegExpSearch\";
     public static final String AUTOLINK_EXACT_KEY_ONLY = \"autolinkExactKeyOnly\";
 
-	public static final String EMAIL_SUBJECT = \"emailSubject\";
-	public static final String OPEN_FOLDERS_OF_ATTACHED_FILES = \"openFoldersOfAttachedFiles\";
+    public static final String EMAIL_SUBJECT = \"emailSubject\";
+    public static final String OPEN_FOLDERS_OF_ATTACHED_FILES = \"openFoldersOfAttachedFiles\";
 
     public static final String GROUP_SHOW_NUMBER_OF_ELEMENTS = \"groupShowNumberOfElements\";
 
-
-	public boolean putBracesAroundCapitals(String fieldName) {
+    public boolean putBracesAroundCapitals(String fieldName) {
         return putBracesAroundCapitalsFields.contains(fieldName);
     }
 
@@ -575,15 +647,17 @@ public void updateSpecialFieldHandling() {
         String fieldString = get(\"putBracesAroundCapitals\");
         if (fieldString.length() > 0) {
             String[] fields = fieldString.split(\";\");
-            for (int i=0; i<fields.length; i++)
+            for (int i = 0; i < fields.length; i++) {
                 putBracesAroundCapitalsFields.add(fields[i].trim());
+            }
         }
         nonWrappableFields.clear();
         fieldString = get(\"nonWrappableFields\");
         if (fieldString.length() > 0) {
             String[] fields = fieldString.split(\";\");
-            for (int i=0; i<fields.length; i++)
+            for (int i = 0; i < fields.length; i++) {
                 nonWrappableFields.add(fields[i].trim());
+            }
         }
 
     }
@@ -599,6 +673,7 @@ public char getValueDelimiters(int index) {
 
     /**
      * Check whether a key is set (differently from null).
+     *
      * @param key The key to check.
      * @return true if the key is set, false otherwise.
      */
@@ -607,7 +682,7 @@ public boolean hasKey(String key) {
     }
 
     public String get(String key) {
-        return prefs.get(key, (String)defaults.get(key));
+        return prefs.get(key, (String) defaults.get(key));
     }
 
     public String get(String key, String def) {
@@ -617,35 +692,35 @@ public String get(String key, String def) {
     public boolean getBoolean(String key) {
         return prefs.getBoolean(key, getBooleanDefault(key));
     }
-    
-    public boolean getBooleanDefault(String key){
-        return ((Boolean)defaults.get(key)).booleanValue();
+
+    public boolean getBooleanDefault(String key) {
+        return ((Boolean) defaults.get(key)).booleanValue();
     }
 
     public double getDouble(String key) {
         return prefs.getDouble(key, getDoubleDefault(key));
     }
-    
-    public double getDoubleDefault(String key){
-        return ((Double)defaults.get(key)).doubleValue();
+
+    public double getDoubleDefault(String key) {
+        return ((Double) defaults.get(key)).doubleValue();
     }
 
     public int getInt(String key) {
         return prefs.getInt(key, getIntDefault(key));
     }
 
     public int getIntDefault(String key) {
-        return ((Integer)defaults.get(key)).intValue();
+        return ((Integer) defaults.get(key)).intValue();
     }
-    
+
     public byte[] getByteArray(String key) {
         return prefs.getByteArray(key, getByteArrayDefault(key));
     }
 
-    public byte[] getByteArrayDefault(String key){
-        return (byte[])defaults.get(key);   
+    public byte[] getByteArrayDefault(String key) {
+        return (byte[]) defaults.get(key);
     }
-    
+
     public void put(String key, String value) {
         prefs.put(key, value);
     }
@@ -671,9 +746,9 @@ public void remove(String key) {
     }
 
     /**
-     * Puts a string array into the Preferences, by linking its elements
-     * with ';' into a single string. Escape characters make the process
-     * transparent even if strings contain ';'.
+     * Puts a string array into the Preferences, by linking its elements with
+     * ';' into a single string. Escape characters make the process transparent
+     * even if strings contain ';'.
      */
     public void putStringArray(String key, String[] value) {
         if (value == null) {
@@ -683,11 +758,11 @@ public void putStringArray(String key, String[] value) {
 
         if (value.length > 0) {
             StringBuffer linked = new StringBuffer();
-            for (int i=0; i<value.length-1; i++) {
+            for (int i = 0; i < value.length - 1; i++) {
                 linked.append(makeEscape(value[i]));
                 linked.append(\";\");
             }
-            linked.append(makeEscape(value[value.length-1]));
+            linked.append(makeEscape(value[value.length - 1]));
             put(key, linked.toString());
         } else {
             put(key, \"\");
@@ -699,8 +774,9 @@ public void putStringArray(String key, String[] value) {
      */
     public String[] getStringArray(String key) {
         String names = get(key);
-        if (names == null)
+        if (names == null) {
             return null;
+        }
 
         StringReader rd = new StringReader(names);
         Vector<String> arr = new Vector<String>();
@@ -709,16 +785,19 @@ public void putStringArray(String key, String[] value) {
             while ((rs = getNextUnit(rd)) != null) {
                 arr.add(rs);
             }
-        } catch (IOException ex) {}
+        } catch (IOException ex) {
+        }
         String[] res = new String[arr.size()];
-        for (int i=0; i<res.length; i++)
+        for (int i = 0; i < res.length; i++) {
             res[i] = arr.elementAt(i);
+        }
 
         return res;
     }
 
     /**
      * Looks up a color definition in preferences, and returns the Color object.
+     *
      * @param key The key for this setting.
      * @return The color corresponding to the setting.
      */
@@ -729,14 +808,15 @@ public Color getColor(String key) {
     }
 
     public Color getDefaultColor(String key) {
-        String value = (String)defaults.get(key);
+        String value = (String) defaults.get(key);
         int[] rgb = getRgb(value);
         return new Color(rgb[0], rgb[1], rgb[2]);
     }
 
     /**
      * Set the default value for a key. This is useful for plugins that need to
      * add default values for the prefs keys they use.
+     *
      * @param key The preferences key.
      * @param value The default value.
      */
@@ -746,6 +826,7 @@ public void putDefaultValue(String key, Object value) {
 
     /**
      * Stores a color in preferences.
+     *
      * @param key The key for this setting.
      * @param color The Color to store.
      */
@@ -760,7 +841,9 @@ public void putColor(String key, Color color) {
     }
 
     /**
-     * Looks up a color definition in preferences, and returns an array containing the RGB values.
+     * Looks up a color definition in preferences, and returns an array
+     * containing the RGB values.
+     *
      * @param value The key for this setting.
      * @return The RGB values corresponding to this color setting.
      */
@@ -774,8 +857,8 @@ public void putColor(String key, Color color) {
     }
 
     /**
-     * Returns the KeyStroke for this binding, as defined by the
-     * defaults, or in the Preferences.
+     * Returns the KeyStroke for this binding, as defined by the defaults, or in
+     * the Preferences.
      */
     public KeyStroke getKey(String bindName) {
 
@@ -792,37 +875,39 @@ public KeyStroke getKey(String bindName) {
             keyBinds.put(bindName, s);
         }
         if (s == null) {
-          Globals.logger(\"Could not get key binding for \\"\" + bindName + \"\\"\");
+            Globals.logger(\"Could not get key binding for \\"\" + bindName + \"\\"\");
         }
 
-        if (Globals.ON_MAC)
-          return getKeyForMac(KeyStroke.getKeyStroke(s));
-        else
-          return KeyStroke.getKeyStroke(s);
+        if (Globals.ON_MAC) {
+            return getKeyForMac(KeyStroke.getKeyStroke(s));
+        } else {
+            return KeyStroke.getKeyStroke(s);
+        }
     }
 
     /**
-     * Returns the KeyStroke for this binding, as defined by the
-     * defaults, or in the Preferences, but adapted for Mac users,
-     * with the Command key preferred instead of Control.
+     * Returns the KeyStroke for this binding, as defined by the defaults, or in
+     * the Preferences, but adapted for Mac users, with the Command key
+     * preferred instead of Control.
      */
     private KeyStroke getKeyForMac(KeyStroke ks) {
-      if (ks == null) return null;
-      int keyCode = ks.getKeyCode();
-      if ((ks.getModifiers() & KeyEvent.CTRL_MASK) == 0) {
-        return ks;
-      }
-      else {
-    	int modifiers = 0;
-        if ((ks.getModifiers() & KeyEvent.SHIFT_MASK) != 0) {
-          modifiers = modifiers | KeyEvent.SHIFT_MASK;
+        if (ks == null) {
+            return null;
         }
-        if ((ks.getModifiers() & KeyEvent.ALT_MASK) != 0) {
-            modifiers = modifiers | KeyEvent.ALT_MASK;
+        int keyCode = ks.getKeyCode();
+        if ((ks.getModifiers() & KeyEvent.CTRL_MASK) == 0) {
+            return ks;
+        } else {
+            int modifiers = 0;
+            if ((ks.getModifiers() & KeyEvent.SHIFT_MASK) != 0) {
+                modifiers = modifiers | KeyEvent.SHIFT_MASK;
+            }
+            if ((ks.getModifiers() & KeyEvent.ALT_MASK) != 0) {
+                modifiers = modifiers | KeyEvent.ALT_MASK;
+            }
+
+            return KeyStroke.getKeyStroke(keyCode, Globals.getShortcutMask() + modifiers);
         }
-        
-        return KeyStroke.getKeyStroke(keyCode, Globals.getShortcutMask()+modifiers);
-      }
     }
 
     /**
@@ -839,9 +924,9 @@ private KeyStroke getKeyForMac(KeyStroke ks) {
         return defKeyBinds;
     }
 
-
     /**
      * Clear all preferences.
+     *
      * @throws BackingStoreException
      */
     public void clear() throws BackingStoreException {
@@ -851,11 +936,12 @@ public void clear() throws BackingStoreException {
     public void clear(String key) throws BackingStoreException {
         prefs.remove(key);
     }
+
     /**
      * Calling this method will write all preferences into the preference store.
      */
     public void flush() {
-        if (getBoolean(\"memoryStickMode\")){
+        if (getBoolean(\"memoryStickMode\")) {
             try {
                 exportPreferences(\"jabref.xml\");
             } catch (IOException e) {
@@ -870,17 +956,17 @@ public void flush() {
     }
 
     /**
-     * Stores new key bindings into Preferences, provided they
-     * actually differ from the old ones.
+     * Stores new key bindings into Preferences, provided they actually differ
+     * from the old ones.
      */
     public void setNewKeyBindings(HashMap<String, String> newBindings) {
         if (!newBindings.equals(keyBinds)) {
             // This confirms that the bindings have actually changed.
             String[] bindNames = new String[newBindings.size()],
-                bindings = new String[newBindings.size()];
+                    bindings = new String[newBindings.size()];
             int index = 0;
-            for (Iterator<String> i=newBindings.keySet().iterator();
-                 i.hasNext();) {
+            for (Iterator<String> i = newBindings.keySet().iterator();
+                    i.hasNext();) {
                 String nm = i.next();
                 String bnd = newBindings.get(nm);
                 bindNames[index] = nm;
@@ -893,84 +979,85 @@ public void setNewKeyBindings(HashMap<String, String> newBindings) {
         }
     }
 
-
-        /**
-         * Fetches key patterns from preferences
-         * Not cached
-         * 
-         * @return LabelPattern containing all keys. Returned LabelPattern has no parent
-         */
-        public LabelPattern getKeyPattern(){
-            keyPattern = new LabelPattern();
-            Preferences pre = Preferences.userNodeForPackage
-                (net.sf.jabref.labelPattern.LabelPattern.class);
-            try {
-                String[] keys = pre.keys();
-            if (keys.length > 0) for (int i=0; i<keys.length; i++)
-                keyPattern.addLabelPattern(keys[i], pre.get(keys[i], null));
-            } catch (BackingStoreException ex) {
-                Globals.logger(\"BackingStoreException in JabRefPreferences.getKeyPattern\");
+    /**
+     * Fetches key patterns from preferences Not cached
+     *
+     * @return LabelPattern containing all keys. Returned LabelPattern has no
+     * parent
+     */
+    public LabelPattern getKeyPattern() {
+        keyPattern = new LabelPattern();
+        Preferences pre = Preferences.userNodeForPackage(net.sf.jabref.labelPattern.LabelPattern.class);
+        try {
+            String[] keys = pre.keys();
+            if (keys.length > 0) {
+                for (int i = 0; i < keys.length; i++) {
+                    keyPattern.addLabelPattern(keys[i], pre.get(keys[i], null));
+                }
             }
-            return keyPattern;
+        } catch (BackingStoreException ex) {
+            Globals.logger(\"BackingStoreException in JabRefPreferences.getKeyPattern\");
         }
+        return keyPattern;
+    }
 
-        /**
-         * Adds the given key pattern to the preferences
-         * 
-         * @param pattern the pattern to store
-         */
-        public void putKeyPattern(LabelPattern pattern){
-            keyPattern = pattern;
-            LabelPattern parent = pattern.getParent();
-
-            // Store overridden definitions to Preferences.
-            Preferences pre = Preferences.userNodeForPackage
-                (net.sf.jabref.labelPattern.LabelPattern.class);
-            try {
-                pre.clear(); // We remove all old entries.
-            } catch (BackingStoreException ex) {
-                Globals.logger(\"BackingStoreException in JabRefPreferences.putKeyPattern\");
-            }
+    /**
+     * Adds the given key pattern to the preferences
+     *
+     * @param pattern the pattern to store
+     */
+    public void putKeyPattern(LabelPattern pattern) {
+        keyPattern = pattern;
+        LabelPattern parent = pattern.getParent();
 
-            for (String s: pattern.keySet()) {
-                ArrayList<String> value = pattern.get(s);
-                if (value != null) {
-                    // no default value
-                    // the first entry in the array is the full pattern
-                    // see net.sf.jabref.labelPattern.LabelPatternUtil.split(String)
-                    pre.put(s, value.get(0));
-                }
+        // Store overridden definitions to Preferences.
+        Preferences pre = Preferences.userNodeForPackage(net.sf.jabref.labelPattern.LabelPattern.class);
+        try {
+            pre.clear(); // We remove all old entries.
+        } catch (BackingStoreException ex) {
+            Globals.logger(\"BackingStoreException in JabRefPreferences.putKeyPattern\");
+        }
+
+        for (String s : pattern.keySet()) {
+            ArrayList<String> value = pattern.get(s);
+            if (value != null) {
+                // no default value
+                // the first entry in the array is the full pattern
+                // see net.sf.jabref.labelPattern.LabelPatternUtil.split(String)
+                pre.put(s, value.get(0));
             }
         }
+    }
 
     private void restoreKeyBindings() {
         // Define default keybindings.
         defineDefaultKeyBindings();
 
         // First read the bindings, and their names.
         String[] bindNames = getStringArray(\"bindNames\"),
-                 bindings  = getStringArray(\"bindings\");
+                bindings = getStringArray(\"bindings\");
 
         // Then set up the key bindings HashMap.
         if ((bindNames == null) || (bindings == null)
-            || (bindNames.length != bindings.length)) {
+                || (bindNames.length != bindings.length)) {
             // Nothing defined in Preferences, or something is wrong.
             setDefaultKeyBindings();
             return;
         }
 
-        for (int i=0; i<bindNames.length; i++)
+        for (int i = 0; i < bindNames.length; i++) {
             keyBinds.put(bindNames[i], bindings[i]);
+        }
     }
 
     private void setDefaultKeyBindings() {
         keyBinds = defKeyBinds;
     }
- 
+
     private void defineDefaultKeyBindings() {
-        defKeyBinds.put(\"Push to application\",\"ctrl L\");
-      defKeyBinds.put(\"Push to LyX\",\"ctrl L\");
-      defKeyBinds.put(\"Push to WinEdt\",\"ctrl shift W\");
+        defKeyBinds.put(\"Push to application\", \"ctrl L\");
+        defKeyBinds.put(\"Push to LyX\", \"ctrl L\");
+        defKeyBinds.put(\"Push to WinEdt\", \"ctrl shift W\");
         defKeyBinds.put(\"Quit JabRef\", \"ctrl Q\");
         defKeyBinds.put(\"Open database\", \"ctrl O\");
         defKeyBinds.put(\"Save database\", \"ctrl S\");
@@ -1084,27 +1171,28 @@ private String getNextUnit(Reader data) throws IOException {
         StringBuffer res = new StringBuffer();
         while (!done && ((c = data.read()) != -1)) {
             if (c == '\\') {
-                if (!escape)
+                if (!escape) {
                     escape = true;
-                else {
+                } else {
                     escape = false;
                     res.append('\\');
                 }
             } else {
                 if (c == ';') {
-                    if (!escape)
+                    if (!escape) {
                         done = true;
-                    else
+                    } else {
                         res.append(';');
+                    }
                 } else {
-                    res.append((char)c);
+                    res.append((char) c);
                 }
                 escape = false;
             }
         }
         if (res.length() > 0) {
             return res.toString();
-        } else if (c ==-1) {
+        } else if (c == -1) {
             // end of stream
             return null;
         } else {
@@ -1115,42 +1203,42 @@ private String getNextUnit(Reader data) throws IOException {
     private String makeEscape(String s) {
         StringBuffer sb = new StringBuffer();
         int c;
-        for (int i=0; i<s.length(); i++) {
+        for (int i = 0; i < s.length(); i++) {
             c = s.charAt(i);
-            if ((c == '\\') || (c == ';'))
+            if ((c == '\\') || (c == ';')) {
                 sb.append('\\');
-            sb.append((char)c);
+            }
+            sb.append((char) c);
         }
         return sb.toString();
     }
 
     /**
-     * Stores all information about the entry type in preferences, with
-     * the tag given by number.
+     * Stores all information about the entry type in preferences, with the tag
+     * given by number.
      */
     public void storeCustomEntryType(CustomEntryType tp, int number) {
-        String nr = \"\"+number;
-        put(CUSTOM_TYPE_NAME+nr, tp.getName());
-        put(CUSTOM_TYPE_REQ+nr, tp.getRequiredFieldsString());//tp.getRequiredFields());
-        putStringArray(CUSTOM_TYPE_OPT+nr, tp.getOptionalFields());
-        putStringArray(CUSTOM_TYPE_PRIOPT+nr, tp.getPrimaryOptionalFields());
+        String nr = \"\" + number;
+        put(CUSTOM_TYPE_NAME + nr, tp.getName());
+        put(CUSTOM_TYPE_REQ + nr, tp.getRequiredFieldsString());//tp.getRequiredFields());
+        putStringArray(CUSTOM_TYPE_OPT + nr, tp.getOptionalFields());
+        putStringArray(CUSTOM_TYPE_PRIOPT + nr, tp.getPrimaryOptionalFields());
 
     }
 
     /**
-     * Retrieves all information about the entry type in preferences,
-     * with the tag given by number.
+     * Retrieves all information about the entry type in preferences, with the
+     * tag given by number.
      */
     public CustomEntryType getCustomEntryType(int number) {
-        String nr = \"\"+number;
-        String
-            name = get(CUSTOM_TYPE_NAME+nr);
-        String[]
-            req = getStringArray(CUSTOM_TYPE_REQ+nr),
-            opt = getStringArray(CUSTOM_TYPE_OPT+nr),
-            priOpt = getStringArray(CUSTOM_TYPE_PRIOPT+nr);
-        if (name == null)
+        String nr = \"\" + number;
+        String name = get(CUSTOM_TYPE_NAME + nr);
+        String[] req = getStringArray(CUSTOM_TYPE_REQ + nr),
+                opt = getStringArray(CUSTOM_TYPE_OPT + nr),
+                priOpt = getStringArray(CUSTOM_TYPE_PRIOPT + nr);
+        if (name == null) {
             return null;
+        }
         if (priOpt == null) {
             return new CustomEntryType(Util.nCase(name), req, opt);
         }
@@ -1164,11 +1252,8 @@ public CustomEntryType getCustomEntryType(int number) {
         return new CustomEntryType(Util.nCase(name), req, priOpt,
                 secOpt.toArray(new String[secOpt.size()]));
 
-
     }
 
-
-
     public List<ExternalFileType> getDefaultExternalFileTypes() {
         List<ExternalFileType> list = new ArrayList<ExternalFileType>();
         list.add(new ExternalFileType(\"PDF\", \"pdf\", \"application/pdf\", \"evince\", \"pdfSmall\"));
@@ -1201,47 +1286,50 @@ public CustomEntryType getCustomEntryType(int number) {
             ExternalFileType type = iterator.next();
             type.setOpenWith(\"\");
         }
-        
 
         return list;
     }
 
     public ExternalFileType[] getExternalFileTypeSelection() {
-        return externalFileTypes.toArray
-                (new ExternalFileType[externalFileTypes.size()]);
+        return externalFileTypes.toArray(new ExternalFileType[externalFileTypes.size()]);
     }
 
     /**
      * Look up the external file type registered with this name, if any.
+     *
      * @param name The file type name.
      * @return The ExternalFileType registered, or null if none.
      */
     public ExternalFileType getExternalFileTypeByName(String name) {
         for (Iterator<ExternalFileType> iterator = externalFileTypes.iterator(); iterator.hasNext();) {
             ExternalFileType type = iterator.next();
-            if (type.getName().equals(name))
+            if (type.getName().equals(name)) {
                 return type;
+            }
         }
         // Return an instance that signifies an unknown file type:
         return new UnknownExternalFileType(name);
     }
 
     /**
      * Look up the external file type registered for this extension, if any.
+     *
      * @param extension The file extension.
      * @return The ExternalFileType registered, or null if none.
      */
     public ExternalFileType getExternalFileTypeByExt(String extension) {
         for (Iterator<ExternalFileType> iterator = externalFileTypes.iterator(); iterator.hasNext();) {
             ExternalFileType type = iterator.next();
-            if ((type.getExtension() != null) && type.getExtension().equalsIgnoreCase(extension))
+            if ((type.getExtension() != null) && type.getExtension().equalsIgnoreCase(extension)) {
                 return type;
+            }
         }
         return null;
     }
 
     /**
      * Look up the external file type registered for this filename, if any.
+     *
      * @param filename The name of the file whose type to look up.
      * @return The ExternalFileType registered, or null if none.
      */
@@ -1263,26 +1351,30 @@ public ExternalFileType getExternalFileTypeForName(String filename) {
 
     /**
      * Look up the external file type registered for this MIME type, if any.
+     *
      * @param mimeType The MIME type.
-     * @return The ExternalFileType registered, or null if none. For the mime type \"text/html\",
-     *   a valid file type is guaranteed to be returned.
+     * @return The ExternalFileType registered, or null if none. For the mime
+     * type \"text/html\", a valid file type is guaranteed to be returned.
      */
     public ExternalFileType getExternalFileTypeByMimeType(String mimeType) {
         for (Iterator<ExternalFileType> iterator = externalFileTypes.iterator(); iterator.hasNext();) {
             ExternalFileType type = iterator.next();
-            if ((type.getMimeType() != null) && type.getMimeType().equals(mimeType))
+            if ((type.getMimeType() != null) && type.getMimeType().equals(mimeType)) {
                 return type;
+            }
         }
-        if (mimeType.equals(\"text/html\"))
+        if (mimeType.equals(\"text/html\")) {
             return HTML_FALLBACK_TYPE;
-        else
+        } else {
             return null;
+        }
     }
 
     /**
      * Reset the List of external file types after user customization.
-     * @param types The new List of external file types. This is the complete list, not
-     *  just new entries.
+     *
+     * @param types The new List of external file types. This is the complete
+     * list, not just new entries.
      */
     public void setExternalFileTypes(List<ExternalFileType> types) {
 
@@ -1306,9 +1398,9 @@ public void setExternalFileTypes(List<ExternalFileType> types) {
             }
             if (found != null) {
                 // Found it! Check if it is an exact match, or if it has been customized:
-                if (found.equals(type))
+                if (found.equals(type)) {
                     unchanged.add(type);
-                else {
+                } else {
                     // It was modified. Remove its entry from the defaults list, since
                     // the type hasn't been removed:
                     defTypes.remove(found);
@@ -1325,24 +1417,23 @@ public void setExternalFileTypes(List<ExternalFileType> types) {
 
         // Now set up the array to write to prefs, containing all new types, all modified
         // types, and a flag denoting each default type that has been removed:
-        String[][] array = new String[types.size()+defTypes.size()][];
-        int i=0;
+        String[][] array = new String[types.size() + defTypes.size()][];
+        int i = 0;
         for (ExternalFileType type : types) {
             array[i] = type.getStringArrayRepresentation();
             i++;
         }
         for (ExternalFileType type : defTypes) {
-            array[i] = new String[] {type.getName(), FILE_TYPE_REMOVED_FLAG};
+            array[i] = new String[]{type.getName(), FILE_TYPE_REMOVED_FLAG};
             i++;
         }
         //System.out.println(\"Encoded: '\"+Util.encodeStringArray(array)+\"'\");
         put(\"externalFileTypes\", Util.encodeStringArray(array));
     }
 
-    
     /**
-     * Set up the list of external file types, either from default values, or from values
-     * recorded in Preferences.
+     * Set up the list of external file types, either from default values, or
+     * from values recorded in Preferences.
      */
     public void updateExternalFileTypes() {
         // First get a list of the default file types as a starting point:
@@ -1366,10 +1457,10 @@ public void updateExternalFileTypes() {
                     }
                 }
                 // If we found it, remove it from the type list:
-                if (toRemove != null)
+                if (toRemove != null) {
                     types.remove(toRemove);
-            }
-            else {
+                }
+            } else {
                 // A new or modified entry type. Construct it from the string array:
                 ExternalFileType type = new ExternalFileType(vals[i]);
                 // Check if there is a default type with the same name. If so, this is a
@@ -1385,7 +1476,7 @@ public void updateExternalFileTypes() {
                 if (toRemove != null) {
                     types.remove(toRemove);
                 }
-                
+
                 // Then add the new one:
                 types.add(type);
             }
@@ -1397,9 +1488,9 @@ public void updateExternalFileTypes() {
         }
     }
 
-
     /**
      * Removes all information about custom entry types with tags of
+     *
      * @param number or higher.
      */
     public void purgeCustomEntryTypes(int number) {
@@ -1410,25 +1501,27 @@ public void purgeCustomEntryTypes(int number) {
     }
 
     /**
-     * Removes all entries keyed by prefix+number, where number
-     * is equal to or higher than the given number.
+     * Removes all entries keyed by prefix+number, where number is equal to or
+     * higher than the given number.
+     *
      * @param number or higher.
      */
     public void purgeSeries(String prefix, int number) {
-        while (get(prefix+number) != null) {
-            remove(prefix+number);
+        while (get(prefix + number) != null) {
+            remove(prefix + number);
             number++;
         }
     }
 
     public EntryEditorTabList getEntryEditorTabList() {
-    if (tabList == null)
-        updateEntryEditorTabList();
-    return tabList;
+        if (tabList == null) {
+            updateEntryEditorTabList();
+        }
+        return tabList;
     }
 
     public void updateEntryEditorTabList() {
-    tabList = new EntryEditorTabList();
+        tabList = new EntryEditorTabList();
     }
 
     /**
@@ -1437,32 +1530,34 @@ public void updateEntryEditorTabList() {
      * @param filename String File to export to
      */
     public void exportPreferences(String filename) throws IOException {
-      File f = new File(filename);
-      OutputStream os = new FileOutputStream(f);
-      try {
-        prefs.exportSubtree(os);
-      } catch (BackingStoreException ex) {
-        throw new IOException(ex.getMessage());
-      }
-    }
-
-      /**
-       * Imports Preferences from an XML file.
-       *
-       * @param filename String File to import from
-       */
-      public void importPreferences(String filename) throws IOException {
+        File f = new File(filename);
+        OutputStream os = new FileOutputStream(f);
+        try {
+            prefs.exportSubtree(os);
+        } catch (BackingStoreException ex) {
+            throw new IOException(ex.getMessage());
+        }
+    }
+
+    /**
+     * Imports Preferences from an XML file.
+     *
+     * @param filename String File to import from
+     */
+    public void importPreferences(String filename) throws IOException {
         File f = new File(filename);
         InputStream is = new FileInputStream(f);
         try {
-          Preferences.importPreferences(is);
+            Preferences.importPreferences(is);
         } catch (InvalidPreferencesFormatException ex) {
-          throw new IOException(ex.getMessage());
+            throw new IOException(ex.getMessage());
         }
-      }
+    }
 
     /**
-     * Determines whether the given field should be written without any sort of wrapping.
+     * Determines whether the given field should be written without any sort of
+     * wrapping.
+     *
      * @param fieldName The field name.
      * @return true if the field should not be wrapped.
      */, @@ -79,6 +79,7 @@ public PrefsDialog3(JabRefFrame parent) {
 		tabs.add(new GeneralTab(frame, prefs));
 		tabs.add(new NetworkTab(frame, prefs));
         tabs.add(new FileTab(frame, prefs));
+        tabs.add(new FileSortTab(frame, prefs));
         tabs.add(new EntryEditorPrefsTab(frame, prefs));
         tabs.add(new GroupsPrefsTab(prefs));
 		tabs.add(new AppearancePrefsTab(prefs));, @@ -214,9 +214,9 @@ public void setValues() {
 		autoResizeMode
 			.setSelected((_prefs.getInt(\"autoResizeMode\") == JTable.AUTO_RESIZE_ALL_COLUMNS));
 
-		priField.setText(_prefs.get(\"priSort\"));
-		secField.setText(_prefs.get(\"secSort\"));
-		terField.setText(_prefs.get(\"terSort\"));
+		priField.setText(_prefs.get(JabRefPreferences.PRIMARY_SORT_FIELD));
+		secField.setText(_prefs.get(JabRefPreferences.SECONDARY_SORT_FIELD));
+		terField.setText(_prefs.get(JabRefPreferences.TERTIARY_SORT_FIELD));
 		priSort.setSelectedIndex(0);
 		secSort.setSelectedIndex(0);
 		terSort.setSelectedIndex(0);
@@ -235,9 +235,9 @@ else if (_prefs.getBoolean(\"namesLastOnly\"))
 			lastNamesOnly.setSelected(true);
 		else
 			noAbbrNames.setSelected(true);
-		priDesc.setSelected(_prefs.getBoolean(\"priDescending\"));
-		secDesc.setSelected(_prefs.getBoolean(\"secDescending\"));
-		terDesc.setSelected(_prefs.getBoolean(\"terDescending\"));
+		priDesc.setSelected(_prefs.getBoolean(JabRefPreferences.PRIMARY_SORT_DESCENDING));
+		secDesc.setSelected(_prefs.getBoolean(JabRefPreferences.SECONDARY_SORT_DESCENDING));
+		terDesc.setSelected(_prefs.getBoolean(JabRefPreferences.TERTIARY_SORT_DESCENDING));
 
 		floatMarked.setSelected(_prefs.getBoolean(\"floatMarkedEntries\"));
 
@@ -268,16 +268,16 @@ public void storeSettings() {
 
 		_prefs.putInt(\"autoResizeMode\",
 			autoResizeMode.isSelected() ? JTable.AUTO_RESIZE_ALL_COLUMNS : JTable.AUTO_RESIZE_OFF);
-		_prefs.putBoolean(\"priDescending\", priDesc.isSelected());
-		_prefs.putBoolean(\"secDescending\", secDesc.isSelected());
-		_prefs.putBoolean(\"terDescending\", terDesc.isSelected());
-		// _prefs.put(\"secSort\",
+		_prefs.putBoolean(JabRefPreferences.PRIMARY_SORT_DESCENDING, priDesc.isSelected());
+		_prefs.putBoolean(JabRefPreferences.SECONDARY_SORT_DESCENDING, secDesc.isSelected());
+		_prefs.putBoolean(JabRefPreferences.TERTIARY_SORT_DESCENDING, terDesc.isSelected());
+		// _prefs.put(JabRefPreferences.SECONDARY_SORT_FIELD,
 		// GUIGlobals.ALL_FIELDS[secSort.getSelectedIndex()]);
-		// _prefs.put(\"terSort\",
+		// _prefs.put(JabRefPreferences.TERTIARY_SORT_FIELD,
 		// GUIGlobals.ALL_FIELDS[terSort.getSelectedIndex()]);
-		_prefs.put(\"priSort\", priField.getText().toLowerCase().trim());
-		_prefs.put(\"secSort\", secField.getText().toLowerCase().trim());
-		_prefs.put(\"terSort\", terField.getText().toLowerCase().trim());
+		_prefs.put(JabRefPreferences.PRIMARY_SORT_FIELD, priField.getText().toLowerCase().trim());
+		_prefs.put(JabRefPreferences.SECONDARY_SORT_FIELD, secField.getText().toLowerCase().trim());
+		_prefs.put(JabRefPreferences.TERTIARY_SORT_FIELD, terField.getText().toLowerCase().trim());
 
 		_prefs.putBoolean(\"floatMarkedEntries\", floatMarked.isSelected());
 		// updatefont, @@ -1,18 +1,18 @@
 /*  Copyright (C) 2003-2011 JabRef contributors.
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-*/
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
 package net.sf.jabref.export;
 
 import java.io.File;
@@ -52,23 +52,23 @@
 import ca.odell.glazedlists.BasicEventList;
 import ca.odell.glazedlists.SortedList;
 
-public class FileActions
-{
+public class FileActions {
 
     private static Pattern refPat = Pattern.compile(\"(#[A-Za-z]+#)\"); // Used to detect string references in strings
     private static BibtexString.Type previousStringType;
 
     private static void writePreamble(Writer fw, String preamble) throws IOException {
-    if (preamble != null) {
-        fw.write(\"@PREAMBLE{\");
-        fw.write(preamble);
-        fw.write(\"}\"+Globals.NEWLINE +Globals.NEWLINE);
-    }
+        if (preamble != null) {
+            fw.write(\"@PREAMBLE{\");
+            fw.write(preamble);
+            fw.write(\"}\" + Globals.NEWLINE + Globals.NEWLINE);
+        }
     }
 
     /**
-     * Write all strings in alphabetical order, modified to produce a safe (for BibTeX) order of the strings
-     * if they reference each other.
+     * Write all strings in alphabetical order, modified to produce a safe (for
+     * BibTeX) order of the strings if they reference each other.
+     *
      * @param fw The Writer to send the output to.
      * @param database The database whose strings we should write.
      * @throws IOException If anthing goes wrong in writing.
@@ -83,17 +83,18 @@ private static void writeStrings(Writer fw, BibtexDatabase database) throws IOEx
         // First, make a Map of all entries:
         HashMap<String, BibtexString> remaining = new HashMap<String, BibtexString>();
         int maxKeyLength = 0;
-        for (Iterator<BibtexString> i=strings.iterator(); i.hasNext();) {
+        for (Iterator<BibtexString> i = strings.iterator(); i.hasNext();) {
             BibtexString string = i.next();
             remaining.put(string.getName(), string);
             maxKeyLength = Math.max(maxKeyLength, string.getName().length());
         }
 
-        for(BibtexString.Type t : BibtexString.Type.values()) {
+        for (BibtexString.Type t : BibtexString.Type.values()) {
             for (Iterator<BibtexString> i = strings.iterator(); i.hasNext();) {
                 BibtexString bs = i.next();
-                if (remaining.containsKey(bs.getName()) && bs.getType() == t)
+                if (remaining.containsKey(bs.getName()) && bs.getType() == t) {
                     writeString(fw, bs, remaining, maxKeyLength);
+                }
             }
         }
         fw.write(Globals.NEWLINE);
@@ -110,12 +111,13 @@ private static void writeString(Writer fw, BibtexString bs, HashMap<String, Bibt
         Matcher m;
         while ((m = refPat.matcher(content)).find()) {
             String foundLabel = m.group(1);
-            int restIndex = content.indexOf(foundLabel)+foundLabel.length();
+            int restIndex = content.indexOf(foundLabel) + foundLabel.length();
             content = content.substring(restIndex);
-            Object referred = remaining.get(foundLabel.substring(1, foundLabel.length()-1));
+            Object referred = remaining.get(foundLabel.substring(1, foundLabel.length() - 1));
             // If the label we found exists as a key in the \"remaining\" Map, we go on and write it now:
-            if (referred != null)
-                writeString(fw, (BibtexString)referred, remaining, maxKeyLength);
+            if (referred != null) {
+                writeString(fw, (BibtexString) referred, remaining, maxKeyLength);
+            }
         }
 
         if (previousStringType != bs.getType()) {
@@ -124,8 +126,9 @@ private static void writeString(Writer fw, BibtexString bs, HashMap<String, Bibt
         }
 
         String suffix = \"\";
-        for(int i = maxKeyLength - bs.getName().length(); i > 0; i--) 
+        for (int i = maxKeyLength - bs.getName().length(); i > 0; i--) {
             suffix += \" \";
+        }
 
         fw.write(\"@String { \" + bs.getName() + suffix + \" = \");
         if (!bs.getContent().equals(\"\")) {
@@ -134,249 +137,229 @@ private static void writeString(Writer fw, BibtexString bs, HashMap<String, Bibt
                 fw.write(formatted);
             } catch (IllegalArgumentException ex) {
                 throw new IllegalArgumentException(
-                        Globals.lang(\"The # character is not allowed in BibTeX strings unless escaped as in '\\#'.\") + \"\n\" +
-                        Globals.lang(\"Before saving, please edit any strings containing the # character.\"));
+                        Globals.lang(\"The # character is not allowed in BibTeX strings unless escaped as in '\\#'.\") + \"\n\"
+                        + Globals.lang(\"Before saving, please edit any strings containing the # character.\"));
             }
 
-        }
-        else
+        } else {
             fw.write(\"{}\");
+        }
 
         fw.write(\" }\" + Globals.NEWLINE);// + Globals.NEWLINE);
     }
 
     /**
      * Writes the JabRef signature and the encoding.
      *
-     * @param encoding String the name of the encoding, which is part of the header.
+     * @param encoding String the name of the encoding, which is part of the
+     * header.
      */
     private static void writeBibFileHeader(Writer out, String encoding) throws IOException {
         out.write(\"% \");
-      out.write(GUIGlobals.SIGNATURE);
-      out.write(\" \"+GUIGlobals.version+\".\"+Globals.NEWLINE + \"% \" + 
-              GUIGlobals.encPrefix+encoding+Globals.NEWLINE +Globals.NEWLINE);
+        out.write(GUIGlobals.SIGNATURE);
+        out.write(\" \" + GUIGlobals.version + \".\" + Globals.NEWLINE + \"% \"
+                + GUIGlobals.encPrefix + encoding + Globals.NEWLINE + Globals.NEWLINE);
     }
 
     /**
-     * Saves the database to file. Two boolean values indicate whether
-     * only entries with a nonzero Globals.SEARCH value and only
-     * entries with a nonzero Globals.GROUPSEARCH value should be
-     * saved. This can be used to let the user save only the results of
-     * a search. False and false means all entries are saved.
+     * Saves the database to file. Two boolean values indicate whether only
+     * entries with a nonzero Globals.SEARCH value and only entries with a
+     * nonzero Globals.GROUPSEARCH value should be saved. This can be used to
+     * let the user save only the results of a search. False and false means all
+     * entries are saved.
      */
     public static SaveSession saveDatabase(BibtexDatabase database,
-		MetaData metaData, File file, JabRefPreferences prefs,
-		boolean checkSearch, boolean checkGroup, String encoding, boolean suppressBackup)
-		throws SaveException {
-    	
-		TreeMap<String, BibtexEntryType> types = new TreeMap<String, BibtexEntryType>();
-		
-		boolean backup = prefs.getBoolean(\"backup\");
-        if (suppressBackup)
+            MetaData metaData, File file, JabRefPreferences prefs,
+            boolean checkSearch, boolean checkGroup, String encoding, boolean suppressBackup)
+            throws SaveException {
+
+        TreeMap<String, BibtexEntryType> types = new TreeMap<String, BibtexEntryType>();
+
+        boolean backup = prefs.getBoolean(\"backup\");
+        if (suppressBackup) {
             backup = false;
+        }
 
-		SaveSession session;
-		BibtexEntry exceptionCause = null;
-		try {
-			session = new SaveSession(file, encoding, backup);
-		} catch (Throwable e) {
-			if (encoding != null) {
-				System.err.println(\"Error from encoding: '\" + encoding + \"' Len: \" + encoding.length());
-			}
+        SaveSession session;
+        BibtexEntry exceptionCause = null;
+        try {
+            session = new SaveSession(file, encoding, backup);
+        } catch (Throwable e) {
+            if (encoding != null) {
+                System.err.println(\"Error from encoding: '\" + encoding + \"' Len: \" + encoding.length());
+            }
 			// we must catch all exceptions to be able notify users that
-			// saving failed, no matter what the reason was
-			// (and they won't just quit JabRef thinking
-			// everyting worked and loosing data)
-			e.printStackTrace();
-			throw new SaveException(e.getMessage());
-		}
+            // saving failed, no matter what the reason was
+            // (and they won't just quit JabRef thinking
+            // everyting worked and loosing data)
+            e.printStackTrace();
+            throw new SaveException(e.getMessage());
+        }
 
-		try {
+        try {
 
 			// Get our data stream. This stream writes only to a temporary file,
-			// until committed.
-			VerifyingWriter fw = session.getWriter();
+            // until committed.
+            VerifyingWriter fw = session.getWriter();
 
-			// Write signature.
-			writeBibFileHeader(fw, encoding);
+            // Write signature.
+            writeBibFileHeader(fw, encoding);
 
-			// Write preamble if there is one.
-			writePreamble(fw, database.getPreamble());
+            // Write preamble if there is one.
+            writePreamble(fw, database.getPreamble());
 
-			// Write strings if there are any.
-			writeStrings(fw, database);
+            // Write strings if there are any.
+            writeStrings(fw, database);
 
 			// Write database entries. Take care, using CrossRefEntry-
-			// Comparator, that referred entries occur after referring
-			// ones. Apart from crossref requirements, entries will be
-			// sorted as they appear on the screen.
-			List<BibtexEntry> sorter = getSortedEntries(database, null, true);
+            // Comparator, that referred entries occur after referring
+            // ones. Apart from crossref requirements, entries will be
+            // sorted as they appear on the screen.
+            List<BibtexEntry> sorter = getSortedEntries(database, null, true);
 
-			FieldFormatter ff = new LatexFieldFormatter();
+            FieldFormatter ff = new LatexFieldFormatter();
 
-			for (BibtexEntry be : sorter) {
-				exceptionCause = be;
+            for (BibtexEntry be : sorter) {
+                exceptionCause = be;
 
 				// Check if we must write the type definition for this
-				// entry, as well. Our criterion is that all non-standard
-				// types (*not* customized standard types) must be written.
-				BibtexEntryType tp = be.getType();
-
-				if (BibtexEntryType.getStandardType(tp.getName()) == null) {
-					types.put(tp.getName(), tp);
-				}
-
-				// Check if the entry should be written.
-				boolean write = true;
-
-				if (checkSearch && !nonZeroField(be, BibtexFields.SEARCH)) {
-					write = false;
-				}
-
-				if (checkGroup && !nonZeroField(be, BibtexFields.GROUPSEARCH)) {
-					write = false;
-				}
-
-				if (write) {
-					be.write(fw, ff, true);
-					fw.write(Globals.NEWLINE);
-				}
-			}
-
-			// Write meta data.
-			if (metaData != null) {
-				metaData.writeMetaData(fw);
-			}
-
-			// Write type definitions, if any:
-			if (types.size() > 0) {
-				for (Iterator<String> i = types.keySet().iterator(); i
-					.hasNext();) {
+                // entry, as well. Our criterion is that all non-standard
+                // types (*not* customized standard types) must be written.
+                BibtexEntryType tp = be.getType();
+
+                if (BibtexEntryType.getStandardType(tp.getName()) == null) {
+                    types.put(tp.getName(), tp);
+                }
+
+                // Check if the entry should be written.
+                boolean write = true;
+
+                if (checkSearch && !nonZeroField(be, BibtexFields.SEARCH)) {
+                    write = false;
+                }
+
+                if (checkGroup && !nonZeroField(be, BibtexFields.GROUPSEARCH)) {
+                    write = false;
+                }
+
+                if (write) {
+                    be.write(fw, ff, true);
+                    fw.write(Globals.NEWLINE);
+                }
+            }
+
+            // Write meta data.
+            if (metaData != null) {
+                metaData.writeMetaData(fw);
+            }
+
+            // Write type definitions, if any:
+            if (types.size() > 0) {
+                for (Iterator<String> i = types.keySet().iterator(); i
+                        .hasNext();) {
                     BibtexEntryType type = types.get(i.next());
                     if (type instanceof CustomEntryType) {
-                        CustomEntryType tp = (CustomEntryType)type;
+                        CustomEntryType tp = (CustomEntryType) type;
                         tp.save(fw);
                         fw.write(Globals.NEWLINE);
                     }
-				}
-
-			}
-
-			fw.close();
-		} catch (Throwable ex) {
-			ex.printStackTrace();
-			try {
-				session.cancel();
-				// repairAfterError(file, backup, INIT_OK);
-			} catch (IOException e) {
-				// Argh, another error? Can we do anything?
-				e.printStackTrace();
-                throw new SaveException(ex.getMessage()+\"\n\"+
-                        Globals.lang(\"Warning: could not complete file repair; your file may \"
-                        +\"have been corrupted. Error message\")+\": \"+e.getMessage());
+                }
 
-			}
-			throw new SaveException(ex.getMessage(), exceptionCause);
-		}
+            }
 
-		return session;
+            fw.close();
+        } catch (Throwable ex) {
+            ex.printStackTrace();
+            try {
+                session.cancel();
+                // repairAfterError(file, backup, INIT_OK);
+            } catch (IOException e) {
+                // Argh, another error? Can we do anything?
+                e.printStackTrace();
+                throw new SaveException(ex.getMessage() + \"\n\"
+                        + Globals.lang(\"Warning: could not complete file repair; your file may \"
+                                + \"have been corrupted. Error message\") + \": \" + e.getMessage());
 
+            }
+            throw new SaveException(ex.getMessage(), exceptionCause);
+        }
 
-	}
+        return session;
 
-    private enum SaveOrder {
-    	Standard, Original, Title, TableSort
     }
-    
+
     private static class SaveSettings {
         public final String pri, sec, ter;
         public final boolean priD, secD, terD;
-        
+
         public SaveSettings(boolean isSaveOperation) {
-        	/* four options:
-        	 * 1. ordered by author/editor/year (saveInStandardOrder)
-        	 * 2. original order (saveInOriginalOrder) -- not hit here as SaveSettings is not called in that case
-        	 * 3. current table sort order (*everything else*)
-        	 * 4. ordered by title (saveInTitleOrder)
-        	 */
-        	SaveOrder saveOrder;
-        	String prefix = isSaveOperation ? \"save\" :  \"export\";
-        	if (Globals.prefs.getBoolean(prefix + \"InStandardOrder\")) {
-        		saveOrder = SaveOrder.Standard;
-        	} else if (Globals.prefs.getBoolean(prefix + \"InTitleOrder\")) {
-        		saveOrder = SaveOrder.Title;
-//        	} else if (Globals.prefs.getBoolean(prefix + \"InOriginalOrder\")) {
-        		// this case is never hit as SaveSettings() is never called if InOriginalOrder is true
-//        		saveOrder = SaveOrder.Original;
-        	} else {
-        		saveOrder = SaveOrder.TableSort;
-        	}
-
-        	switch (saveOrder) {
-        	case TableSort:
+            /* three options:
+             * 1. original order (saveInOriginalOrder) -- not hit here as SaveSettings is not called in that case
+             * 2. current table sort order
+             * 3. ordered by specified order
+             */
+            // This case should never behit as SaveSettings() is never called if InOriginalOrder is true
+            assert isSaveOperation && !Globals.prefs.getBoolean(JabRefPreferences.SAVE_IN_ORIGINAL_ORDER);
+            assert !isSaveOperation && !Globals.prefs.getBoolean(JabRefPreferences.EXPORT_IN_ORIGINAL_ORDER);
+
+            if (isSaveOperation && Globals.prefs.getBoolean(JabRefPreferences.SAVE_IN_SPECIFIED_ORDER)) {
+                pri = Globals.prefs.get(JabRefPreferences.SAVE_PRIMARY_SORT_FIELD);
+                sec = Globals.prefs.get(JabRefPreferences.SAVE_SECONDARY_SORT_FIELD);
+                ter = Globals.prefs.get(JabRefPreferences.SAVE_TERTIARY_SORT_FIELD);
+                priD = Globals.prefs.getBoolean(JabRefPreferences.SAVE_PRIMARY_SORT_DESCENDING);
+                secD = Globals.prefs.getBoolean(JabRefPreferences.SAVE_SECONDARY_SORT_DESCENDING);
+                terD = Globals.prefs.getBoolean(JabRefPreferences.SAVE_TERTIARY_SORT_DESCENDING);
+            } else if (!isSaveOperation && Globals.prefs.getBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER)) {
+                pri = Globals.prefs.get(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD);
+                sec = Globals.prefs.get(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD);
+                ter = Globals.prefs.get(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD);
+                priD = Globals.prefs.getBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING);
+                secD = Globals.prefs.getBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING);
+                terD = Globals.prefs.getBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING);
+            } else {
                 // The setting is to save according to the current table order.
-                pri = Globals.prefs.get(\"priSort\");
-                sec = Globals.prefs.get(\"secSort\");
-                // sorted as they appear on the screen.
-                ter = Globals.prefs.get(\"terSort\");
-                priD = Globals.prefs.getBoolean(\"priDescending\");
-                secD = Globals.prefs.getBoolean(\"secDescending\");
-                terD = Globals.prefs.getBoolean(\"terDescending\");
-                break;
-        	case Title:
-        		// The setting is to not save in standard order, but in title order: title, author, editor
-        		pri = \"title\";
-                sec = \"author\";
-                ter = \"editor\";
-                priD = false;
-                secD = false;
-                terD = false;
-                break;
-        	case Standard:
-        	default: // required to get rid of Java compile errors
-                pri = \"author\";
-                sec = \"editor\";
-                ter = \"year\";
-                priD = false;
-                secD = false;
-                terD = true;
-        		break;
-        	}
+                pri = Globals.prefs.get(JabRefPreferences.PRIMARY_SORT_FIELD);
+                sec = Globals.prefs.get(JabRefPreferences.SECONDARY_SORT_FIELD);
+                ter = Globals.prefs.get(JabRefPreferences.TERTIARY_SORT_FIELD);
+                priD = Globals.prefs.getBoolean(JabRefPreferences.PRIMARY_SORT_DESCENDING);
+                secD = Globals.prefs.getBoolean(JabRefPreferences.SECONDARY_SORT_DESCENDING);
+                terD = Globals.prefs.getBoolean(JabRefPreferences.TERTIARY_SORT_DESCENDING);
+            }
         }
     }
-    
+
     private static List<Comparator<BibtexEntry>> getSaveComparators(boolean isSaveOperation) {
         SaveSettings saveSettings = new SaveSettings(isSaveOperation);
 
         List<Comparator<BibtexEntry>> comparators = new ArrayList<Comparator<BibtexEntry>>();
-        if (isSaveOperation)
+        if (isSaveOperation) {
             comparators.add(new CrossRefEntryComparator());
+        }
         comparators.add(new FieldComparator(saveSettings.pri, saveSettings.priD));
         comparators.add(new FieldComparator(saveSettings.sec, saveSettings.secD));
         comparators.add(new FieldComparator(saveSettings.ter, saveSettings.terD));
         comparators.add(new FieldComparator(BibtexFields.KEY_FIELD));
-        
+
         return comparators;
     }
-    
+
     /**
-	 * Saves the database to file, including only the entries included in the
-	 * supplied input array bes.
-	 * 
-	 * @return A List containing warnings, if any.
-	 */
+     * Saves the database to file, including only the entries included in the
+     * supplied input array bes.
+     *
+     * @return A List containing warnings, if any.
+     */
     @SuppressWarnings(\"unchecked\")
-	public static SaveSession savePartOfDatabase(BibtexDatabase database, MetaData metaData,
-                                                 File file, JabRefPreferences prefs, BibtexEntry[] bes, String encoding) throws SaveException
-    {
-
-    TreeMap<String, BibtexEntryType> types = new TreeMap<String, BibtexEntryType>(); // Map
-																						// to
-																						// collect
-																						// entry
-																						// type
-																						// definitions
-    // that we must save along with entries using them.
+    public static SaveSession savePartOfDatabase(BibtexDatabase database, MetaData metaData,
+            File file, JabRefPreferences prefs, BibtexEntry[] bes, String encoding) throws SaveException {
+
+        TreeMap<String, BibtexEntryType> types = new TreeMap<String, BibtexEntryType>(); // Map
+        // to
+        // collect
+        // entry
+        // type
+        // definitions
+        // that we must save along with entries using them.
 
         BibtexEntry be = null;
         boolean backup = prefs.getBoolean(\"backup\");
@@ -388,8 +371,7 @@ public static SaveSession savePartOfDatabase(BibtexDatabase database, MetaData m
             throw new SaveException(e.getMessage());
         }
 
-        try
-        {
+        try {
 
             // Define our data stream.
             VerifyingWriter fw = session.getWriter();
@@ -401,119 +383,114 @@ public static SaveSession savePartOfDatabase(BibtexDatabase database, MetaData m
             writePreamble(fw, database.getPreamble());
 
             // Write strings if there are any.
-        writeStrings(fw, database);
+            writeStrings(fw, database);
 
             // Write database entries. Take care, using CrossRefEntry-
             // Comparator, that referred entries occur after referring
             // ones. Apart from crossref requirements, entries will be
             // sorted as they appear on the screen.
+            List<Comparator<BibtexEntry>> comparators = getSaveComparators(true);
 
-        List<Comparator<BibtexEntry>> comparators = getSaveComparators(true);
-
-        // Use glazed lists to get a sorted view of the entries:
-        BasicEventList entryList = new BasicEventList();
-        SortedList sorter = new SortedList(entryList, new FieldComparatorStack<BibtexEntry>(comparators));
+            // Use glazed lists to get a sorted view of the entries:
+            BasicEventList entryList = new BasicEventList();
+            SortedList sorter = new SortedList(entryList, new FieldComparatorStack<BibtexEntry>(comparators));
 
-        if ((bes != null) && (bes.length > 0))
-        for (int i=0; i<bes.length; i++) {
-            sorter.add(bes[i]);
-        }
+            if ((bes != null) && (bes.length > 0)) {
+                for (int i = 0; i < bes.length; i++) {
+                    sorter.add(bes[i]);
+                }
+            }
 
             FieldFormatter ff = new LatexFieldFormatter();
 
-            for (Iterator<BibtexEntry> i = sorter.iterator(); i.hasNext();)
-            {
+            for (Iterator<BibtexEntry> i = sorter.iterator(); i.hasNext();) {
                 be = (i.next());
 
         // Check if we must write the type definition for this
-        // entry, as well. Our criterion is that all non-standard
-        // types (*not* customized standard types) must be written.
-        BibtexEntryType tp = be.getType();
-        if (BibtexEntryType.getStandardType(tp.getName()) == null) {
-            types.put(tp.getName(), tp);
-        }
-
-        be.write(fw, ff, true);
-        fw.write(Globals.NEWLINE);
-        }
+                // entry, as well. Our criterion is that all non-standard
+                // types (*not* customized standard types) must be written.
+                BibtexEntryType tp = be.getType();
+                if (BibtexEntryType.getStandardType(tp.getName()) == null) {
+                    types.put(tp.getName(), tp);
+                }
+
+                be.write(fw, ff, true);
+                fw.write(Globals.NEWLINE);
+            }
 
             // Write meta data.
-            if (metaData != null)
-            {
+            if (metaData != null) {
                 metaData.writeMetaData(fw);
             }
 
-        // Write type definitions, if any:
-        if (types.size() > 0) {
-        for (Iterator<String> i=types.keySet().iterator(); i.hasNext();) {
-            CustomEntryType tp = (CustomEntryType)types.get(i.next());
-            tp.save(fw);
-            fw.write(Globals.NEWLINE);
-        }
+            // Write type definitions, if any:
+            if (types.size() > 0) {
+                for (Iterator<String> i = types.keySet().iterator(); i.hasNext();) {
+                    CustomEntryType tp = (CustomEntryType) types.get(i.next());
+                    tp.save(fw);
+                    fw.write(Globals.NEWLINE);
+                }
 
-        }
+            }
 
             fw.close();
-        }
-         catch (Throwable ex)
-        {
+        } catch (Throwable ex) {
             try {
                 session.cancel();
                 //repairAfterError(file, backup, status);
             } catch (IOException e) {
                 // Argh, another error? Can we do anything?
                 e.printStackTrace();
-                throw new SaveException(ex.getMessage()+\"\n\"+
-                        Globals.lang(\"Warning: could not complete file repair; your file may \"
-                        +\"have been corrupted. Error message\")+\": \"+e.getMessage());
+                throw new SaveException(ex.getMessage() + \"\n\"
+                        + Globals.lang(\"Warning: could not complete file repair; your file may \"
+                                + \"have been corrupted. Error message\") + \": \" + e.getMessage());
             }
             throw new SaveException(ex.getMessage(), be);
-    }
+        }
 
         return session;
 
     }
 
-
     /**
      * This method attempts to get a Reader for the file path given, either by
-     * loading it as a resource (from within jar), or as a normal file.
-     * If unsuccessful (e.g. file not found), an IOException is thrown.
+     * loading it as a resource (from within jar), or as a normal file. If
+     * unsuccessful (e.g. file not found), an IOException is thrown.
      */
     public static Reader getReader(String name) throws IOException {
-      Reader reader = null;
-      // Try loading as a resource first. This works for files inside the jar:
-      URL reso = Globals.class.getResource(name);
+        Reader reader = null;
+        // Try loading as a resource first. This works for files inside the jar:
+        URL reso = Globals.class.getResource(name);
 
-      // If that didn't work, try loading as a normal file URL:
-      if (reso != null) {
-        try {
-          reader = new InputStreamReader(reso.openStream());
-        } catch (FileNotFoundException ex) {
-          throw new IOException(Globals.lang(\"Could not find layout file\")+\": '\"+name+\"'.\");
-        }
-      } else {
-        File f = new File(name);
-        try {
-          reader = new FileReader(f);
-        } catch (FileNotFoundException ex) {
-          throw new IOException(Globals.lang(\"Could not find layout file\")+\": '\"+name+\"'.\");
+        // If that didn't work, try loading as a normal file URL:
+        if (reso != null) {
+            try {
+                reader = new InputStreamReader(reso.openStream());
+            } catch (FileNotFoundException ex) {
+                throw new IOException(Globals.lang(\"Could not find layout file\") + \": '\" + name + \"'.\");
+            }
+        } else {
+            File f = new File(name);
+            try {
+                reader = new FileReader(f);
+            } catch (FileNotFoundException ex) {
+                throw new IOException(Globals.lang(\"Could not find layout file\") + \": '\" + name + \"'.\");
+            }
         }
-      }
 
-      return reader;
+        return reader;
     }
 
     /*
-    * We have begun to use getSortedEntries() for both database save operations
-    * and non-database save operations.  In a non-database save operation
-    * (such as the exportDatabase call), we do not wish to use the
-    * global preference of saving in standard order.
-    */
+     * We have begun to use getSortedEntries() for both database save operations
+     * and non-database save operations.  In a non-database save operation
+     * (such as the exportDatabase call), we do not wish to use the
+     * global preference of saving in standard order.
+     */
     @SuppressWarnings(\"unchecked\")
-	public static List<BibtexEntry> getSortedEntries(BibtexDatabase database, Set<String> keySet, boolean isSaveOperation) {
-        boolean inOriginalOrder = isSaveOperation ? Globals.prefs.getBoolean(\"saveInOriginalOrder\") :
-            Globals.prefs.getBoolean(\"exportInOriginalOrder\");
+    public static List<BibtexEntry> getSortedEntries(BibtexDatabase database, Set<String> keySet, boolean isSaveOperation) {
+        boolean inOriginalOrder = isSaveOperation ? Globals.prefs.getBoolean(\"saveInOriginalOrder\")
+                : Globals.prefs.getBoolean(\"exportInOriginalOrder\");
         List<Comparator<BibtexEntry>> comparators;
         if (inOriginalOrder) {
             // Sort entries based on their creation order, utilizing the fact
@@ -524,14 +501,15 @@ public static Reader getReader(String name) throws IOException {
         } else {
             comparators = getSaveComparators(isSaveOperation);
         }
-        
+
         // Use glazed lists to get a sorted view of the entries:
         FieldComparatorStack<BibtexEntry> comparatorStack = new FieldComparatorStack<BibtexEntry>(comparators);
         BasicEventList entryList = new BasicEventList();
         SortedList sorter = new SortedList(entryList, comparatorStack);
 
-        if (keySet == null)
+        if (keySet == null) {
             keySet = database.getKeySet();
+        }
 
         if (keySet != null) {
             Iterator<String> i = keySet.iterator();
@@ -543,19 +521,16 @@ public static Reader getReader(String name) throws IOException {
         return sorter;
     }
 
-    /** 
+    /**
      * @return true iff the entry has a nonzero value in its field.
      */
-    private static boolean nonZeroField(BibtexEntry be, String field)
-    {
+    private static boolean nonZeroField(BibtexEntry be, String field) {
         String o = (be.getField(field));
 
         return ((o != null) && !o.equals(\"0\"));
     }
 }
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 //  END OF FILE.
 ///////////////////////////////////////////////////////////////////////////////, @@ -1352,11 +1352,11 @@ else if (i == URL_COL)
 
         /*
          * // Default sort order: String[] sortFields = new String[]
-         * {Globals.prefs.get(\"priSort\"), Globals.prefs.get(\"secSort\"),
-         * Globals.prefs.get(\"terSort\")}; boolean[] sortDirections = new
-         * boolean[] {Globals.prefs.getBoolean(\"priDescending\"),
-         * Globals.prefs.getBoolean(\"secDescending\"),
-         * Globals.prefs.getBoolean(\"terDescending\")}; // descending
+         * {Globals.prefs.get(JabRefPreferences.PRIMARY_SORT_FIELD), Globals.prefs.get(JabRefPreferences.SECONDARY_SORT_FIELD),
+         * Globals.prefs.get(JabRefPreferences.TERTIARY_SORT_FIELD)}; boolean[] sortDirections = new
+         * boolean[] {Globals.prefs.getBoolean(JabRefPreferences.PRIMARY_SORT_DESCENDING),
+         * Globals.prefs.getBoolean(JabRefPreferences.SECONDARY_SORT_DESCENDING),
+         * Globals.prefs.getBoolean(JabRefPreferences.TERTIARY_SORT_DESCENDING)}; // descending
          */
         sortedList.getReadWriteLock().writeLock().lock();
         comparatorChooser.appendComparator(PAD, 0, false);, @@ -377,14 +377,19 @@ private void setupComparatorChooser() {
             comparators.add(new FieldComparator(tableFormat.getColumnName(i).toLowerCase()));
         }
 
-
         // Set initial sort columns:
 
         // Default sort order:
-        String[] sortFields = new String[] {Globals.prefs.get(\"priSort\"), Globals.prefs.get(\"secSort\"),
-            Globals.prefs.get(\"terSort\")};
-        boolean[] sortDirections = new boolean[] {Globals.prefs.getBoolean(\"priDescending\"),
-            Globals.prefs.getBoolean(\"secDescending\"), Globals.prefs.getBoolean(\"terDescending\")}; // descending
+        String[] sortFields = new String[] {
+            Globals.prefs.get(JabRefPreferences.PRIMARY_SORT_FIELD), 
+            Globals.prefs.get(JabRefPreferences.SECONDARY_SORT_FIELD),
+            Globals.prefs.get(JabRefPreferences.TERTIARY_SORT_FIELD)
+        };
+        boolean[] sortDirections = new boolean[]{
+            Globals.prefs.getBoolean(JabRefPreferences.PRIMARY_SORT_DESCENDING),
+            Globals.prefs.getBoolean(JabRefPreferences.SECONDARY_SORT_DESCENDING),
+            Globals.prefs.getBoolean(JabRefPreferences.TERTIARY_SORT_DESCENDING)
+        }; // descending
 
         sortedForTable.getReadWriteLock().writeLock().lock();
         for (int i=0; i<sortFields.length; i++) {
@@ -414,24 +419,24 @@ public void actionPerformed(ActionEvent actionEvent) {
                 // Update preferences:
                 int count = Math.min(fields.size(), order.size());
                 if (count >= 1) {
-                    Globals.prefs.put(\"priSort\", fields.get(0));
-                    Globals.prefs.putBoolean(\"priDescending\", order.get(0));
+                    Globals.prefs.put(JabRefPreferences.PRIMARY_SORT_FIELD, fields.get(0));
+                    Globals.prefs.putBoolean(JabRefPreferences.PRIMARY_SORT_DESCENDING, order.get(0));
                 }
                 if (count >= 2) {
-                    Globals.prefs.put(\"secSort\", fields.get(1));
-                    Globals.prefs.putBoolean(\"secDescending\", order.get(1));
+                    Globals.prefs.put(JabRefPreferences.SECONDARY_SORT_FIELD, fields.get(1));
+                    Globals.prefs.putBoolean(JabRefPreferences.SECONDARY_SORT_DESCENDING, order.get(1));
                 }
                 else {
-                    Globals.prefs.put(\"secSort\", \"\");
-                    Globals.prefs.putBoolean(\"secDescending\", false);
+                    Globals.prefs.put(JabRefPreferences.SECONDARY_SORT_FIELD, \"\");
+                    Globals.prefs.putBoolean(JabRefPreferences.SECONDARY_SORT_DESCENDING, false);
                 }
                 if (count >= 3) {
-                    Globals.prefs.put(\"terSort\", fields.get(2));
-                    Globals.prefs.putBoolean(\"terDescending\", order.get(2));
+                    Globals.prefs.put(JabRefPreferences.TERTIARY_SORT_FIELD, fields.get(2));
+                    Globals.prefs.putBoolean(JabRefPreferences.TERTIARY_SORT_DESCENDING, order.get(2));
                 }
                 else {
-                    Globals.prefs.put(\"terSort\", \"\");
-                    Globals.prefs.putBoolean(\"terDescending\", false);
+                    Globals.prefs.put(JabRefPreferences.TERTIARY_SORT_FIELD, \"\");
+                    Globals.prefs.putBoolean(JabRefPreferences.TERTIARY_SORT_DESCENDING, false);
                 }
             }
 , ]"	"This will add a new \"File Sorting\" Tab to the preferences that allows to exactly specify the sort and export order of entries, rather than the rather limited set of choices that were available to date.
"	"New Sorting/Export preferences"
"2"	"Simon Harrer"	"[build-wrapper.xml, build.gradle, src/extensions/SimpleCsvImporter.java, ]"	"[@@ -0,0 +1,3 @@
+<project default=\"test\">
+    <include file=\"build.xml\" as=\"antTargets\"/>
+</project>
\ No newline at end of file, @@ -0,0 +1,61 @@
+apply plugin: \"java\"
+apply plugin: \"eclipse\"
+apply plugin: \"idea\"
+apply plugin: \"application\"
+
+repositories {
+    mavenCentral()
+}
+
+sourceSets {
+    main {
+        java {
+            srcDir \"src/java\"
+        }
+        resources {
+            srcDirs = [\"src\"]
+        }
+    }
+}
+
+dependencies {
+
+    // jgoodies
+    compile 'com.jgoodies:jgoodies-common:1.4.0'
+    compile 'com.jgoodies:jgoodies-forms:1.6.0'
+    compile 'com.jgoodies:jgoodies-looks:2.5.2'
+
+    compile 'org.apache.pdfbox:pdfbox:1.7.1'
+    compile 'org.apache.pdfbox:fontbox:1.7.1'
+    compile 'org.apache.pdfbox:jempbox:1.7.1'
+
+
+    compile 'org.openoffice:juh:3.2.1'
+    compile 'org.openoffice:jurt:3.2.1'
+    compile 'org.openoffice:ridl:3.2.1'
+    compile 'org.openoffice:unoil:3.2.1'
+
+    compile 'org.antlr:antlr:3.4'
+
+    compile 'mysql:mysql-connector-java:5.0.7'
+    compile 'org.postgresql:postgresql:9.2-1002-jdbc4'
+
+    compile fileTree(dir: 'lib', includes: ['glazedlists-1.8.0_java15.jar', 'jayatana-1.2.4.jar', 'microba.jar', 'spin.jar'])
+
+    // not available in maven repository
+    compile fileTree(dir: 'lib/plugin', includes: ['jpf.jar', 'jpf-boot.jar', 'commons-logging.jar', 'JPFCodeGenerator-rt.jar'])
+
+    compile fileTree(dir: 'lib/spl/jersey', includes: ['*.jar'])
+    compile fileTree(dir: 'lib/spl/sciplore', includes: ['*.jar'])
+
+    compile 'junit:junit:3.8.2'
+}
+
+// use ant targets with prefix antTargets.XXXXX
+ant.importBuild \"build-wrapper.xml\"
+
+compileJava.dependsOn \"antTargets.generate\"
+
+task wrapper(type: Wrapper) {
+    gradleVersion = '1.11'
+}
\ No newline at end of file, @@ -13,8 +13,14 @@ public String getFormatName() {
   public boolean isRecognizedFormat(InputStream stream) throws IOException {
     return true; // this is discouraged except for demonstration purposes
   }
-  
-  public List importEntries(InputStream stream) throws IOException {    
+
+    @Override
+    public List<BibtexEntry> importEntries(InputStream in, OutputPrinter status) throws IOException {
+        // MUST BE IMPLEMENTED
+        return null;
+    }
+
+    public List importEntries(InputStream stream) throws IOException {
     ArrayList bibitems = new ArrayList();
     BufferedReader in = new BufferedReader(ImportFormatReader.getReaderDefaultEncoding(stream));
       , ]"	"This adds basic gradle integration. The project files for Intellij and Eclipse can be generated and JabRef can be started from within the IDEs as well as the tests can be run with errors. 
"	"Basic gradle integration"
"3"	"Egon Willighagen"	"[src/resource/JabRef_nl.properties, ]"	"[@@ -34,7 +34,7 @@ Abbreviate_journal_names_of_the_selected_entries_(ISO_abbreviation)=Kort_tijdsch
 Abbreviate_journal_names_of_the_selected_entries_(MEDLINE_abbreviation)=Kort_tijdschriftennamen_met_de_geselecteerde_entries_af_(MEDLINE_afkorting)
 
 Abbreviate_names=Namen_afkorten
-Abbreviated_%0_journal_names.=
+Abbreviated_%0_journal_names.=Afgekorte_tijdschrift_namen
 
 Abbreviation=Afkorting
 
@@ -112,7 +112,7 @@ Append_contents_from_a_BibTeX_database_into_the_currently_viewed_database=Voeg_d
 Append_database=Database_invoegen
 
 append_the_selected_text_to_bibtex_key=voeg_de_geselecteerde_tekst_toe_aan_BibTeX-sleutel
-Application=
+Application=Programma
 
 Apply=Toepassen
 
@@ -159,7 +159,7 @@ Automatically_created_groups=Automatisch_aangemaakte_groepen
 
 Automatically_hide_groups_interface_when_switching_to_a_database_that_contains_no_groups=Verberg_automatisch_het_groepenvenster_bij_overgang_naar_een_database_die_geen_groepen_bevat
 
-Automatically_remove_exact_duplicates=
+Automatically_remove_exact_duplicates=Automatisch_exacte_kopie\u00ebn_verwijderen
 
 Automatically_show_groups_interface_when_switching_to_a_database_that_contains_groups=Toon_automatisch_het_groepenvenster_bij_overgang_naar_een_database_die_groepen_bevat
 
@@ -186,7 +186,7 @@ Background_color_for_optional_fields=Achtergrondkleur_voor_optionele_velden
 Background_color_for_required_fields=Achtergrondkleur_voor_vereiste_velden
 
 Backup_old_file_when_saving=Maak_reservekopie_van_oud_bestand_bij_het_opslaan
-Beta_version=
+Beta_version=Beta_versie
 
 BibTeX_key=BibTeX-sleutel
 
@@ -233,7 +233,7 @@ Change_case=Verander_geval
 
 Change_entry_type=Wijzig_entry_type
 
-Change_file_type=
+Change_file_type=Wijzig_bestandstype
 
 change_key=wijzig_sleutel
 
@@ -305,8 +305,8 @@ Command_line_id=Commandoregel_id
 
 Complete_record=Vervolledig_record
 
-Connect=
-Connect_to_SQL_database=
+Connect=Verbinden
+Connect_to_SQL_database=Verbind_met_een_SQL_database
 Connection_to_IEEEXplore_failed=
 
 Contained_in=bevat_in
@@ -2320,7 +2320,7 @@ Run_HTML_converter_on_title=
 Searching...=
 You_have_selected_more_than_%0_entries_for_download._Some_web_sites_might_block_you_if_you_make_too_many_rapid_downloads._Do_you_want_to_continue?=
 Confirm_selection=
-Unknown_DOI\:_'%0'.=
+Unknown_DOI\:_'%0'.=Unbekende_DOI\:_'%0'.
 Get_BibTeX_entry_from_DOI=
 Prefer_converting_subscripts_and_superscripts_to_equations_rather_than_text=
 Add_{}_to_specified_title_words_on_search_to_keep_the_correct_case=
@@ -2337,7 +2337,7 @@ Unknown_DiVA_entry\:_'%0'.=
 Get_BibTeX_entry_from_DiVA=
 Log=
 
-ISO_690=
+ISO_690=ISO_690
 
 Add_brackets_and_replace_separators_with_their_non-breaking_version_for_units=
 Add_new_entry_and_keep_both_old_entries=
@@ -2381,9 +2381,9 @@ Run_Unicode_converter_on_title,_author(s),_and_abstract=
 Database_has_changed._Do_you_want_to_save_before_closing?=
 Host=
 Invalid_setting=
-Network=
+Network=Netwerk
 Please_specify_both_hostname_and_port=
-Port=
+Port=Poort
 Start_field_contents_in_same_column=
 Use_camel_case_for_field_names_(e.g.,_\"HowPublished\"_instead_of_\"howpublished\")=
 Use_custom_proxy_configuration=
@@ -2393,7 +2393,7 @@ Rebind_C-a,_too=
 
 Show_number_of_elements_contained_in_each_group=
 
-Open_folder=
-Opened_%0_folder(s).=
+Open_folder=Open_map
+Opened_%0_folder(s).=%0_map(pen)_geopend.
 
 Searches_for_unlinked_PDF_files_on_the_file_system=, ]"	""	"Some example new Dutch translations via the GitHub web page."
"4"	"was123"	"[src/resource/JabRef_in.properties, ]"	"[@@ -1304,10 +1304,10 @@ Style_selection=Pilihan_gaya
 The_panel_below_shows_the_definition_of_the_default_style.=Panel_dibawah_menampilkan_definisi_dari_gaya_bawaan
 If_you_want_to_use_it_as_a_template_for_a_new_style,_you_can_copy_the_contents_into_a_new_.jstyle_file=Jika_anda_menginginkan_sebagai_templet_untuk_gaya_baru,_anda_bisa_menyalin_isi_ke_berkas_baru_.jstyle
 
-Default_style_(author-year_citations)=
-Default_style_(numerical_citations)=
-No_valid_style_file_defined=
-Choose_pattern=
+Default_style_(author-year_citations)=Gaya_bawaan_(acuan_penulis_tahun)
+Default_style_(numerical_citations)=Gaya_bawaan_(acuan_numerik)
+No_valid_style_file_defined=(gaya_yang_sah_tidak_ditemukan)
+Choose_pattern=Pilih_pola
 Use_the_bib_file_location_as_primary_file_directory=
 Could_not_run_the_gnuclient/emacsclient_program._Make_sure_you_have_the_emacsclient/gnuclient_program_installed_and_available_in_the_PATH.=
 Built-in_journal_list=, ]"	"Indonesian translation added
"	"Update JabRef_in.properties"
"5"	"Olaf Lenz"	"[src/images/splash-dev.svg, ]"	"[@@ -79,18 +79,18 @@
        width=\"572.00000\"
        patternUnits=\"userSpaceOnUse\">
       <image
-         sodipodi:absref=\"/auto.anoa/home/olenz/projects/software/jabref/src/src/images/behandlet.png\"
+         sodipodi:absref=\"/home/olenz/projects/software/jabref/src/src/images/behandlet.png\"
          xlink:href=\"behandlet.png\"
-         transform=\"translate(-231.0000,-284.3622)\"
-         style=\"opacity:1.0000000;stroke:#000000;stroke-width:5.0000000;stroke-miterlimit:4.0000000;stroke-dasharray:none;stroke-opacity:1.0000000\"
-         inkscape:export-ydpi=\"90.000000\"
-         inkscape:export-xdpi=\"90.000000\"
-         inkscape:export-filename=\"/home/alver/Desktop/bilder/jabref/splash4.png\"
-         y=\"284.36218\"
-         x=\"231.00000\"
-         width=\"572.00000\"
+         id=\"image9050\"
          height=\"428.00000\"
-         id=\"image9050\" />
+         width=\"572.00000\"
+         x=\"231.00000\"
+         y=\"284.36218\"
+         inkscape:export-filename=\"/home/alver/Desktop/bilder/jabref/splash4.png\"
+         inkscape:export-xdpi=\"90.000000\"
+         inkscape:export-ydpi=\"90.000000\"
+         style=\"opacity:1.0000000;stroke:#000000;stroke-width:5.0000000;stroke-miterlimit:4.0000000;stroke-dasharray:none;stroke-opacity:1.0000000\"
+         transform=\"translate(-231.0000,-284.3622)\" />
     </pattern>
     <radialGradient
        inkscape:collect=\"always\"
@@ -136,14 +136,14 @@
        r=\"135.88548\" />
   </defs>
   <sodipodi:namedview
-     inkscape:window-y=\"-3\"
-     inkscape:window-x=\"46\"
-     inkscape:window-height=\"1180\"
-     inkscape:window-width=\"1872\"
-     inkscape:current-layer=\"svg2138\"
+     inkscape:window-y=\"0\"
+     inkscape:window-x=\"35\"
+     inkscape:window-height=\"873\"
+     inkscape:window-width=\"752\"
+     inkscape:current-layer=\"layer1\"
      inkscape:document-units=\"px\"
-     inkscape:cy=\"225.8697\"
-     inkscape:cx=\"22.10531\"
+     inkscape:cy=\"305.8697\"
+     inkscape:cx=\"342.10531\"
      inkscape:zoom=\"1\"
      inkscape:pageshadow=\"2\"
      inkscape:pageopacity=\"0.0\"
@@ -152,7 +152,7 @@
      pagecolor=\"#ffffff\"
      id=\"base\"
      showgrid=\"false\"
-     inkscape:window-maximized=\"1\"
+     inkscape:window-maximized=\"0\"
      fit-margin-top=\"0\"
      fit-margin-left=\"0\"
      fit-margin-right=\"0\"
@@ -174,12 +174,13 @@
      id=\"layer2\"
      inkscape:label=\"Release splash\">
     <image
-       y=\"0\"
-       x=\"1\"
-       id=\"image3381\"
-       xlink:href=\"file:///auto.anoa/home/olenz/projects/software/jabref/src/src/images/splash.png\"
+       sodipodi:absref=\"/home/olenz/projects/software/jabref/src/src/images/splash-release.svg\"
+       xlink:href=\"splash-release.svg\"
+       width=\"576\"
        height=\"432\"
-       width=\"576\" />
+       id=\"image3381\"
+       x=\"1\"
+       y=\"0\" />
   </g>
   <g
      id=\"layer1\"
@@ -204,7 +205,7 @@
          style=\"font-size:85.91455841px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;writing-mode:lr-tb;text-anchor:start;fill:#ff0000;fill-opacity:1;stroke:#ff6600;stroke-width:2.8878212;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;font-family:Bitstream Vera Sans\">dev</tspan></text>
     <text
        xml:space=\"preserve\"
-       style=\"font-size:29.93491554px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans\"
+       style=\"font-size:20.00000002px;font-style:normal;font-weight:bold;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Vera Sans;-inkscape-font-specification:Bitstream Vera Sans Bold;font-stretch:normal;font-variant:normal\"
        x=\"510.92224\"
        y=\"226.16539\"
        id=\"text3244\"
@@ -214,23 +215,23 @@
          x=\"510.92224\"
          y=\"226.16539\"
          id=\"tspan3252\"
-         style=\"font-size:23.9479332px;text-align:center;text-anchor:middle;fill:#ff0000\">This is a</tspan><tspan
+         style=\"font-size:20.00000002px;text-align:center;text-anchor:middle;fill:#ff0000;-inkscape-font-specification:Bitstream Vera Sans Bold;font-family:Bitstream Vera Sans;font-weight:bold;font-style:normal;font-stretch:normal;font-variant:normal\">This is a</tspan><tspan
          sodipodi:role=\"line\"
          x=\"510.92224\"
          y=\"256.10031\"
          id=\"tspan3256\"
-         style=\"font-size:23.9479332px;text-align:center;text-anchor:middle;fill:#ff0000\"><tspan
-   style=\"font-weight:bold;-inkscape-font-specification:Sans Bold\"
+         style=\"font-size:20.00000002px;text-align:center;text-anchor:middle;fill:#ff0000;-inkscape-font-specification:Bitstream Vera Sans Bold;font-family:Bitstream Vera Sans;font-weight:bold;font-style:normal;font-stretch:normal;font-variant:normal\"><tspan
+   style=\"font-weight:bold;-inkscape-font-specification:Bitstream Vera Sans Bold;font-family:Bitstream Vera Sans;font-style:normal;font-stretch:normal;font-variant:normal;font-size:20.00000002px\"
    id=\"tspan3266\">development version</tspan>.</tspan><tspan
          sodipodi:role=\"line\"
          x=\"510.92224\"
          y=\"286.03522\"
          id=\"tspan3258\"
-         style=\"font-size:23.9479332px;text-align:center;text-anchor:middle;fill:#ff0000\">Features may</tspan><tspan
+         style=\"font-size:20.00000002px;text-align:center;text-anchor:middle;fill:#ff0000;-inkscape-font-specification:Bitstream Vera Sans Bold;font-family:Bitstream Vera Sans;font-weight:bold;font-style:normal;font-stretch:normal;font-variant:normal\">Features may</tspan><tspan
          sodipodi:role=\"line\"
          x=\"510.92224\"
          y=\"315.97015\"
          id=\"tspan3260\"
-         style=\"font-size:23.9479332px;text-align:center;text-anchor:middle;fill:#ff0000\">not work as expected.</tspan></text>
+         style=\"font-size:20.00000002px;text-align:center;text-anchor:middle;fill:#ff0000;-inkscape-font-specification:Bitstream Vera Sans Bold;font-family:Bitstream Vera Sans;font-weight:bold;font-style:normal;font-stretch:normal;font-variant:normal\">not work as expected.</tspan></text>
   </g>
 </svg>, ]"	""	"Fixed splash-dev.svg"
"6"	"noravanq"	"[src/main/java/net/sf/jabref/GUIGlobals.java, src/main/java/net/sf/jabref/JabRefPreferences.java, src/main/java/net/sf/jabref/TableColumnsTab.java, src/main/java/net/sf/jabref/gui/MainTableFormat.java, src/main/java/net/sf/jabref/gui/MainTableSelectionListener.java, src/main/java/net/sf/jabref/gui/PreventDraggingJTableHeader.java, ]"	"[@@ -28,6 +28,8 @@
 import javax.swing.ImageIcon;
 import javax.swing.JLabel;
 
+import javax.swing.SwingConstants;
+import net.sf.jabref.external.ExternalFileType;
 import org.xnap.commons.gui.shortcut.EmacsKeyBindings;
 
 import net.sf.jabref.specialfields.Priority;
@@ -411,6 +413,12 @@ public static void init() {
         lab = new JLabel(getImage(\"psSmall\"));
         lab.setToolTipText(Globals.lang(\"Open file\"));
         tableIcons.put(GUIGlobals.FILE_FIELD, lab);
+
+        for(ExternalFileType fileType : Globals.prefs.getExternalFileTypeSelection()) {
+            lab = new JLabel(fileType.getIcon());
+            lab.setToolTipText(Globals.lang(\"Open \"+fileType.getName()+\" file\"));
+            tableIcons.put(fileType.getName(), lab);
+        }
         
         lab = new JLabel(Relevance.getInstance().getRepresentingIcon());
         lab.setToolTipText(Relevance.getInstance().getToolTip());, @@ -424,6 +424,9 @@ private JabRefPreferences() {
         defaults.put(\"fileColumn\", Boolean.TRUE);
         defaults.put(\"arxivColumn\", Boolean.FALSE);
 
+        defaults.put(\"extraFileColumns\", Boolean.FALSE);
+        defaults.put(\"listOfFileColumns\",\"\");
+
         defaults.put(SpecialFieldsUtils.PREF_SPECIALFIELDSENABLED, SpecialFieldsUtils.PREF_SPECIALFIELDSENABLED_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_SHOWCOLUMN_PRIORITY, SpecialFieldsUtils.PREF_SHOWCOLUMN_PRIORITY_DEFAULT);
         defaults.put(SpecialFieldsUtils.PREF_SHOWCOLUMN_QUALITY, SpecialFieldsUtils.PREF_SHOWCOLUMN_QUALITY_DEFAULT);, @@ -33,6 +33,7 @@
 import com.jgoodies.forms.builder.DefaultFormBuilder;
 import com.jgoodies.forms.layout.CellConstraints;
 import com.jgoodies.forms.layout.FormLayout;
+import net.sf.jabref.external.ExternalFileType;
 
 class TableColumnsTab extends JPanel implements PrefsTab {
 
@@ -44,6 +45,10 @@
     private JabRefFrame frame;
 
     private JCheckBox pdfColumn, urlColumn, fileColumn, arxivColumn;
+
+    private JCheckBox extraFileColumns;
+    private JList listOfFileColumns;
+
     private JRadioButton preferUrl, preferDoi;
 
     private JCheckBox showOneLetterHeadingForIconColumns;
@@ -199,6 +204,22 @@ public void stateChanged(ChangeEvent arg0) {
 		});
 		arxivColumn = new JCheckBox(Globals.lang(\"Show ArXiv column\"));
 
+		extraFileColumns = new JCheckBox(Globals.lang(\"Show Extra columns\"));
+                extraFileColumns.addChangeListener(new ChangeListener() {
+                        @Override
+                        public void stateChanged(ChangeEvent arg0) {
+                                listOfFileColumns.setEnabled(extraFileColumns.isSelected());
+                        }
+                });
+                ExternalFileType[] fileTypes = Globals.prefs.getExternalFileTypeSelection();
+                String[] fileTypeNames = new String[fileTypes.length];
+                for(int i=0;i<fileTypes.length;i++) {
+                    fileTypeNames[i]=fileTypes[i].getName();
+                }
+                listOfFileColumns = new JList(fileTypeNames);
+                JScrollPane listOfFileColumnsScrollPane = new JScrollPane(listOfFileColumns);
+                listOfFileColumns.setVisibleRowCount(3);
+
 		/*** begin: special table columns and special fields ***/
 
 		HelpAction help = new HelpAction(frame.helpDiag, GUIGlobals.specialFieldsHelp);
@@ -266,6 +287,9 @@ public void stateChanged(ChangeEvent event) {
 		specialTableColumnsBuilder.add(preferDoi, cc.xy(6, 5));	
 		specialTableColumnsBuilder.add(arxivColumn, cc.xyw(5, 6, 2));	
 
+		specialTableColumnsBuilder.add(extraFileColumns, cc.xyw(5, 7, 2));	
+		specialTableColumnsBuilder.add(listOfFileColumnsScrollPane, cc.xywh(5, 8, 2, 3));	
+
 		builder.append(specialTableColumnsBuilder.getPanel());
 		builder.nextLine();
 
@@ -300,6 +324,26 @@ public void setValues() {
         fileColumn.setSelected(_prefs.getBoolean(\"fileColumn\"));
         arxivColumn.setSelected(_prefs.getBoolean(\"arxivColumn\"));
 
+        extraFileColumns.setSelected(_prefs.getBoolean(\"extraFileColumns\"));
+        if(extraFileColumns.isSelected()) {
+            String[] desiredColumns = _prefs.getStringArray(\"listOfFileColumns\");
+            int listSize = listOfFileColumns.getModel().getSize();
+            int[] indicesToSelect = new int[listSize];
+            for(int i=0;i<listSize;i++) {
+                indicesToSelect[i]=listSize+1;
+                for(int j=0;j<desiredColumns.length;j++) {
+                    if(listOfFileColumns.getModel().getElementAt(i).equals(desiredColumns[j])) {
+                        indicesToSelect[i]=i;
+                        break;
+                    }
+                }
+            }
+            listOfFileColumns.setSelectedIndices(indicesToSelect);
+        }
+        else {
+            listOfFileColumns.setSelectedIndices(new int[] {});
+        }
+
         /*** begin: special fields ***/
 
         oldRankingColumn = _prefs.getBoolean(SpecialFieldsUtils.PREF_SHOWCOLUMN_RANKING);
@@ -562,6 +606,19 @@ public void storeSettings() {
 		_prefs.putBoolean(\"urlColumn\", urlColumn.isSelected());
 		_prefs.putBoolean(\"preferUrlDoi\", preferDoi.isSelected());
 		_prefs.putBoolean(\"arxivColumn\", arxivColumn.isSelected());
+
+		_prefs.putBoolean(\"extraFileColumns\", extraFileColumns.isSelected());
+                if(extraFileColumns.isSelected()&&!listOfFileColumns.isSelectionEmpty()) {
+                    String[] selections = new String[listOfFileColumns.getSelectedIndices().length];
+                    for(int i=0;i<selections.length;i++) {
+                        selections[i]=listOfFileColumns.getModel().getElementAt(
+                                listOfFileColumns.getSelectedIndices()[i]).toString();
+                    }
+                    _prefs.putStringArray(\"listOfFileColumns\", selections);
+                }
+                else {
+                    _prefs.putStringArray(\"listOfFileColumns\", new String[] {});
+                }
 		
 		_prefs.putBoolean(JabRefPreferences.SHOWONELETTERHEADINGFORICONCOLUMNS, showOneLetterHeadingForIconColumns.isSelected());
 , @@ -35,6 +35,12 @@
 import net.sf.jabref.specialfields.SpecialFieldsUtils;
 import ca.odell.glazedlists.gui.TableFormat;
 import ca.odell.glazedlists.matchers.Matcher;
+import java.awt.Color;
+import java.awt.Graphics;
+import java.awt.image.BufferedImage;
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
+import javax.swing.JLabel;
 
 /**
  * Class defining the contents and column headers of the main table.
@@ -173,6 +179,23 @@ public boolean isRankingColumn(int col) {
         return false;
     }
 
+    private Object modifyIconForMultipleLinks(JLabel label) {
+        Icon icon = label.getIcon();
+        BufferedImage bufImg = new BufferedImage(
+            icon.getIconWidth(),
+            icon.getIconHeight(),
+            BufferedImage.TYPE_INT_ARGB);
+        Graphics g = bufImg.createGraphics();
+        // paint the Icon to the BufferedImage.
+        icon.paintIcon(null, g, 0,0);
+        // add the letter \"m\" in the bottom right corner
+        g.setColor(Color.BLACK);
+        g.setFont(new java.awt.Font(\"Serif\", java.awt.Font.PLAIN, 12));
+        g.drawString(\"m\",bufImg.getWidth() - g.getFontMetrics().stringWidth(\"m\"),bufImg.getHeight());
+        g.dispose();
+        return new JLabel(new ImageIcon(bufImg));
+    }
+    
     public Object getColumnValue(BibtexEntry be, int col) {
         Object o = null;
         String[] iconType = getIconTypeForColumn(col); // If non-null, indicates an icon column's type.
@@ -183,16 +206,21 @@ public Object getColumnValue(BibtexEntry be, int col) {
 
         else if (iconType != null) {
             int hasField = -1;
-            for (int i = iconType.length - 1; i >= 0; i--)
-                if (hasField(be, iconType[i]))
-                    hasField = i;
+
+            int[] fieldCount = hasField(be,iconType);
+            hasField=fieldCount[0];
+
             if (hasField < 0)
                 return null;
 
             // Ok, so we are going to display an icon. Find out which one, and return it:
             if (iconType[hasField].equals(GUIGlobals.FILE_FIELD)) {
                 o = FileListTableModel.getFirstLabel(be.getField(GUIGlobals.FILE_FIELD));
 
+            if(fieldCount[1]>1) {
+                o = modifyIconForMultipleLinks((JLabel)o);
+            }
+
             // Handle priority column special
             // Extra handling because the icon depends on a FieldValue
             } else if (iconType[hasField].equals(PRIORITY[0])) {
@@ -210,6 +238,10 @@ else if (iconType != null) {
                 }
             } else {
                 o = GUIGlobals.getTableIcon(iconType[hasField]);
+
+                if(fieldCount[1]>1) {
+                    o = modifyIconForMultipleLinks((JLabel)o);
+                }
             }
         } else {
             String[] fld = columns[col - padleft];
@@ -265,6 +297,51 @@ public boolean hasField(BibtexEntry be, String field) {
         return ((be != null) && (be.getField(field) != null));
     }
 
+    public int[] hasField(BibtexEntry be, String[] field) {
+        // If the entry has a nonzero value in any of the
+        // 'search' fields, returns the smallest index for which it does. 
+        // Otherwise returns -1. When field indicates one or more file types,
+        // returns the index of the first present file type.
+        if(be==null||field==null||field.length<1) {
+            return new int[] {-1,-1};
+        }
+        int hasField=-1;
+        if(!field[0].equals(GUIGlobals.FILE_FIELD)) {
+            for (int i = field.length - 1; i >= 0; i--) {
+                if (hasField(be, field[i])) {
+                    hasField = i;
+                }
+            }
+            return new int[] {hasField,-1};
+        }
+        else {
+            // We use a FileListTableModel to parse the field content:
+            Object o = be.getField(GUIGlobals.FILE_FIELD);
+            FileListTableModel fileList = new FileListTableModel();
+            fileList.setContent((String)o);
+            if(field.length==1) {
+                if(fileList.getRowCount()==0) {
+                    return new int[] {-1,-1};
+                }
+                else {
+                    return new int[] {0,fileList.getRowCount()};
+                }
+            }
+            int lastLinkPosition=-1, countLinks = 0;
+            for (int i = 1; i < field.length; i++) {
+                // Count the number of links of correct type.
+                for (int j=0; j<fileList.getRowCount(); j++) {
+                    FileListEntry flEntry = fileList.getEntry(j);
+                    if(flEntry.getType().toString().equals(field[i])) {
+                        lastLinkPosition=i;
+                        countLinks++;
+                    }
+                }
+            }
+            return new int[] {lastLinkPosition,countLinks};
+        }
+    }
+
     public void updateTableFormat() {
 
         // Read table columns from prefs:
@@ -318,6 +395,13 @@ public void updateTableFormat() {
         if (Globals.prefs.getBoolean(\"arxivColumn\"))
             iconCols.put(coln++, ARXIV);
 
+        if (Globals.prefs.getBoolean(\"extraFileColumns\")) {
+            String[] desiredColumns = Globals.prefs.getStringArray(\"listOfFileColumns\");
+            for(int i=0;i<desiredColumns.length;i++) {
+                iconCols.put(coln++, new String[] {GUIGlobals.FILE_FIELD,desiredColumns[i]});
+            }
+        }
+
         // Add 1 to the number of icon columns to get padleft.
         padleft = 1 + iconCols.size();
 , @@ -35,13 +35,17 @@
 import net.sf.jabref.FocusRequester;
 import net.sf.jabref.GUIGlobals;
 import net.sf.jabref.Globals;
+import net.sf.jabref.JabRefFrame;
 import net.sf.jabref.PreviewPanel;
 import net.sf.jabref.RightClickMenu;
 import net.sf.jabref.Util;
 import net.sf.jabref.external.ExternalFileMenuItem;
 import ca.odell.glazedlists.EventList;
 import ca.odell.glazedlists.event.ListEvent;
 import ca.odell.glazedlists.event.ListEventListener;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import net.sf.jabref.specialfields.SpecialField;
 import net.sf.jabref.specialfields.SpecialFieldValue;
 import net.sf.jabref.specialfields.SpecialFieldsUtils;
@@ -301,6 +305,14 @@ public void mouseClicked(MouseEvent e) {
                 return;
             final String fieldName = iconType[hasField];
 
+            //If this is a file link field with specified file types,
+            //we should also pass the types.
+            String[] fileTypes={};
+            if(hasField==0&&iconType[hasField].equals(GUIGlobals.FILE_FIELD)&&iconType.length>1) {
+                fileTypes=iconType;
+            }
+            final List<String> listOfFileTypes = Collections.unmodifiableList(Arrays.asList(fileTypes));
+
             // Open it now. We do this in a thread, so the program won't freeze during the wait.
             (new Thread() {
                 public void run() {
@@ -320,9 +332,33 @@ public void run() {
                             // We use a FileListTableModel to parse the field content:
                             FileListTableModel fileList = new FileListTableModel();
                             fileList.setContent((String)link);
-                            // If there are one or more links, open the first one:
-                            if (fileList.getRowCount() > 0) {
-                                FileListEntry flEntry = fileList.getEntry(0);
+
+                            FileListEntry flEntry=null;
+                            // If there are one or more links of the correct type,
+                            // open the first one:
+                            if(listOfFileTypes.size()>0) {
+                                for(int i=0;i<fileList.getRowCount();i++) {
+                                    flEntry = fileList.getEntry(i);
+                                    boolean correctType=false;
+                                    for(int j=0;j<listOfFileTypes.size();j++) {
+                                        if(flEntry.getType().toString().equals(listOfFileTypes.get(j))) {
+                                            correctType=true;
+                                        }
+                                    }
+                                    if(correctType) {
+                                        break;
+                                    }
+                                    flEntry=null;
+                                }
+                            }
+                            //If there are no file types specified, consider all files.
+                            else if(fileList.getRowCount()>0) {
+                                flEntry=fileList.getEntry(0);
+                            }
+                            if(flEntry!=null) {
+//                            if (fileList.getRowCount() > 0) {
+//                                FileListEntry flEntry = fileList.getEntry(0);
+
                                 ExternalFileMenuItem item = new ExternalFileMenuItem
                                         (panel.frame(), entry, \"\",
                                         flEntry.getLink(), flEntry.getType().getIcon(),
@@ -403,6 +439,20 @@ private void showIconRightClickMenu(MouseEvent e, int row, String[] iconType) {
             // If there are one or more links, open the first one:
             for (int i=0; i<fileList.getRowCount(); i++) {
                 FileListEntry flEntry = fileList.getEntry(i);
+
+                //If file types are specified, ignore files of other types.
+                if(iconType.length>1) {
+                    boolean correctType=false;
+                    for(int j=1;j<iconType.length;j++) {
+                        if(flEntry.getType().toString().equals(iconType[j])) {
+                            correctType=true;
+                        }
+                    }
+                    if(!correctType) {
+                        continue;
+                    }
+                }
+
                 String description = flEntry.getDescription();
                 if ((description == null) || (description.trim().length() == 0))
                     description = flEntry.getLink();, @@ -21,6 +21,7 @@
 import javax.swing.table.TableColumnModel;
 
 import net.sf.jabref.Globals;
+import net.sf.jabref.Util;
 import net.sf.jabref.specialfields.SpecialFieldsUtils;
 
 /**
@@ -119,6 +120,10 @@ private int getSpecialColumnsCount() {
         if (Globals.prefs.getBoolean(\"arxivColumn\")) {
             count++;
         }
+
+        if (Globals.prefs.getBoolean(\"extraFileColumns\")) {
+            count+=Globals.prefs.getStringArray(\"listOfFileColumns\").length;
+        }
         
         // special field columns may also not be dragged
         if (Globals.prefs.getBoolean(SpecialFieldsUtils.PREF_SPECIALFIELDSENABLED)) {, ]"	"```
The user can now specify an arbitrary number of file-link columns in te \"Entry table columns\" preferences tab, to be added to the main table. The user can any file types specified in the list of External File Types. The extra columns work exactly like the original file-link column.

For each file-link column whenever there are multiple files, the letter \"m\" is displayed at the bottom right corner of the icon.
```

 Committer: noravanq

 On branch master
 Changes to be committed:
   (use \"git reset HEAD <file>...\" to unstage)

```
modified:   src/main/java/net/sf/jabref/GUIGlobals.java
modified:   src/main/java/net/sf/jabref/JabRefPreferences.java
modified:   src/main/java/net/sf/jabref/TableColumnsTab.java
modified:   src/main/java/net/sf/jabref/gui/MainTableFormat.java
modified:   src/main/java/net/sf/jabref/gui/MainTableSelectionListener.java
modified:   src/main/java/net/sf/jabref/gui/PreventDraggingJTableHeader.java
```
"	" I have implemented 2 features requested in Ticket #841."
"7"	"Adrian Daerr"	"[src/main/java/net/sf/jabref/util/XMPUtil.java, ]"	"[@@ -996,7 +996,20 @@ public static void writeDocumentInformation(PDDocument document,
 		for (String field : fields){
 
 			if (useXmpPrivacyFilter && filters.contains(field)) {
-				continue;
+                            // erase field instead of adding it
+                            if (field.equals(\"author\")) {
+				di.setAuthor(null);
+                            } else if (field.equals(\"title\")) {
+				di.setTitle(null);
+                            } else if (field.equals(\"keywords\")) {
+				di.setKeywords(null);
+                            } else if (field.equals(\"abstract\")) {
+				di.setSubject(null);
+                            } else {
+				di.setCustomMetadataValue(\"bibtex/\" + field,
+                                                          null);
+                            }
+                            continue;
 			}
 
 			if (field.equals(\"author\")) {, ]"	"This pull-request pertains to the addition of metadata to PDF files associated with entries, as triggered by the menu entry \"Write XMP metadata to PDFs\" in the \"Tools\" menu. XMP is an extremely interesting feature that allows tagging PDF files (amongst others) with automatically retrievable metadata in much the same way mp3-tags allow adding title/author/... information to mp3 music files. Actually JabRef exports the metadata not only to two XMP namespaces (Dublin Core and a custom JabRef namespace), but also to the PDF DocumentInformation Object.

Practically from the beginning of the XMP-writing capabilities of JabRef, Christopher Oezbek had added _privacy filtering_ for the XMP-tagging of PDF-files with data from the bibtex-record, meaning that the user could define a list of fields (in Preferences->XMP metadata) which should _not_ be exported to the PDF file.  Unfortunately, the filtering was incomplete: jabref exports the metadata in three different forms, only one of which was originally filtered. In 2013 filtering was extended to both XMP namespaces, but JabRef still exported _all_ fields into the PDF DocumentInfo object. The two present commits correct this problem. The first (b45316f) prevents private fields from being exported to the PDF DocumentInfo. The second one more agressively erases these fields even if they already exist in the PDF document. 

The deletion of existing fields might be debateable. It seems the right thing to do for fields clearly generated by JabRef (viz. those prefixed by \"jabref/\"), but there are four fields which might be of other origin (Author,Title,Subject and Keywords). Making a systematic exception for these four fields, i.e. not erasing them even if they are privacy filtered, is a bad idea and violates the principle of least surprise. This is why the second commit makes no exception. Deactivating the erasure for the four generic fields could however easily be added as an option in the XMP export preferences if it is judged important. The current behaviour has the advantage of reliably correcting PDF files previously tagged with a buggy privacy filtering.

If these commits are pulled into the master branch and confirmed to work, the bug #869 on the sourceforge tracker: 
https://sourceforge.net/p/jabref/bugs/869/
can be closed.
"	"PDF-file metadata: Privacy Filtering all metadata"
"8"	"Peter Ansell"	"[src/main/java/net/sf/jabref/external/ACSPdfDownload.java, ]"	"[@@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 JabRef contributors.
+/*  Copyright (C) 2014 Commonwealth Scientific and Industrial Research Organisation
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or, ]"	"Adds a FullTextFinder implementation to transform the ACS DOI redirect URLs to their PDF download equivalents.
"	"Support FindFullText with ACS DOIs"
"9"	"Ling Wang"	"[src/main/java/net/sf/jabref/BibtexEntry.java, src/main/java/net/sf/jabref/BibtexEntryType.java, testbib/testjabref.bib, testbib/testjabref_210as292.bib, testbib/testjabref_292.bib, ]"	"[@@ -421,8 +421,10 @@ public void write(Writer out, FieldFormatter ff, boolean write) throws IOExcepti
             break;
         case 1:
             writeUnsorted(out, ff, write);
+            break;
         case 2:
             writeUserOrder(out,ff,write);
+            break;
         }
         
         , @@ -84,7 +84,7 @@ public String getName()
             {
                 return new String[]
                 {
-                    \"volume\", \"number\", \"pages\", \"month\", \"note\", //- \"volume\", \"pages\", \"part\", \"eid\"
+                    \"volume\", \"pages\", \"number\", \"month\", \"note\", //- \"volume\", \"pages\", \"part\", \"eid\"
                 };
             }
 , @@ -0,0 +1,313 @@
+% This file was created with JabRef devel - 1st edition family.
+% Encoding: UTF8
+
+
+@Article{Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS,
+  Title                    = {256-Channel Neural Recording and Delta Compression Microsystem With
+ 3D Electrodes},
+  Author                   = {Aziz, Joseph N. Y. and Abdelhalim, Karim and Shulyzki, Ruslana and
+ Genov, Roman and Bardakjian, Berj L. and Derchansky, Miron and Serletis,
+ Demitre and Carlen, Peter L.},
+  Journal                  = {IEEE JOURNAL OF SOLID-STATE CIRCUITS},
+  Year                     = {2009},
+
+  Month                    = {MAR},
+  Number                   = {3},
+  Pages                    = {995-1005},
+  Volume                   = {44},
+
+  Abstract                 = {A 3D microsystem for multi-site penetrating extracellular neural recording
+ from the brain is presented. A 16 x 16-channel neural recording interface
+ integrated prototype fabricated in 0.35 mu m CMOS occupies 3.5 mm
+ x 4.5 mm area. Each recording channel dissipates 15 mu W of power
+ with input-referred noise of 7 mu V-rms over 5 kHz bandwidth. A switched-capacitor
+ delta read-out data compression circuit trades recording accuracy
+ for the output data rate. An array of 1.5 mm platinum-coated microelectrodes
+ is bonded directly onto the die. Results of in vitro experimental
+ recordings from intact mouse hippocampus validate the circuit design
+ and the on-chip electrode bonding technology.},
+  Address                  = {445 HOES LANE, PISCATAWAY, NJ 08855 USA},
+  Affiliation              = {Aziz, JNY (Reprint Author), Broadcom, Irvine, CA 92617 USA. {[}Aziz,
+ Joseph N. Y.; Abdelhalim, Karim; Shulyzki, Ruslana; Genov, Roman]
+ Univ Toronto, Dept Elect \& Comp Engn, Toronto, ON M5S 3G4, Canada.
+ {[}Bardakjian, Berj L.] Univ Toronto, Inst Biomat \& Biomed Engn,
+ Edward S Rogers Sr Dept Elect \& Comp Engn, Toronto, ON M5S 1A4,
+ Canada. {[}Derchansky, Miron; Serletis, Demitre; Carlen, Peter L.]
+ Univ Toronto, Toronto Western Res Inst, Toronto, ON M5S 1A4, Canada.
+ {[}Derchansky, Miron; Serletis, Demitre; Carlen, Peter L.] Univ Toronto,
+ Dept Physiol, Toronto, ON M5S 1A4, Canada.},
+  Author-email             = {roman@eecg.utoronto.ca},
+  Cited-references         = {ATLURI S, 2006, P IEEE INT S CIRC SY, P1131. AZIZ J, 2006, P IEEE
+ INT S CIRC SY. AZIZ J, 2007, IEEE INT SOL STAT CI, P160. AZIZ JNY,
+ 2006, P IEEE INT S CIRC SY, P5075. AZIZ JNY, 2007, IEEE T BIOMED
+ CIRCUI, V1. AZIZ JNY, 2007, P IEEE INT S CIRC SY. CHAIMANONART N,
+ 2005, P ANN INT IEEE EMBS, P5194. DELBRUCK T, 1994, P IEEE INT S
+ CIRC SY, V4, P339. ENZ CC, 1996, P IEEE, V84, P1584. EVERSMANN B,
+ 2003, IEEE J SOLID-ST CIRC, V38, P2306, DOI 10.1109/JSSC.2003.819174.
+ HARRISON R, 2006, IEEE INT SOL STAT C, P2258. HARRISON RR, 2003,
+ IEEE J SOLID-ST CIRC, V38, P958, DOI 10.1009/JSSC.2003.811979. HARRISON
+ RR, 2007, IEEE CUST INTEGR CIR, P115. HEER F, 2006, IEEE J SOLID-ST
+ CIRC, V41, P1620, DOI 10.1109/JSSC.2006.873677. KIM S, 2006, P 2006
+ INT C IEEE EN, P2986. MALLIK U, 2005, IEEE ISSCC, P362. MOHSENI P,
+ 2004, IEEE T BIO-MED ENG, V51, P832, DOI 10.1109/TBME.2004.824126.
+ MOTCHENBACHER CD, 1993, LOW NOISE ELECT SYST. OLSSON RH, 2005, IEEE
+ J SOLID-ST CIRC, V40, P2796. PATTERSON WR, 2004, IEEE T BIO-MED ENG,
+ V51, P1845, DOI 10.1109/TBME.2004.831521. RILEY G, 1987, SURFACE
+ MOUNT INT, P535. STEYAERT MSJ, 1987, IEEE J SOLID-ST CIRC, V22, P1163.
+ TSIVIDIS Y, 2003, OPERATION MODELING M. WATTANAPANITCH W, 2007, IEEE
+ T BIOMED CIRC S, V1, P136, DOI 10.1109/TBCAS.2007.907868. WISE KD,
+ 2005, IEEE ENG MED BIOL, V24, P22.},
+  Doc-delivery-number      = {415FE},
+  Doi                      = {10.1109/JSSC.2008.2010997},
+  File                     = {Draft:JabRef\\Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS_draft.pdf:PDF;Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS.pdf:JabRef\\Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS.pdf:PDF},
+  ISSN                     = {0018-9200},
+  Journal-iso              = {IEEE J. Solid-State Circuit},
+  Keywords                 = {Multi-channel recording; microelectrodes; extracellular recording;
+ electrode array; implantable; brain; hippocampus; delta compression;
+ neural amplifier},
+  Keywords-plus            = {AMPLIFIER; STABILIZATION; CIRCUIT; ARRAY},
+  Language                 = {English},
+  Number-of-cited-references = {25},
+  Publisher                = {IEEE-INST ELECTRICAL ELECTRONICS ENGINEERS INC},
+  Subject-category         = {Engineering, Electrical \& Electronic},
+  Times-cited              = {2},
+  Timestamp                = {10.04.15.11.41},
+  Type                     = {Article},
+  Unique-id                = {ISI:000263918900029}
+}
+
+@Article{BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering,
+  Title                    = {Patterning PDMS using a combination of wet and dry etching},
+  Author                   = {B Balakrisnan , S Patil and E Smela},
+  Journal                  = {Journal of Micromechanics and Microengineering},
+  Year                     = {2009},
+  Number                   = {4},
+  Pages                    = {047002},
+  Volume                   = {19},
+
+  Abstract                 = {PDMS films of 10 �m thickness can be patterned within 30 min by combining
+ dry etching to achieve substantially vertical sidewalls with wet
+ etching to achieve high etch rates and to protect the underlying
+ substrate from attack. Dry etching alone would have taken 5 h, and
+ wet etching alone would produce severe undercutting. In addition,
+ using either technique alone produces undesirable surface morphologies.
+ The mask used during etching is critical to a successful patterning
+ outcome. E-beam evaporated Al was found to work well, adhering strongly
+ to oxygen-plasma-treated PDMS and holding up well during both dry
+ and wet etching. To prevent wrinkling of the PDMS, a fast deposition
+ rate should be used.},
+  File                     = {BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering.pdf:JabRef\\BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering.pdf:PDF},
+  Timestamp                = {09.06.17.13.03},
+  Url                      = {http://stacks.iop.org/0960-1317/19/i=4/a=047002}
+}
+
+@Article{Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA,
+  Title                    = {Synaptic facilitation by reflected action potentials: enhancement
+ of transmission when nerve impulses reverse direction at axon branch
+ points.},
+  Author                   = {S. A. Baccus},
+  Journal                  = {Proc Natl Acad Sci U S A},
+  Year                     = {1998},
+
+  Month                    = {Jul},
+  Number                   = {14},
+  Pages                    = {8345--8350},
+  Volume                   = {95},
+
+  Abstract                 = {A rapid, reversible enhancement of synaptic transmission from a sensory
+ neuron is reported and explained by impulses that reverse direction,
+ or reflect, at axon branch points. In leech mechanosensory neurons,
+ where one can detect reflection because it is possible simultaneously
+ to study electrical activity in separate branches, action potentials
+ reflected from branch points within the central nervous system under
+ physiological conditions. Synapses adjacent to these branch points
+ were activated twice in rapid succession, first by an impulse arriving
+ from the periphery and then by its reflection. This fast double-firing
+ facilitated synaptic transmission, increasing it to more than twice
+ its normal level. Reflection occurred within a range of resting membrane
+ potentials, and electrical activity produced by mechanical stimulation
+ changed membrane potential so as to produce and cease reflection.
+ A compartmental model was used to investigate how branch-point morphology
+ and electrical activity contribute to produce reflection. The model
+ shows that mechanisms that hyperpolarize the membrane so as to impair
+ action potential propagation can increase the range of structures
+ that can produce reflection. This suggests that reflection is more
+ likely to occur in other structures where impulses fail, such as
+ in axons and dendrites in the mammalian brain. In leech sensory neurons,
+ reflection increased transmission from central synapses only in those
+ axon branches that innervate the edges of the receptive field in
+ the skin, thereby sharpening spatial contrast. Reflection thus allows
+ a neuron to amplify synaptic transmission from a selected group of
+ its branches in a way that can be regulated by electrical activity.},
+  File                     = {Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA.pdf:JabRef\\Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA.pdf:PDF},
+  Institution              = {Neuroscience Program, University of Miami, Miami, FL 33136, USA.
+ sbaccus@mednet.med.miami.edu},
+  Keywords                 = {Action Potentials, physiology; Animals; Axons, physiology; Electrophysiology;
+ Ganglia, Invertebrate, physiology; Ganglia, Sensory, physiology;
+ Leeches; Neurons, physiology; Synapses, physiology; Synaptic Transmission,
+ physiology},
+  Language                 = {eng},
+  Medline-pst              = {ppublish},
+  Pmid                     = {9653189},
+  Timestamp                = {11.05.01.13.02}
+}
+
+@Article{Brewer1995Serum-freeB27/neurobasalmediumsupportsdifferentiatedgrowthofneuronsfromthestriatumsubstantianigraseptumcerebralcortexcerebellumanddentategyrus.JNeurosciRes,
+  Title                    = {Serum-free B27/neurobasal medium supports differentiated growth of
+ neurons from the striatum, substantia nigra, septum, cerebral cortex,
+ cerebellum, and dentate gyrus.},
+  Author                   = {G. J. Brewer},
+  Journal                  = {J Neurosci Res},
+  Year                     = {1995},
+
+  Month                    = {Dec},
+  Number                   = {5},
+  Pages                    = {674--683},
+  Volume                   = {42},
+
+  Abstract                 = {Two fundamental questions about neuron cell culture were addressed.
+ Can one serum-free medium that was developed for optimum growth of
+ hippocampal neurons support the growth of neurons from other regions
+ of the brain? Is the region specific state of differentiation maintained
+ in culture? To answer these questions, we isolated neurons from six
+ other rat brain regions, placed them in culture in B27/Neurobasal
+ defined medium, and analyzed their morphology and growth dependence
+ on cell density after 4 days in culture. Neuronal identity was confirmed
+ by immunostaining with antibodies to neurofilament 200. Neurons from
+ each brain region maintained distinctive morphologies in culture
+ in the virtual absence of glia. Cells isolated from embryonic day
+ 18 cerebral cortex by digestion with papain showed the same high
+ survival as hippocampal neurons, e.g., 70\% survival for cells plated
+ at 160/mm2. At this age and density, neurons from the septum showed
+ slightly lower survival, 45\%. Survival of dentate granule neurons
+ from postnatal day four brains was 30-40\%, significantly lower,
+ and relatively independent of plating density. This suggests an absence
+ of dependence on trophic factors or contact for dentate granule neurons.
+ Growth of cerebellar granule neurons isolated from postnatal day
+ 7, 8, or 9 brains in B27/Neurobasal was compared to growth in BME/10\%
+ serum. Viability in serum-free medium at 4 days was much better than
+ that in serum, did not require KCl elevated to 25 mM, and occurred
+ without substantial growth of glia. Cerebellar granule neurons plated
+ at 1,280 cells/mm2 were maintained in culture for three weeks with
+ 17\% of the original cell density surviving. Survival of cells isolated
+ from embryonic day 18 substantia nigra was 50\% at 160 cells/mm2
+ after 4 days, similar to that of striatum, but slightly less than
+ hippocampal neuron survival. The dopaminergic phenotype of the substantia
+ nigral neurons was maintained over 2 weeks in culture as judged by
+ immunoreactivity with antibodies to tyrosine hydroxylase. During
+ this time, immunoreactivity was found in the processes as they grew
+ out from the soma. Together, these studies suggest that B27/Neurobasal
+ will be a useful medium for maintaining the differentiated growth
+ of neurons from many brain regions. Potential applications of a common
+ growth medium for different neurons are discussed.},
+  Doi                      = {10.1002/jnr.490420510},
+  Institution              = {Southern Illinois University School of Medicine, Springfield 62794-1220,
+ USA.},
+  Keywords                 = {Animals; Brain, anatomy /&/ histology/cytology/enzymology; Cell Culture
+ Techniques; Cell Survival; Cells, Cultured; Cerebellum, cytology/embryology;
+ Cerebral Cortex, cytology/embryology; Corpus Striatum, cytology/embryology;
+ Culture Media, Serum-Free; Dentate Gyrus, cytology/embryology; Electrophysiology;
+ Hippocampus, cytology/embryology; Neurofilament Proteins, metabolism;
+ Neurons, cytology/enzymology; Rats; Rats, Sprague-Dawley; Septum
+ Pellucidum, embryology; Substantia Nigra, cytology/embryology; Tyrosine
+ 3-Monooxygenase, metabolism},
+  Pmid                     = {8600300},
+  Timestamp                = {2008.12.12},
+  Url                      = {http://dx.doi.org/10.1002/jnr.490420510}
+}
+
+@Article{Brewer1997Isolationandcultureofadultrathippocampalneurons.JNeurosciMethods,
+  Title                    = {Isolation and culture of adult rat hippocampal neurons.},
+  Author                   = {G. J. Brewer},
+  Journal                  = {J Neurosci Methods},
+  Year                     = {1997},
+
+  Month                    = {Feb},
+  Number                   = {2},
+  Pages                    = {143--155},
+  Volume                   = {71},
+
+  Abstract                 = {Inability to culture adult central neurons and the failure of injured
+ neurons to regenerate in the brain could be due to genetic controls
+ or environmental inhibitors. We tested the environmental inhibitor
+ hypothesis by attempting to regenerate adult rat neurons in B27/Neurobasal
+ culture medium, a medium optimized for survival of embryonic neurons.
+ To isolate neurons from their numerous connections, papain was the
+ best of six different proteases screened on slices of hippocampus
+ for survival of isolated cells after 4 days of culture. Use of a
+ density gradient enabled separation of oligodendroglia and some enrichment
+ of neurons and microglia from considerable debris which was inhibitory
+ to sprouting and viability. With these techniques, about 900000 viable
+ neurons were isolated from each hippocampus of any age rat from birth
+ to 24-36 months, near the median mortality. FGF2 was found to enhance
+ viability at least 3-fold to 40-80\%, independent of age, without
+ affecting the length of the processes. Neurons were cultured for
+ more than 3 weeks. These methods demonstrate that hippocampal neurons
+ can regenerate axons and dendrites if provided with adequate nutrition
+ and if inhibitors are removed. They also will enable aging studies.
+ Therefore, the concept of environmental growth restriction may be
+ more appropriate for neurons in the brain than the concept of a genetic
+ block that precludes regeneration of processes.},
+  Institution              = {Department of Medical Microbiology and Immunology, Southern Illinois
+ University School of Medicine, Springfield 62794-1220, USA. gbrewer@siumed.edu},
+  Keywords                 = {Age Factors; Animals; Cell Adhesion, physiology; Cell Culture Techniques,
+ methods; Cell Separation, methods; Cell Survival, physiology; Cells,
+ Cultured; Cerebral Cortex, cytology; Dose-Response Relationship,
+ Drug; Fibroblast Growth Factor 2, physiology; Glutamic Acid, pharmacology;
+ Hippocampus, cytology; Male; Neurons, cytology/drug effects; Osmolar
+ Concentration; Oxygen, pharmacology; Papain; Rats; Rats, Inbred F344;
+ Rats, Sprague-Dawley},
+  Pii                      = {S0165-0270(96)00136-7},
+  Pmid                     = {9128149},
+  Timestamp                = {09.02.26.19.31}
+}
+
+@Article{Brewer2008NbActiv4mediumimprovementtoNeurobasal/B27increasesneuronsynapsedensitiesandnetworkspikeratesonmultielectrodearrays.JNeurosciMethods,
+  Title                    = {NbActiv4 medium improvement to Neurobasal/B27 increases neuron synapse
+ densities and network spike rates on multielectrode arrays.},
+  Author                   = {Gregory J Brewer and Michael D Boehler and Torrie T Jones and Bruce
+ C Wheeler},
+  Journal                  = {J Neurosci Methods},
+  Year                     = {2008},
+
+  Month                    = {May},
+  Number                   = {2},
+  Pages                    = {181--187},
+  Volume                   = {170},
+
+  Abstract                 = {The most interesting property of neurons is their long-distance propagation
+ of signals as spiking action potentials. Since 1993, Neurobasal/B27
+ has been used as a serum-free medium optimized for hippocampal neuron
+ survival. Neurons on microelectrode arrays (MEA) were used as an
+ assay system to increase spontaneous spike rates in media of different
+ compositions. We find spike rates of 0.5 s(-1) (Hz) for rat embryonic
+ hippocampal neurons cultured in Neurobasal/B27, lower than cultures
+ in serum-based media and offering an opportunity for improvement.
+ NbActiv4 was formulated by addition of creatine, cholesterol and
+ estrogen to Neurobasal/B27 that synergistically produced an eightfold
+ increase in spontaneous spike activity. The increased activity with
+ NbActiv4 correlated with a twofold increase in immunoreactive synaptophysin
+ bright puncta and GluR1 total puncta. Characteristic of synaptic
+ scaling, immunoreactive GABAAbeta puncta also increased 1.5-fold
+ and NMDA-R1 puncta increased 1.8-fold. Neuron survival in NbActiv4
+ equaled that in Neurobasal/B27, but with slightly higher astroglia.
+ Resting respiratory demand was decreased and demand capacity was
+ increased in NbActiv4, indicating less stress and higher efficiency.
+ These results show that NbActiv4 is an improvement to Neurobasal/B27
+ for cultured networks with an increased density of synapses and transmitter
+ receptors which produces higher spontaneous spike rates in neuron
+ networks.},
+  Doi                      = {10.1016/j.jneumeth.2008.01.009},
+  Institution              = {Southern Illinois University School of Medicine, Springfield, IL
+ 62794-9626, USA. gbrewer@siumed.edu},
+  Keywords                 = {Cell Survival; Cells, Cultured; Culture Media; Electrophysiology;
+ Hippocampus, cytology; Humans; Image Processing, Computer-Assisted;
+ Immunohistochemistry; Kinetics; Microelectrodes; Nerve Net, physiology;
+ Neurons, physiology; Oxygen Consumption, physiology; Oxygen, analysis;
+ Synapses, physiology},
+  Pii                      = {S0165-0270(08)00039-3},
+  Pmid                     = {18308400},
+  Timestamp                = {09.02.26.19.31},
+  Url                      = {http://dx.doi.org/10.1016/j.jneumeth.2008.01.009}
+}
+, @@ -0,0 +1,482 @@
+% This file was created with JabRef devel - 1st edition family.
+% Encoding: UTF8
+
+
+@ARTICLE{Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS,
+  author = {Aziz, Joseph N. Y. and Abdelhalim, Karim and Shulyzki, Ruslana and
+	
+	 Genov, Roman and Bardakjian, Berj L. and Derchansky, Miron and Serletis,
+	
+	 Demitre and Carlen, Peter L.},
+  title = {256-Channel Neural Recording and Delta Compression Microsystem With
+	
+	 3D Electrodes},
+  journal = {IEEE JOURNAL OF SOLID-STATE CIRCUITS},
+  year = {2009},
+  volume = {44},
+  pages = {995-1005},
+  number = {3},
+  month = {MAR},
+  abstract = {A 3D microsystem for multi-site penetrating extracellular neural recording
+	
+	 from the brain is presented. A 16 x 16-channel neural recording interface
+	
+	 integrated prototype fabricated in 0.35 mu m CMOS occupies 3.5 mm
+	
+	 x 4.5 mm area. Each recording channel dissipates 15 mu W of power
+	
+	 with input-referred noise of 7 mu V-rms over 5 kHz bandwidth. A switched-capacitor
+	
+	 delta read-out data compression circuit trades recording accuracy
+	
+	 for the output data rate. An array of 1.5 mm platinum-coated microelectrodes
+	
+	 is bonded directly onto the die. Results of in vitro experimental
+	
+	 recordings from intact mouse hippocampus validate the circuit design
+	
+	 and the on-chip electrode bonding technology.},
+  address = {445 HOES LANE, PISCATAWAY, NJ 08855 USA},
+  affiliation = {Aziz, JNY (Reprint Author), Broadcom, Irvine, CA 92617 USA. {[}Aziz,
+	
+	 Joseph N. Y.; Abdelhalim, Karim; Shulyzki, Ruslana; Genov, Roman]
+	
+	 Univ Toronto, Dept Elect \& Comp Engn, Toronto, ON M5S 3G4, Canada.
+	
+	 {[}Bardakjian, Berj L.] Univ Toronto, Inst Biomat \& Biomed Engn,
+	
+	 Edward S Rogers Sr Dept Elect \& Comp Engn, Toronto, ON M5S 1A4,
+	
+	 Canada. {[}Derchansky, Miron; Serletis, Demitre; Carlen, Peter L.]
+	
+	 Univ Toronto, Toronto Western Res Inst, Toronto, ON M5S 1A4, Canada.
+	
+	 {[}Derchansky, Miron; Serletis, Demitre; Carlen, Peter L.] Univ Toronto,
+	
+	 Dept Physiol, Toronto, ON M5S 1A4, Canada.},
+  author-email = {roman@eecg.utoronto.ca},
+  cited-references = {ATLURI S, 2006, P IEEE INT S CIRC SY, P1131. AZIZ J, 2006, P IEEE
+	
+	 INT S CIRC SY. AZIZ J, 2007, IEEE INT SOL STAT CI, P160. AZIZ JNY,
+	
+	 2006, P IEEE INT S CIRC SY, P5075. AZIZ JNY, 2007, IEEE T BIOMED
+	
+	 CIRCUI, V1. AZIZ JNY, 2007, P IEEE INT S CIRC SY. CHAIMANONART N,
+	
+	 2005, P ANN INT IEEE EMBS, P5194. DELBRUCK T, 1994, P IEEE INT S
+	
+	 CIRC SY, V4, P339. ENZ CC, 1996, P IEEE, V84, P1584. EVERSMANN B,
+	
+	 2003, IEEE J SOLID-ST CIRC, V38, P2306, DOI 10.1109/JSSC.2003.819174.
+	
+	 HARRISON R, 2006, IEEE INT SOL STAT C, P2258. HARRISON RR, 2003,
+	
+	 IEEE J SOLID-ST CIRC, V38, P958, DOI 10.1009/JSSC.2003.811979. HARRISON
+	
+	 RR, 2007, IEEE CUST INTEGR CIR, P115. HEER F, 2006, IEEE J SOLID-ST
+	
+	 CIRC, V41, P1620, DOI 10.1109/JSSC.2006.873677. KIM S, 2006, P 2006
+	
+	 INT C IEEE EN, P2986. MALLIK U, 2005, IEEE ISSCC, P362. MOHSENI P,
+	
+	 2004, IEEE T BIO-MED ENG, V51, P832, DOI 10.1109/TBME.2004.824126.
+	
+	 MOTCHENBACHER CD, 1993, LOW NOISE ELECT SYST. OLSSON RH, 2005, IEEE
+	
+	 J SOLID-ST CIRC, V40, P2796. PATTERSON WR, 2004, IEEE T BIO-MED ENG,
+	
+	 V51, P1845, DOI 10.1109/TBME.2004.831521. RILEY G, 1987, SURFACE
+	
+	 MOUNT INT, P535. STEYAERT MSJ, 1987, IEEE J SOLID-ST CIRC, V22, P1163.
+	
+	 TSIVIDIS Y, 2003, OPERATION MODELING M. WATTANAPANITCH W, 2007, IEEE
+	
+	 T BIOMED CIRC S, V1, P136, DOI 10.1109/TBCAS.2007.907868. WISE KD,
+	
+	 2005, IEEE ENG MED BIOL, V24, P22.},
+  doc-delivery-number = {415FE},
+  doi = {10.1109/JSSC.2008.2010997},
+  file = {Draft:JabRef\\Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS_draft.pdf:PDF;Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS.pdf:JabRef\\Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS.pdf:PDF},
+  issn = {0018-9200},
+  journal-iso = {IEEE J. Solid-State Circuit},
+  keywords = {Multi-channel recording; microelectrodes; extracellular recording;
+	
+	 electrode array; implantable; brain; hippocampus; delta compression;
+	
+	 neural amplifier},
+  keywords-plus = {AMPLIFIER; STABILIZATION; CIRCUIT; ARRAY},
+  language = {English},
+  number-of-cited-references = {25},
+  publisher = {IEEE-INST ELECTRICAL ELECTRONICS ENGINEERS INC},
+  subject-category = {Engineering, Electrical \& Electronic},
+  times-cited = {2},
+  timestamp = {10.04.15.11.41},
+  type = {Article},
+  unique-id = {ISI:000263918900029}
+}
+
+@ARTICLE{BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering,
+  author = {B Balakrisnan , S Patil and E Smela},
+  title = {Patterning PDMS using a combination of wet and dry etching},
+  journal = {Journal of Micromechanics and Microengineering},
+  year = {2009},
+  volume = {19},
+  pages = {047002},
+  number = {4},
+  abstract = {PDMS films of 10 �m thickness can be patterned within 30 min by combining
+	
+	 dry etching to achieve substantially vertical sidewalls with wet
+	
+	 etching to achieve high etch rates and to protect the underlying
+	
+	 substrate from attack. Dry etching alone would have taken 5 h, and
+	
+	 wet etching alone would produce severe undercutting. In addition,
+	
+	 using either technique alone produces undesirable surface morphologies.
+	
+	 The mask used during etching is critical to a successful patterning
+	
+	 outcome. E-beam evaporated Al was found to work well, adhering strongly
+	
+	 to oxygen-plasma-treated PDMS and holding up well during both dry
+	
+	 and wet etching. To prevent wrinkling of the PDMS, a fast deposition
+	
+	 rate should be used.},
+  file = {BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering.pdf:JabRef\\BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering.pdf:PDF},
+  timestamp = {09.06.17.13.03},
+  url = {http://stacks.iop.org/0960-1317/19/i=4/a=047002}
+}
+
+@ARTICLE{Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA,
+  author = {S. A. Baccus},
+  title = {Synaptic facilitation by reflected action potentials: enhancement
+	
+	 of transmission when nerve impulses reverse direction at axon branch
+	
+	 points.},
+  journal = {Proc Natl Acad Sci U S A},
+  year = {1998},
+  volume = {95},
+  pages = {8345--8350},
+  number = {14},
+  month = {Jul},
+  abstract = {A rapid, reversible enhancement of synaptic transmission from a sensory
+	
+	 neuron is reported and explained by impulses that reverse direction,
+	
+	 or reflect, at axon branch points. In leech mechanosensory neurons,
+	
+	 where one can detect reflection because it is possible simultaneously
+	
+	 to study electrical activity in separate branches, action potentials
+	
+	 reflected from branch points within the central nervous system under
+	
+	 physiological conditions. Synapses adjacent to these branch points
+	
+	 were activated twice in rapid succession, first by an impulse arriving
+	
+	 from the periphery and then by its reflection. This fast double-firing
+	
+	 facilitated synaptic transmission, increasing it to more than twice
+	
+	 its normal level. Reflection occurred within a range of resting membrane
+	
+	 potentials, and electrical activity produced by mechanical stimulation
+	
+	 changed membrane potential so as to produce and cease reflection.
+	
+	 A compartmental model was used to investigate how branch-point morphology
+	
+	 and electrical activity contribute to produce reflection. The model
+	
+	 shows that mechanisms that hyperpolarize the membrane so as to impair
+	
+	 action potential propagation can increase the range of structures
+	
+	 that can produce reflection. This suggests that reflection is more
+	
+	 likely to occur in other structures where impulses fail, such as
+	
+	 in axons and dendrites in the mammalian brain. In leech sensory neurons,
+	
+	 reflection increased transmission from central synapses only in those
+	
+	 axon branches that innervate the edges of the receptive field in
+	
+	 the skin, thereby sharpening spatial contrast. Reflection thus allows
+	
+	 a neuron to amplify synaptic transmission from a selected group of
+	
+	 its branches in a way that can be regulated by electrical activity.},
+  file = {Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA.pdf:JabRef\\Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA.pdf:PDF},
+  institution = {Neuroscience Program, University of Miami, Miami, FL 33136, USA.
+	
+	 sbaccus@mednet.med.miami.edu},
+  keywords = {Action Potentials, physiology; Animals; Axons, physiology; Electrophysiology;
+	
+	 Ganglia, Invertebrate, physiology; Ganglia, Sensory, physiology;
+	
+	 Leeches; Neurons, physiology; Synapses, physiology; Synaptic Transmission,
+	
+	 physiology},
+  language = {eng},
+  medline-pst = {ppublish},
+  pmid = {9653189},
+  timestamp = {11.05.01.13.02}
+}
+
+@ARTICLE{Brewer1995Serum-freeB27/neurobasalmediumsupportsdifferentiatedgrowthofneuronsfromthestriatumsubstantianigraseptumcerebralcortexcerebellumanddentategyrus.JNeurosciRes,
+  author = {G. J. Brewer},
+  title = {Serum-free B27/neurobasal medium supports differentiated growth of
+	
+	 neurons from the striatum, substantia nigra, septum, cerebral cortex,
+	
+	 cerebellum, and dentate gyrus.},
+  journal = {J Neurosci Res},
+  year = {1995},
+  volume = {42},
+  pages = {674--683},
+  number = {5},
+  month = {Dec},
+  abstract = {Two fundamental questions about neuron cell culture were addressed.
+	
+	 Can one serum-free medium that was developed for optimum growth of
+	
+	 hippocampal neurons support the growth of neurons from other regions
+	
+	 of the brain? Is the region specific state of differentiation maintained
+	
+	 in culture? To answer these questions, we isolated neurons from six
+	
+	 other rat brain regions, placed them in culture in B27/Neurobasal
+	
+	 defined medium, and analyzed their morphology and growth dependence
+	
+	 on cell density after 4 days in culture. Neuronal identity was confirmed
+	
+	 by immunostaining with antibodies to neurofilament 200. Neurons from
+	
+	 each brain region maintained distinctive morphologies in culture
+	
+	 in the virtual absence of glia. Cells isolated from embryonic day
+	
+	 18 cerebral cortex by digestion with papain showed the same high
+	
+	 survival as hippocampal neurons, e.g., 70\% survival for cells plated
+	
+	 at 160/mm2. At this age and density, neurons from the septum showed
+	
+	 slightly lower survival, 45\%. Survival of dentate granule neurons
+	
+	 from postnatal day four brains was 30-40\%, significantly lower,
+	
+	 and relatively independent of plating density. This suggests an absence
+	
+	 of dependence on trophic factors or contact for dentate granule neurons.
+	
+	 Growth of cerebellar granule neurons isolated from postnatal day
+	
+	 7, 8, or 9 brains in B27/Neurobasal was compared to growth in BME/10\%
+	
+	 serum. Viability in serum-free medium at 4 days was much better than
+	
+	 that in serum, did not require KCl elevated to 25 mM, and occurred
+	
+	 without substantial growth of glia. Cerebellar granule neurons plated
+	
+	 at 1,280 cells/mm2 were maintained in culture for three weeks with
+	
+	 17\% of the original cell density surviving. Survival of cells isolated
+	
+	 from embryonic day 18 substantia nigra was 50\% at 160 cells/mm2
+	
+	 after 4 days, similar to that of striatum, but slightly less than
+	
+	 hippocampal neuron survival. The dopaminergic phenotype of the substantia
+	
+	 nigral neurons was maintained over 2 weeks in culture as judged by
+	
+	 immunoreactivity with antibodies to tyrosine hydroxylase. During
+	
+	 this time, immunoreactivity was found in the processes as they grew
+	
+	 out from the soma. Together, these studies suggest that B27/Neurobasal
+	
+	 will be a useful medium for maintaining the differentiated growth
+	
+	 of neurons from many brain regions. Potential applications of a common
+	
+	 growth medium for different neurons are discussed.},
+  doi = {10.1002/jnr.490420510},
+  institution = {Southern Illinois University School of Medicine, Springfield 62794-1220,
+	
+	 USA.},
+  keywords = {Animals; Brain, anatomy /&/ histology/cytology/enzymology; Cell Culture
+	
+	 Techniques; Cell Survival; Cells, Cultured; Cerebellum, cytology/embryology;
+	
+	 Cerebral Cortex, cytology/embryology; Corpus Striatum, cytology/embryology;
+	
+	 Culture Media, Serum-Free; Dentate Gyrus, cytology/embryology; Electrophysiology;
+	
+	 Hippocampus, cytology/embryology; Neurofilament Proteins, metabolism;
+	
+	 Neurons, cytology/enzymology; Rats; Rats, Sprague-Dawley; Septum
+	
+	 Pellucidum, embryology; Substantia Nigra, cytology/embryology; Tyrosine
+	
+	 3-Monooxygenase, metabolism},
+  pmid = {8600300},
+  timestamp = {2008.12.12},
+  url = {http://dx.doi.org/10.1002/jnr.490420510}
+}
+
+@ARTICLE{Brewer1997Isolationandcultureofadultrathippocampalneurons.JNeurosciMethods,
+  author = {G. J. Brewer},
+  title = {Isolation and culture of adult rat hippocampal neurons.},
+  journal = {J Neurosci Methods},
+  year = {1997},
+  volume = {71},
+  pages = {143--155},
+  number = {2},
+  month = {Feb},
+  abstract = {Inability to culture adult central neurons and the failure of injured
+	
+	 neurons to regenerate in the brain could be due to genetic controls
+	
+	 or environmental inhibitors. We tested the environmental inhibitor
+	
+	 hypothesis by attempting to regenerate adult rat neurons in B27/Neurobasal
+	
+	 culture medium, a medium optimized for survival of embryonic neurons.
+	
+	 To isolate neurons from their numerous connections, papain was the
+	
+	 best of six different proteases screened on slices of hippocampus
+	
+	 for survival of isolated cells after 4 days of culture. Use of a
+	
+	 density gradient enabled separation of oligodendroglia and some enrichment
+	
+	 of neurons and microglia from considerable debris which was inhibitory
+	
+	 to sprouting and viability. With these techniques, about 900000 viable
+	
+	 neurons were isolated from each hippocampus of any age rat from birth
+	
+	 to 24-36 months, near the median mortality. FGF2 was found to enhance
+	
+	 viability at least 3-fold to 40-80\%, independent of age, without
+	
+	 affecting the length of the processes. Neurons were cultured for
+	
+	 more than 3 weeks. These methods demonstrate that hippocampal neurons
+	
+	 can regenerate axons and dendrites if provided with adequate nutrition
+	
+	 and if inhibitors are removed. They also will enable aging studies.
+	
+	 Therefore, the concept of environmental growth restriction may be
+	
+	 more appropriate for neurons in the brain than the concept of a genetic
+	
+	 block that precludes regeneration of processes.},
+  institution = {Department of Medical Microbiology and Immunology, Southern Illinois
+	
+	 University School of Medicine, Springfield 62794-1220, USA. gbrewer@siumed.edu},
+  keywords = {Age Factors; Animals; Cell Adhesion, physiology; Cell Culture Techniques,
+	
+	 methods; Cell Separation, methods; Cell Survival, physiology; Cells,
+	
+	 Cultured; Cerebral Cortex, cytology; Dose-Response Relationship,
+	
+	 Drug; Fibroblast Growth Factor 2, physiology; Glutamic Acid, pharmacology;
+	
+	 Hippocampus, cytology; Male; Neurons, cytology/drug effects; Osmolar
+	
+	 Concentration; Oxygen, pharmacology; Papain; Rats; Rats, Inbred F344;
+	
+	 Rats, Sprague-Dawley},
+  pii = {S0165-0270(96)00136-7},
+  pmid = {9128149},
+  timestamp = {09.02.26.19.31}
+}
+
+@ARTICLE{Brewer2008NbActiv4mediumimprovementtoNeurobasal/B27increasesneuronsynapsedensitiesandnetworkspikeratesonmultielectrodearrays.JNeurosciMethods,
+  author = {Gregory J Brewer and Michael D Boehler and Torrie T Jones and Bruce
+	
+	 C Wheeler},
+  title = {NbActiv4 medium improvement to Neurobasal/B27 increases neuron synapse
+	
+	 densities and network spike rates on multielectrode arrays.},
+  journal = {J Neurosci Methods},
+  year = {2008},
+  volume = {170},
+  pages = {181--187},
+  number = {2},
+  month = {May},
+  abstract = {The most interesting property of neurons is their long-distance propagation
+	
+	 of signals as spiking action potentials. Since 1993, Neurobasal/B27
+	
+	 has been used as a serum-free medium optimized for hippocampal neuron
+	
+	 survival. Neurons on microelectrode arrays (MEA) were used as an
+	
+	 assay system to increase spontaneous spike rates in media of different
+	
+	 compositions. We find spike rates of 0.5 s(-1) (Hz) for rat embryonic
+	
+	 hippocampal neurons cultured in Neurobasal/B27, lower than cultures
+	
+	 in serum-based media and offering an opportunity for improvement.
+	
+	 NbActiv4 was formulated by addition of creatine, cholesterol and
+	
+	 estrogen to Neurobasal/B27 that synergistically produced an eightfold
+	
+	 increase in spontaneous spike activity. The increased activity with
+	
+	 NbActiv4 correlated with a twofold increase in immunoreactive synaptophysin
+	
+	 bright puncta and GluR1 total puncta. Characteristic of synaptic
+	
+	 scaling, immunoreactive GABAAbeta puncta also increased 1.5-fold
+	
+	 and NMDA-R1 puncta increased 1.8-fold. Neuron survival in NbActiv4
+	
+	 equaled that in Neurobasal/B27, but with slightly higher astroglia.
+	
+	 Resting respiratory demand was decreased and demand capacity was
+	
+	 increased in NbActiv4, indicating less stress and higher efficiency.
+	
+	 These results show that NbActiv4 is an improvement to Neurobasal/B27
+	
+	 for cultured networks with an increased density of synapses and transmitter
+	
+	 receptors which produces higher spontaneous spike rates in neuron
+	
+	 networks.},
+  doi = {10.1016/j.jneumeth.2008.01.009},
+  institution = {Southern Illinois University School of Medicine, Springfield, IL
+	
+	 62794-9626, USA. gbrewer@siumed.edu},
+  keywords = {Cell Survival; Cells, Cultured; Culture Media; Electrophysiology;
+	
+	 Hippocampus, cytology; Humans; Image Processing, Computer-Assisted;
+	
+	 Immunohistochemistry; Kinetics; Microelectrodes; Nerve Net, physiology;
+	
+	 Neurons, physiology; Oxygen Consumption, physiology; Oxygen, analysis;
+	
+	 Synapses, physiology},
+  pii = {S0165-0270(08)00039-3},
+  pmid = {18308400},
+  timestamp = {09.02.26.19.31},
+  url = {http://dx.doi.org/10.1016/j.jneumeth.2008.01.009}
+}
+, @@ -0,0 +1,301 @@
+% This file was created with JabRef 2.9.2.
+% Encoding: UTF8
+
+@ARTICLE{Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS,
+  author = {Aziz, Joseph N. Y. and Abdelhalim, Karim and Shulyzki, Ruslana and
+	Genov, Roman and Bardakjian, Berj L. and Derchansky, Miron and Serletis,
+	Demitre and Carlen, Peter L.},
+  title = {256-Channel Neural Recording and Delta Compression Microsystem With
+	3D Electrodes},
+  journal = {IEEE JOURNAL OF SOLID-STATE CIRCUITS},
+  year = {2009},
+  volume = {44},
+  pages = {995-1005},
+  number = {3},
+  month = {MAR},
+  abstract = {A 3D microsystem for multi-site penetrating extracellular neural recording
+	from the brain is presented. A 16 x 16-channel neural recording interface
+	integrated prototype fabricated in 0.35 mu m CMOS occupies 3.5 mm
+	x 4.5 mm area. Each recording channel dissipates 15 mu W of power
+	with input-referred noise of 7 mu V-rms over 5 kHz bandwidth. A switched-capacitor
+	delta read-out data compression circuit trades recording accuracy
+	for the output data rate. An array of 1.5 mm platinum-coated microelectrodes
+	is bonded directly onto the die. Results of in vitro experimental
+	recordings from intact mouse hippocampus validate the circuit design
+	and the on-chip electrode bonding technology.},
+  address = {445 HOES LANE, PISCATAWAY, NJ 08855 USA},
+  affiliation = {Aziz, JNY (Reprint Author), Broadcom, Irvine, CA 92617 USA. {[}Aziz,
+	Joseph N. Y.; Abdelhalim, Karim; Shulyzki, Ruslana; Genov, Roman]
+	Univ Toronto, Dept Elect \& Comp Engn, Toronto, ON M5S 3G4, Canada.
+	{[}Bardakjian, Berj L.] Univ Toronto, Inst Biomat \& Biomed Engn,
+	Edward S Rogers Sr Dept Elect \& Comp Engn, Toronto, ON M5S 1A4,
+	Canada. {[}Derchansky, Miron; Serletis, Demitre; Carlen, Peter L.]
+	Univ Toronto, Toronto Western Res Inst, Toronto, ON M5S 1A4, Canada.
+	{[}Derchansky, Miron; Serletis, Demitre; Carlen, Peter L.] Univ Toronto,
+	Dept Physiol, Toronto, ON M5S 1A4, Canada.},
+  author-email = {roman@eecg.utoronto.ca},
+  cited-references = {ATLURI S, 2006, P IEEE INT S CIRC SY, P1131. AZIZ J, 2006, P IEEE
+	INT S CIRC SY. AZIZ J, 2007, IEEE INT SOL STAT CI, P160. AZIZ JNY,
+	2006, P IEEE INT S CIRC SY, P5075. AZIZ JNY, 2007, IEEE T BIOMED
+	CIRCUI, V1. AZIZ JNY, 2007, P IEEE INT S CIRC SY. CHAIMANONART N,
+	2005, P ANN INT IEEE EMBS, P5194. DELBRUCK T, 1994, P IEEE INT S
+	CIRC SY, V4, P339. ENZ CC, 1996, P IEEE, V84, P1584. EVERSMANN B,
+	2003, IEEE J SOLID-ST CIRC, V38, P2306, DOI 10.1109/JSSC.2003.819174.
+	HARRISON R, 2006, IEEE INT SOL STAT C, P2258. HARRISON RR, 2003,
+	IEEE J SOLID-ST CIRC, V38, P958, DOI 10.1009/JSSC.2003.811979. HARRISON
+	RR, 2007, IEEE CUST INTEGR CIR, P115. HEER F, 2006, IEEE J SOLID-ST
+	CIRC, V41, P1620, DOI 10.1109/JSSC.2006.873677. KIM S, 2006, P 2006
+	INT C IEEE EN, P2986. MALLIK U, 2005, IEEE ISSCC, P362. MOHSENI P,
+	2004, IEEE T BIO-MED ENG, V51, P832, DOI 10.1109/TBME.2004.824126.
+	MOTCHENBACHER CD, 1993, LOW NOISE ELECT SYST. OLSSON RH, 2005, IEEE
+	J SOLID-ST CIRC, V40, P2796. PATTERSON WR, 2004, IEEE T BIO-MED ENG,
+	V51, P1845, DOI 10.1109/TBME.2004.831521. RILEY G, 1987, SURFACE
+	MOUNT INT, P535. STEYAERT MSJ, 1987, IEEE J SOLID-ST CIRC, V22, P1163.
+	TSIVIDIS Y, 2003, OPERATION MODELING M. WATTANAPANITCH W, 2007, IEEE
+	T BIOMED CIRC S, V1, P136, DOI 10.1109/TBCAS.2007.907868. WISE KD,
+	2005, IEEE ENG MED BIOL, V24, P22.},
+  doc-delivery-number = {415FE},
+  doi = {10.1109/JSSC.2008.2010997},
+  file = {Draft:JabRef\\Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS_draft.pdf:PDF;Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS.pdf:JabRef\\Aziz2009256-ChannelNeuralRecordingandDeltaCompressionMicrosystemWith3DElectrodesIEEEJOURNALOFSOLID-STATECIRCUITS.pdf:PDF},
+  issn = {0018-9200},
+  journal-iso = {IEEE J. Solid-State Circuit},
+  keywords = {Multi-channel recording; microelectrodes; extracellular recording;
+	electrode array; implantable; brain; hippocampus; delta compression;
+	neural amplifier},
+  keywords-plus = {AMPLIFIER; STABILIZATION; CIRCUIT; ARRAY},
+  language = {English},
+  number-of-cited-references = {25},
+  publisher = {IEEE-INST ELECTRICAL ELECTRONICS ENGINEERS INC},
+  subject-category = {Engineering, Electrical \& Electronic},
+  times-cited = {2},
+  timestamp = {10.04.15.11.41},
+  type = {Article},
+  unique-id = {ISI:000263918900029}
+}
+
+@ARTICLE{Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA,
+  author = {S. A. Baccus},
+  title = {Synaptic facilitation by reflected action potentials: enhancement
+	of transmission when nerve impulses reverse direction at axon branch
+	points.},
+  journal = {Proc Natl Acad Sci U S A},
+  year = {1998},
+  volume = {95},
+  pages = {8345--8350},
+  number = {14},
+  month = {Jul},
+  abstract = {A rapid, reversible enhancement of synaptic transmission from a sensory
+	neuron is reported and explained by impulses that reverse direction,
+	or reflect, at axon branch points. In leech mechanosensory neurons,
+	where one can detect reflection because it is possible simultaneously
+	to study electrical activity in separate branches, action potentials
+	reflected from branch points within the central nervous system under
+	physiological conditions. Synapses adjacent to these branch points
+	were activated twice in rapid succession, first by an impulse arriving
+	from the periphery and then by its reflection. This fast double-firing
+	facilitated synaptic transmission, increasing it to more than twice
+	its normal level. Reflection occurred within a range of resting membrane
+	potentials, and electrical activity produced by mechanical stimulation
+	changed membrane potential so as to produce and cease reflection.
+	A compartmental model was used to investigate how branch-point morphology
+	and electrical activity contribute to produce reflection. The model
+	shows that mechanisms that hyperpolarize the membrane so as to impair
+	action potential propagation can increase the range of structures
+	that can produce reflection. This suggests that reflection is more
+	likely to occur in other structures where impulses fail, such as
+	in axons and dendrites in the mammalian brain. In leech sensory neurons,
+	reflection increased transmission from central synapses only in those
+	axon branches that innervate the edges of the receptive field in
+	the skin, thereby sharpening spatial contrast. Reflection thus allows
+	a neuron to amplify synaptic transmission from a selected group of
+	its branches in a way that can be regulated by electrical activity.},
+  file = {Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA.pdf:JabRef\\Baccus1998Synapticfacilitationbyreflectedactionpotentials--enhancementoftransmissionwhennerveimpulsesreversedirectionataxonbranchpoints.ProcNatlAcadSciUSA.pdf:PDF},
+  institution = {Neuroscience Program, University of Miami, Miami, FL 33136, USA.
+	sbaccus@mednet.med.miami.edu},
+  keywords = {Action Potentials, physiology; Animals; Axons, physiology; Electrophysiology;
+	Ganglia, Invertebrate, physiology; Ganglia, Sensory, physiology;
+	Leeches; Neurons, physiology; Synapses, physiology; Synaptic Transmission,
+	physiology},
+  language = {eng},
+  medline-pst = {ppublish},
+  pmid = {9653189},
+  timestamp = {11.05.01.13.02}
+}
+
+@ARTICLE{BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering,
+  author = {B Balakrisnan , S Patil and E Smela},
+  title = {Patterning PDMS using a combination of wet and dry etching},
+  journal = {Journal of Micromechanics and Microengineering},
+  year = {2009},
+  volume = {19},
+  pages = {047002},
+  number = {4},
+  abstract = {PDMS films of 10 �m thickness can be patterned within 30 min by combining
+	dry etching to achieve substantially vertical sidewalls with wet
+	etching to achieve high etch rates and to protect the underlying
+	substrate from attack. Dry etching alone would have taken 5 h, and
+	wet etching alone would produce severe undercutting. In addition,
+	using either technique alone produces undesirable surface morphologies.
+	The mask used during etching is critical to a successful patterning
+	outcome. E-beam evaporated Al was found to work well, adhering strongly
+	to oxygen-plasma-treated PDMS and holding up well during both dry
+	and wet etching. To prevent wrinkling of the PDMS, a fast deposition
+	rate should be used.},
+  file = {BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering.pdf:JabRef\\BBalakrisnan2009PatterningPDMSusingacombinationofwetanddryetchingJournalofMicromechanicsandMicroengineering.pdf:PDF},
+  timestamp = {09.06.17.13.03},
+  url = {http://stacks.iop.org/0960-1317/19/i=4/a=047002}
+}
+
+@ARTICLE{Brewer1997Isolationandcultureofadultrathippocampalneurons.JNeurosciMethods,
+  author = {G. J. Brewer},
+  title = {Isolation and culture of adult rat hippocampal neurons.},
+  journal = {J Neurosci Methods},
+  year = {1997},
+  volume = {71},
+  pages = {143--155},
+  number = {2},
+  month = {Feb},
+  abstract = {Inability to culture adult central neurons and the failure of injured
+	neurons to regenerate in the brain could be due to genetic controls
+	or environmental inhibitors. We tested the environmental inhibitor
+	hypothesis by attempting to regenerate adult rat neurons in B27/Neurobasal
+	culture medium, a medium optimized for survival of embryonic neurons.
+	To isolate neurons from their numerous connections, papain was the
+	best of six different proteases screened on slices of hippocampus
+	for survival of isolated cells after 4 days of culture. Use of a
+	density gradient enabled separation of oligodendroglia and some enrichment
+	of neurons and microglia from considerable debris which was inhibitory
+	to sprouting and viability. With these techniques, about 900000 viable
+	neurons were isolated from each hippocampus of any age rat from birth
+	to 24-36 months, near the median mortality. FGF2 was found to enhance
+	viability at least 3-fold to 40-80\%, independent of age, without
+	affecting the length of the processes. Neurons were cultured for
+	more than 3 weeks. These methods demonstrate that hippocampal neurons
+	can regenerate axons and dendrites if provided with adequate nutrition
+	and if inhibitors are removed. They also will enable aging studies.
+	Therefore, the concept of environmental growth restriction may be
+	more appropriate for neurons in the brain than the concept of a genetic
+	block that precludes regeneration of processes.},
+  institution = {Department of Medical Microbiology and Immunology, Southern Illinois
+	University School of Medicine, Springfield 62794-1220, USA. gbrewer@siumed.edu},
+  keywords = {Age Factors; Animals; Cell Adhesion, physiology; Cell Culture Techniques,
+	methods; Cell Separation, methods; Cell Survival, physiology; Cells,
+	Cultured; Cerebral Cortex, cytology; Dose-Response Relationship,
+	Drug; Fibroblast Growth Factor 2, physiology; Glutamic Acid, pharmacology;
+	Hippocampus, cytology; Male; Neurons, cytology/drug effects; Osmolar
+	Concentration; Oxygen, pharmacology; Papain; Rats; Rats, Inbred F344;
+	Rats, Sprague-Dawley},
+  pii = {S0165-0270(96)00136-7},
+  pmid = {9128149},
+  timestamp = {09.02.26.19.31}
+}
+
+@ARTICLE{Brewer1995Serum-freeB27/neurobasalmediumsupportsdifferentiatedgrowthofneuronsfromthestriatumsubstantianigraseptumcerebralcortexcerebellumanddentategyrus.JNeurosciRes,
+  author = {G. J. Brewer},
+  title = {Serum-free B27/neurobasal medium supports differentiated growth of
+	neurons from the striatum, substantia nigra, septum, cerebral cortex,
+	cerebellum, and dentate gyrus.},
+  journal = {J Neurosci Res},
+  year = {1995},
+  volume = {42},
+  pages = {674--683},
+  number = {5},
+  month = {Dec},
+  abstract = {Two fundamental questions about neuron cell culture were addressed.
+	Can one serum-free medium that was developed for optimum growth of
+	hippocampal neurons support the growth of neurons from other regions
+	of the brain? Is the region specific state of differentiation maintained
+	in culture? To answer these questions, we isolated neurons from six
+	other rat brain regions, placed them in culture in B27/Neurobasal
+	defined medium, and analyzed their morphology and growth dependence
+	on cell density after 4 days in culture. Neuronal identity was confirmed
+	by immunostaining with antibodies to neurofilament 200. Neurons from
+	each brain region maintained distinctive morphologies in culture
+	in the virtual absence of glia. Cells isolated from embryonic day
+	18 cerebral cortex by digestion with papain showed the same high
+	survival as hippocampal neurons, e.g., 70\% survival for cells plated
+	at 160/mm2. At this age and density, neurons from the septum showed
+	slightly lower survival, 45\%. Survival of dentate granule neurons
+	from postnatal day four brains was 30-40\%, significantly lower,
+	and relatively independent of plating density. This suggests an absence
+	of dependence on trophic factors or contact for dentate granule neurons.
+	Growth of cerebellar granule neurons isolated from postnatal day
+	7, 8, or 9 brains in B27/Neurobasal was compared to growth in BME/10\%
+	serum. Viability in serum-free medium at 4 days was much better than
+	that in serum, did not require KCl elevated to 25 mM, and occurred
+	without substantial growth of glia. Cerebellar granule neurons plated
+	at 1,280 cells/mm2 were maintained in culture for three weeks with
+	17\% of the original cell density surviving. Survival of cells isolated
+	from embryonic day 18 substantia nigra was 50\% at 160 cells/mm2
+	after 4 days, similar to that of striatum, but slightly less than
+	hippocampal neuron survival. The dopaminergic phenotype of the substantia
+	nigral neurons was maintained over 2 weeks in culture as judged by
+	immunoreactivity with antibodies to tyrosine hydroxylase. During
+	this time, immunoreactivity was found in the processes as they grew
+	out from the soma. Together, these studies suggest that B27/Neurobasal
+	will be a useful medium for maintaining the differentiated growth
+	of neurons from many brain regions. Potential applications of a common
+	growth medium for different neurons are discussed.},
+  doi = {10.1002/jnr.490420510},
+  institution = {Southern Illinois University School of Medicine, Springfield 62794-1220,
+	USA.},
+  keywords = {Animals; Brain, anatomy /&/ histology/cytology/enzymology; Cell Culture
+	Techniques; Cell Survival; Cells, Cultured; Cerebellum, cytology/embryology;
+	Cerebral Cortex, cytology/embryology; Corpus Striatum, cytology/embryology;
+	Culture Media, Serum-Free; Dentate Gyrus, cytology/embryology; Electrophysiology;
+	Hippocampus, cytology/embryology; Neurofilament Proteins, metabolism;
+	Neurons, cytology/enzymology; Rats; Rats, Sprague-Dawley; Septum
+	Pellucidum, embryology; Substantia Nigra, cytology/embryology; Tyrosine
+	3-Monooxygenase, metabolism},
+  pmid = {8600300},
+  timestamp = {2008.12.12},
+  url = {http://dx.doi.org/10.1002/jnr.490420510}
+}
+
+@ARTICLE{Brewer2008NbActiv4mediumimprovementtoNeurobasal/B27increasesneuronsynapsedensitiesandnetworkspikeratesonmultielectrodearrays.JNeurosciMethods,
+  author = {Gregory J Brewer and Michael D Boehler and Torrie T Jones and Bruce
+	C Wheeler},
+  title = {NbActiv4 medium improvement to Neurobasal/B27 increases neuron synapse
+	densities and network spike rates on multielectrode arrays.},
+  journal = {J Neurosci Methods},
+  year = {2008},
+  volume = {170},
+  pages = {181--187},
+  number = {2},
+  month = {May},
+  abstract = {The most interesting property of neurons is their long-distance propagation
+	of signals as spiking action potentials. Since 1993, Neurobasal/B27
+	has been used as a serum-free medium optimized for hippocampal neuron
+	survival. Neurons on microelectrode arrays (MEA) were used as an
+	assay system to increase spontaneous spike rates in media of different
+	compositions. We find spike rates of 0.5 s(-1) (Hz) for rat embryonic
+	hippocampal neurons cultured in Neurobasal/B27, lower than cultures
+	in serum-based media and offering an opportunity for improvement.
+	NbActiv4 was formulated by addition of creatine, cholesterol and
+	estrogen to Neurobasal/B27 that synergistically produced an eightfold
+	increase in spontaneous spike activity. The increased activity with
+	NbActiv4 correlated with a twofold increase in immunoreactive synaptophysin
+	bright puncta and GluR1 total puncta. Characteristic of synaptic
+	scaling, immunoreactive GABAAbeta puncta also increased 1.5-fold
+	and NMDA-R1 puncta increased 1.8-fold. Neuron survival in NbActiv4
+	equaled that in Neurobasal/B27, but with slightly higher astroglia.
+	Resting respiratory demand was decreased and demand capacity was
+	increased in NbActiv4, indicating less stress and higher efficiency.
+	These results show that NbActiv4 is an improvement to Neurobasal/B27
+	for cultured networks with an increased density of synapses and transmitter
+	receptors which produces higher spontaneous spike rates in neuron
+	networks.},
+  doi = {10.1016/j.jneumeth.2008.01.009},
+  institution = {Southern Illinois University School of Medicine, Springfield, IL
+	62794-9626, USA. gbrewer@siumed.edu},
+  keywords = {Cell Survival; Cells, Cultured; Culture Media; Electrophysiology;
+	Hippocampus, cytology; Humans; Image Processing, Computer-Assisted;
+	Immunohistochemistry; Kinetics; Microelectrodes; Nerve Net, physiology;
+	Neurons, physiology; Oxygen Consumption, physiology; Oxygen, analysis;
+	Synapses, physiology},
+  pii = {S0165-0270(08)00039-3},
+  pmid = {18308400},
+  timestamp = {09.02.26.19.31},
+  url = {http://dx.doi.org/10.1016/j.jneumeth.2008.01.009}
+}
+, ]"	"Hi All,
I just upgraded to 2.10 and I found some bugs immediately.
1. in the right-click-menu there is no `move-to-group` but 2 `remove
from group` instead.
2. I like the new add/remove/move panel, but the scrolling is not
working, which is a big problem. Because I have lots of groups which
cannot even fit into the full screen height after expansion.
3. no way to expand or collapse all nodes

I tried the dev version, all problems still exist. Here is my fixation.

Cheers,

W.L.
"	"try to fix some obvious bugs about `groups`"
"10"	"vegeziel"	"[src/main/java/net/sf/jabref/imports/MedlinePlainImporter.java, src/main/java/net/sf/jabref/imports/RisImporter.java, src/main/resources/plugins/net.sf.jabref.core/plugin.xml, ]"	"[@@ -0,0 +1,279 @@
+/*  Copyright (C) 2003-2011 JabRef contributors.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+    
+*/
+
+package net.sf.jabref.imports;
+
+import java.util.regex.Pattern;
+import java.io.InputStream;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+
+import net.sf.jabref.BibtexEntry;
+import net.sf.jabref.Globals;
+import net.sf.jabref.AuthorList;
+import net.sf.jabref.BibtexFields;
+import net.sf.jabref.OutputPrinter;
+
+/**
+ * Importer for the MEDLINE Plain format.
+ * 
+ * check here for details on the format
+ * http://www.nlm.nih.gov/bsd/mms/medlineelements.html
+ * 
+ * @author vegeziel
+ */
+public class MedlinePlainImporter extends ImportFormat {
+
+    /**
+     * Return the name of this import format.
+     */
+    public String getFormatName() {
+        return \"MedlinePlain\";
+    }
+
+    /*
+     *  (non-Javadoc)
+     * @see net.sf.jabref.imports.ImportFormat#getCLIId()
+     */
+    public String getCLIId() {
+        return \"medlineplain\";
+    }
+
+    /**
+     * Check whether the source is in the correct format for this importer.
+     */
+    public boolean isRecognizedFormat(InputStream stream) throws IOException {
+
+    	// Our strategy is to look for the \"PMID  - *\", \"PMC.*-.*\", or \"PMCR.*-.*\" line 
+    	// (i.e., PubMed Unique Identifier, PubMed Central Identifier, PubMed Central Release)
+        BufferedReader in = new BufferedReader(ImportFormatReader.getReaderDefaultEncoding(stream));
+        Pattern pat1 = Pattern.compile(\"PMID.*-.*\"),
+                pat2 = Pattern.compile(\"PMC.*-.*\"),
+                pat3 = Pattern.compile(\"PMCR.*-.*\");
+
+        String str;
+        while ((str = in.readLine()) != null){
+            if (pat1.matcher(str).find() || pat2.matcher(str).find() || pat3.matcher(str).find())
+                return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Parse the entries in the source, and return a List of BibtexEntry
+     * objects.
+     */
+    public List<BibtexEntry> importEntries(InputStream stream, OutputPrinter status) throws IOException {
+        ArrayList<BibtexEntry> bibitems = new ArrayList<BibtexEntry>();
+        StringBuffer sb = new StringBuffer();
+        BufferedReader in = new BufferedReader(ImportFormatReader.getReaderDefaultEncoding(stream));
+        String str;
+        while ((str = in.readLine()) != null){
+            sb.append(str);
+            sb.append(\"\n\");
+        }
+        String[] entries = sb.toString().replaceAll(\"\u2013\", \"-\").replaceAll(\"\u2014\", \"--\").replaceAll(\"\u2015\", \"--\").split(\"\\n\\n\");
+
+        for (int i = 0; i < entries.length; i++){
+
+            if (entries[i].trim().length() == 0)
+                continue;
+
+            String type = \"\", author = \"\", editor = \"\", comment = \"\";
+            HashMap<String, String> hm = new HashMap<String, String>();
+
+
+            String[] fields = entries[i].split(\"\n\");
+
+            for (int j = 0; j < fields.length; j++){
+            	if(fields[j].equals(\"\"))
+            		continue;
+            	
+                StringBuffer current = new StringBuffer(fields[j]);
+                boolean done = false;
+                
+                while (!done && (j < fields.length-1)) {
+                    if(fields[j+1].length() <=4 )
+                    	System.out.println(\"aaa\");
+                	if (fields[j+1].charAt(4) != '-') {
+                        if ((current.length() > 0)
+                                && !Character.isWhitespace(current.charAt(current.length()-1)))
+                            current.append(' ');
+                        current.append(fields[j+1].trim());
+                        j++;
+                    } else
+                        done = true;
+                }
+                String entry = current.toString();
+                
+                String lab = entry.substring(0, entry.indexOf('-')).trim();
+                String val = entry.substring(entry.indexOf('-')+1).trim();
+                if (lab.equals(\"PT\")){
+                	val = val.toLowerCase();
+                    if (val.equals(\"BOOK\")) type = \"book\";
+                    else if (val.equals(\"journal article\") 
+                    			|| val.equals(\"classical article\")
+                    			|| val.equals(\"corrected and republished article\")
+                    			|| val.equals(\"historical article\")
+                    			|| val.equals(\"introductory journal article\")
+                    			|| val.equals(\"newspaper article\")) type = \"article\";
+                    else if (val.equals(\"clinical conference\")
+                    		|| val.equals(\"consensus development conference\")
+                    		|| val.equals(\"consensus development conference, NIH\")) type = \"conference\";
+                    else if (val.equals(\"technical report\")) type = \"techreport\";
+                    else if (val.equals(\"editorial\")) type = \"inproceedings\";//\"incollection\";\"inbook\";
+                    else if (val.equals(\"overall\")) type = \"proceedings\";
+                    else if(type.equals(\"\")) type = \"other\";
+                    
+                }else if (lab.equals(\"TI\")) {
+                    String oldVal = hm.get(\"title\");
+                    if (oldVal == null)
+                        hm.put(\"title\", val);
+                    else {
+                        if (oldVal.endsWith(\":\") || oldVal.endsWith(\".\") || oldVal.endsWith(\"?\"))
+                            hm.put(\"title\", oldVal+\" \"+val);
+                        else
+                            hm.put(\"title\", oldVal+\": \"+val);
+                    }
+                }
+                    // =
+                    // val;
+                else if (lab.equals(\"BTI\") || lab.equals(\"CTI\")) {
+                    hm.put(\"booktitle\", val);
+                }
+                else if (lab.equals(\"FAU\")) {
+                    if (author.equals(\"\")) // don't add \" and \" for the first author
+                        author = val;
+                    else author += \" and \" + val;
+                }
+                else if (lab.equals(\"FED\")){
+                    if (editor.equals(\"\")) // don't add \" and \" for the first editor
+                        editor = val;
+                    else editor += \" and \" + val;
+                }
+                else if (lab.equals(\"JT\")) {
+                    if (type.equals(\"inproceedings\"))
+                        hm.put(\"booktitle\", val);
+                    else
+                        hm.put(\"journal\", val);
+                }
+
+                else if (lab.equals(\"PG\")) 
+                	hm.put(\"pages\", val);
+                
+//                else if (lab.equals(\"STAT\")) {
+//                    if (val.equals(\"MEDLINE\"))
+//                        hm.put(\"publisher\", \"PubMed\");
+//                    else
+//                        hm.put(\"publisher\", val);
+//                }
+                else if (lab.equals(\"PL\"))
+                    hm.put(\"address\", val);
+                else if (lab.equals(\"IS\"))
+                    hm.put(\"issn\", val);
+                else if (lab.equals(\"VI\")) 
+                	hm.put(\"volume\", val);
+//                else if (lab.equals(\"\")) 
+//                	hm.put(\"number\", val);
+                else if (lab.equals(\"AB\")) {
+                    String oldAb = hm.get(\"abstract\");
+                    if (oldAb == null)
+                        hm.put(\"abstract\", val);
+                    else
+                        hm.put(\"abstract\", oldAb+\"\n\"+val);
+                }
+                else if ((lab.equals(\"DP\"))) {
+                    String[] parts = val.split(\" \");
+                    hm.put(\"year\", parts[0]);
+                    if ((parts.length > 1) && (parts[1].length() > 0)) {
+                    	hm.put(\"month\", parts[1]);
+                    }
+                }
+
+                else if (lab.equals(\"MH\") || lab.equals(\"OT\")){
+                    if (!hm.containsKey(\"keywords\")) hm.put(\"keywords\", val);
+                    else{
+                        String kw = hm.get(\"keywords\");
+                        hm.put(\"keywords\", kw + \", \" + val);
+                    }
+                }
+                else if (lab.equals(\"CON\") || lab.equals(\"CIN\") || lab.equals(\"EIN\")
+                			|| lab.equals(\"EFR\") || lab.equals(\"CRI\") || lab.equals(\"CRF\")
+                			|| lab.equals(\"PRIN\") || lab.equals(\"PROF\") || lab.equals(\"RPI\")
+                			|| lab.equals(\"RPF\") || lab.equals(\"RIN\") || lab.equals(\"ROF\")
+                			|| lab.equals(\"UIN\") || lab.equals(\"UOF\") || lab.equals(\"SPIN\")
+                			|| lab.equals(\"ORI\")) {
+                    if (comment.length() > 0)
+                        comment = comment+\"\n\";
+                    comment = comment+val;
+                }
+//                // Added ID import 2005.12.01, Morten Alver:
+//                else if (lab.equals(\"ID\"))
+//                    hm.put(\"refid\", val);
+//                    // Added doi import (sciencedirect.com) 2011.01.10, Alexander Hug <alexander@alexanderhug.info>
+                else if (lab.equals(\"AID\")){
+                    String doi = val;
+                    if (doi.startsWith(\"doi:\")){
+                        doi = doi.replaceAll(\"(?i)doi:\", \"\").trim();
+                        hm.put(\"doi\", doi);
+                    }
+                }
+            }
+            // fix authors
+            if (author.length() > 0) {
+                author = AuthorList.fixAuthor_lastNameFirst(author);
+                hm.put(\"author\", author);
+            }
+            if (editor.length() > 0) {
+                editor = AuthorList.fixAuthor_lastNameFirst(editor);
+                hm.put(\"editor\", editor);
+            }
+            if (comment.length() > 0) {
+                hm.put(\"comment\", comment);
+            }
+            
+            BibtexEntry b = new BibtexEntry(BibtexFields.DEFAULT_BIBTEXENTRY_ID, Globals
+                    .getEntryType(type)); // id assumes an existing database so don't
+
+            // Remove empty fields:
+            ArrayList<Object> toRemove = new ArrayList<Object>();
+            for (Iterator<String> it = hm.keySet().iterator(); it.hasNext();) {
+                Object key = it.next();
+                String content = hm.get(key);
+                if ((content == null) || (content.trim().length() == 0))
+                    toRemove.add(key);
+            }
+            for (Iterator<Object> iterator = toRemove.iterator(); iterator.hasNext();) {
+                hm.remove(iterator.next());
+
+            }
+
+            // create one here
+            b.setField(hm);
+            bibitems.add(b);
+
+        }
+
+        return bibitems;
+
+    }
+}
, @@ -60,14 +60,12 @@ public boolean isRecognizedFormat(InputStream stream) throws IOException {
 
         // Our strategy is to look for the \"AU  - *\" line.
         BufferedReader in = new BufferedReader(ImportFormatReader.getReaderDefaultEncoding(stream));
-        Pattern pat1 = Pattern.compile(\"AU  - .*\"),
-                pat2 = Pattern.compile(\"A1  - .*\"),
-                pat3 = Pattern.compile(\"A2  - .*\");
+        Pattern pat1 = Pattern.compile(\"TY  - .*\");
 
 
         String str;
         while ((str = in.readLine()) != null){
-            if (pat1.matcher(str).find() || pat2.matcher(str).find() || pat3.matcher(str).find())
+            if (pat1.matcher(str).find())
                 return true;
         }
 , @@ -32,6 +32,15 @@
 		<parameter id=\"description\"
 			value=\"Import format for Medline references.\" />
 	</extension>
+	
+	<extension id=\"MedlinePlainImporter\" plugin-id=\"net.sf.jabref.core\"
+		point-id=\"ImportFormat\">
+		<parameter id=\"importFormat\"
+			value=\"net.sf.jabref.imports.MedlinePlainImporter\" />
+		<parameter id=\"name\" value=\"Medline Plain Importer\" />
+		<parameter id=\"description\"
+			value=\"Import format for Medline references (not XML).\" />
+	</extension>
 
 	<!-- To extend JabRef with an Entry Fetcher use the following extension point -->
 	<extension-point id=\"EntryFetcher\">, ]"	"Found bug: PubMed/Medline PLAIN format recognized as RIS format.
Provided solution:
    - Modified RIS ImportFilter. Now RIS format is identified by looking for the \"TY\" tag (it is a mandatory tag in RIS format and it is not conflictual with other filters)
    - Added new ImportFilter \"MedlinePlain\". This import filter parses Medline files in plain format (not XML). The import filter has been produced referring to the official Medline documentation (http://www.nlm.nih.gov/bsd/mms/medlineelements.html)
    - Updated the net.sf.jabref.core plugin.xml file in order to include the newly added MedlinePlain import filter
"	"BugFix for bug \"#880 PubMed Import broken\""
"11"	"Ingvar Jackal"	"[CHANGELOG, ]"	"[@@ -10,6 +10,7 @@
     - Support FindFullText with ACS DOIs (pull request #9)
     - Fixes groups and adds optional 2.9.2 save ordering (pull request #10)
     - Fixes bug 880 \"PubMed Import broken\" (pull request #11 by vegeziel)
+    - Fixes bug #959 \"StringIndexOutOfBoundsException with invalid Preview text\" (pull request #12 by IngvarJackal)
 2.10
     - Made IEEEXploreFetcher author parsing work again.
     - Added a few more characters in the HTML/Unicode to LaTeX conversion., ]"	"Fixed #959 \"StringIndexOutOfBoundsException with invalid Preview text\". java.lang.StringIndexOutOfBoundsException handled: message dialogue shows with last five words before illegal backslash expression and trace is written in stderr.
"	"BugFix for #959 \"StringIndexOutOfBoundsException with invalid Preview text\""
"12"	"Ingvar Jackal"	"[src/main/java/net/sf/jabref/JabRef.java, src/main/java/net/sf/jabref/journals/ManageJournalsPanel.java, ]"	"[@@ -171,7 +171,7 @@ protected JabRef(String[] args) {
 				Globals.journalAbbrev.readJournalList(new File(
 						personalJournalList));
 			} catch (FileNotFoundException e) {
-				JOptionPane.showMessageDialog(null, Globals.lang(\"Journal_file_not_found\" + \": \" + e.getMessage()), Globals.lang(\"Error_opening_file\"), JOptionPane.ERROR_MESSAGE);
+				JOptionPane.showMessageDialog(null, Globals.lang(\"Journal file not found\") + \": \" + e.getMessage(), Globals.lang(\"Error opening file\"), JOptionPane.ERROR_MESSAGE);
 				Globals.prefs.put(\"personalJournalList\", \"\");
 			}
 		}, @@ -206,7 +206,7 @@ public void actionPerformed(ActionEvent e) {
                 		storeSettings();
                 		dialog.dispose();
                 	} catch (FileNotFoundException ex) {
-                		JOptionPane.showMessageDialog(null, Globals.lang(\"Error_opening_file\" + \": \" + ex.getMessage()), Globals.lang(\"Error_opening_file\"), JOptionPane.ERROR_MESSAGE); 
+                		JOptionPane.showMessageDialog(null, Globals.lang(\"Error opening file\") + \": \" + ex.getMessage(), Globals.lang(\"Error opening file\"), JOptionPane.ERROR_MESSAGE);
                 	}
                 }
             }, ]"	"Fixed bug #960 FileNotFoundException in Journal abbreviations window. I added error dialogue and added the check while initializing in order to to fix missed file (it sets personalJournalList to \"\" if so).
"	"BugFix for \"#960 FileNotFoundException in Journal abbreviations window\""
"13"	"Thorsten Dahlheimer"	"[CHANGELOG, src/main/java/net/sf/jabref/BibtexFields.java, src/main/java/net/sf/jabref/journals/AbbreviateAction.java, src/main/java/net/sf/jabref/journals/UnabbreviateAction.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+    - Make (un)abbreviating journal titles also work on the journaltitle field
     - Change default behaviour to be more non-invasive: timestamps and owners are NOT set by default per entry.
     - \"Open Folder\" works again
     - newline separator can now be configured globally, @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 Raik Nagel and JabRef contributors
+/*  Copyright (C) 2003-2014 Raik Nagel and JabRef contributors
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -96,6 +96,10 @@ private BibtexFields()
     dummy = new BibtexSingleField( \"journal\", true, GUIGlobals.SMALL_W ) ;
     dummy.setExtras(\"journalNames\");
     add(dummy) ;
+    dummy = new BibtexSingleField( \"journaltitle\", true, GUIGlobals.SMALL_W ) ;
+    dummy.setExtras(\"journalNames\");
+    add(dummy) ;
+
     add( new BibtexSingleField( \"key\", true ) ) ;
     add( new BibtexSingleField( \"month\", true, GUIGlobals.SMALL_W ) ) ;
     add( new BibtexSingleField( \"note\", true, GUIGlobals.MEDIUM_W  ) ) ;, @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 JabRef contributors.
+/*  Copyright (C) 2003-2014 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -56,6 +56,8 @@ public void run() {
         for (BibtexEntry entry : entries) {
             if (Globals.journalAbbrev.abbreviate(panel.database(), entry, \"journal\", ce, iso))
                 count++;
+            if (Globals.journalAbbrev.abbreviate(panel.database(), entry, \"journaltitle\", ce, iso))
+                count++;
         }
         if (count > 0) {
             ce.end();, @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 JabRef contributors.
+/*  Copyright (C) 2003-2014 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -54,6 +54,8 @@ public void run() {
         for (BibtexEntry entry : entries) {
             if (Globals.journalAbbrev.unabbreviate(panel.database(), entry, \"journal\", ce))
                 count++;
+            if (Globals.journalAbbrev.unabbreviate(panel.database(), entry, \"journaltitle\", ce))
+                count++;
         }
         if (count > 0) {
             ce.end();, @@ -53,6 +53,7 @@ <h2>Contributions from:</h2>
         Fedor Bezrukov,
         Fabian Bieker,
         Aaron Chen,
+        Thorsten Dahlheimer,
         Fabrice Dessaint,
         Nathan Dunn,
         E. Hakan Duran,, ]"	"I've (i) added the toggle button to the \"journaltitle\" field editor
and (ii) made the abbreviate/unabbreviate actions change both the \"journal\" and \"journaltitle\" fields.
The latter might be a bit simple-minded --  should the field to consider depend on whether Biblatex mode is actually turned on?
"	"Make (un)abbreviating journal titles also work on the journaltitle field"
"14"	"Kempf"	"[CHANGELOG, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+    - Fixed bug 960 \"FileNotFoundException in Journal abbreviations window\" (by edukempf)
     - Change default behaviour to be more non-invasive: timestamps and owners are NOT set by default per entry.
     - \"Open Folder\" works again
     - newline separator can now be configured globally, @@ -88,7 +88,8 @@ <h2>Contributions from:</h2>
         David Weitzman,
         Seb Wills,
         John Zedlewski,
-        Waluyo Adi Siswanto</p>
+        Waluyo Adi Siswanto,
+        Eduardo Kempf</p>
 
         <h2>Thanks to:</h2>
 , ]"	"Hi I am Eduardo, I'm a student of UTFPR - Brazil, I was proposed in one of the subjects I am studying make some contributions to a free software project, so I was passed on this project. This is my first contribution, so follows the correction of a bug I found in the following link: http://sourceforge.net/p/jabref/bugs/960/. 

To fix the bug made ​​some changes to the system to validate the path provided by the user, and if the file does not exist it is created, checks were made for both Windows and for Linux. 

I am sending my pull-request. 

ps :. sorry my english
"	"fixed the bug 960"
"15"	"eduardogreco"	"[CHANGELOG, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Feature 850: Keyboard shortcut for 'Cleanup entries' (by eduardogreco)
     - Change default behaviour to be more non-invasive: timestamps and owners are NOT set by default per entry.
     - \"Open Folder\" works again
     - newline separator can now be configured globally, @@ -88,7 +88,8 @@ <h2>Contributions from:</h2>
         David Weitzman,
         Seb Wills,
         John Zedlewski,
-        Waluyo Adi Siswanto</p>
+        Waluyo Adi Siswanto,
+		Eduardo Roberto Greco</p>
 
         <h2>Thanks to:</h2>
 , ]"	"I solved the task of link:
https://sourceforge.net/p/jabref/feature-requests/850/

I am a student at the Federal University of Paraná - Brazil and I'm contributing to the JabRef because I think very important  open source software.
"	"Solved the task #850 Keyboard shortcut for 'Cleanup entries'"
"16"	"Thorsten Dahlheimer"	"[CHANGELOG, src/main/java/net/sf/jabref/EntryEditor.java, src/main/java/net/sf/jabref/JabRefFrame.java, src/main/java/net/sf/jabref/JabRefPreferences.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Feature 850: Keyboard shortcut for 'Cleanup entries' (by eduardogreco)
     - Change default behaviour to be more non-invasive: timestamps and owners are NOT set by default per entry.
     - \"Open Folder\" works again
     - newline separator can now be configured globally
@@ -14,6 +15,7 @@
     - Fixes bug #960 \"FileNotFoundException in Journal abbreviations window\" (pull request #13 by IngvarJackal)
     - Make (un)abbreviating journal titles also work on the journaltitle field
     - Fix edits getting lost in Biblatex mode
+    - Fix error when setting a previously unset field via the source panel of the entry editor
 2.10
     - Made IEEEXploreFetcher author parsing work again.
     - Added a few more characters in the HTML/Unicode to LaTeX conversion., @@ -840,15 +840,14 @@ public boolean storeSource(boolean showError) {
 
             // Then set all fields that have been set by the user.
             for (String field : nu.getAllFields()){
-                if (!entry.getField(field).equals(nu.getField(field))) {
-                    String toSet = nu.getField(field);
-
+                String oldValue = entry.getField(field);
+                String newValue = nu.getField(field);
+                if (oldValue == null || !oldValue.equals(newValue)) {
                     // Test if the field is legally set.
-                    (new LatexFieldFormatter()).format(toSet, field);
+                    (new LatexFieldFormatter()).format(newValue, field);
 
-                    compound.addEdit(new UndoableFieldChange(entry, field, entry
-                        .getField(field), toSet));
-                    entry.setField(field, toSet);
+                    compound.addEdit(new UndoableFieldChange(entry, field, oldValue, newValue));
+                    entry.setField(field, newValue);
                     anyChanged = true;
                 }
             }, @@ -290,6 +290,7 @@ void addAction(Action a) {
       writeXmpAction = new GeneralAction(\"writeXMP\", \"Write XMP-metadata to PDFs\",
                                         Globals.lang(\"Will write XMP-metadata to the PDFs linked from selected entries.\"),
                                         prefs.getKey(\"Write XMP\")),
+                                        
       openFolder = new GeneralAction(\"openFolder\", \"Open folder\",
                                         Globals.lang(\"Open folder\"),
                                         prefs.getKey(\"Open folder\")),
@@ -355,7 +356,8 @@ void addAction(Action a) {
 
     Cleanup = new GeneralAction(\"Cleanup\", \"Cleanup entries\", 
 					Globals.lang(\"Cleanup entries\"), 
-					GUIGlobals.getIconUrl(\"cleanupentries\") ),
+					prefs.getKey(\"Cleanup\"),
+					(\"cleanupentries\")),
           
     mergeEntries = new GeneralAction(\"mergeEntries\", \"Merge entries\", 
 					Globals.lang(\"Merge entries\"),
@@ -1121,16 +1123,15 @@ public GeneralAction(String command, String text, String description, KeyStroke
           putValue(ACCELERATOR_KEY, key);
       }
 
-  /*    public GeneralAction(String command, String text, String description,
-                           URL imageUrl, KeyStroke key) {
+      public GeneralAction(String command, String text, String description, KeyStroke key, String imageUrl) {
       this.command = command;
-        ImageIcon icon = GUIGlobals.getImage(command);
+        ImageIcon icon = GUIGlobals.getImage(imageUrl);
         if (icon != null)
             putValue(SMALL_ICON, icon);
       putValue(NAME, text);
       putValue(SHORT_DESCRIPTION, Globals.lang(description));
         putValue(ACCELERATOR_KEY, key);
-    }*/
+    }
 
     public void actionPerformed(ActionEvent e) {
       if (tabbedPane.getTabCount() > 0) {, @@ -1145,6 +1145,7 @@ private void defineDefaultKeyBindings() {
         defKeyBinds.put(\"Search ACM Portal\", \"ctrl shift F8\");
         defKeyBinds.put(\"Fetch ArXiv.org\", \"shift F8\");
         defKeyBinds.put(\"Search JSTOR\", \"shift F9\");
+        defKeyBinds.put(\"Cleanup\", \"ctrl shift F7\");
         defKeyBinds.put(\"Write XMP\", \"ctrl F7\");
         defKeyBinds.put(\"New file link\", \"ctrl N\");
         defKeyBinds.put(\"Fetch SPIRES\", \"ctrl F8\");, @@ -89,7 +89,8 @@ <h2>Contributions from:</h2>
         David Weitzman,
         Seb Wills,
         John Zedlewski,
-        Waluyo Adi Siswanto</p>
+        Waluyo Adi Siswanto,
+		Eduardo Roberto Greco</p>
 
         <h2>Thanks to:</h2>
 , ]"	"This fixes a bug where edits made in a field on a
CompressedEntryEditorTab wouldn't get stored when the field editor lost
focus.
The bug was caused by EntryEditorTabFocusListener accessing the unused inherited parent field
of CompressedEntryEditorTab instances instead of the latter class's own (private) parent field.
Instead of doing just a quick fix, I decided to eliminate the excessive code and data duplication
in the two classes altogether and consolidate them into one class (with an additional flag to the constructor),
since I don't think an extra class is warranted here (and easily and sensibly implementable by derivation).
"	"Fix edits getting lost in Biblatex mode"
"17"	"Thorsten Dahlheimer"	"[CHANGELOG, src/main/java/net/sf/jabref/EntryEditor.java, ]"	"[@@ -1,5 +1,4 @@
 [master]
-    - Make (un)abbreviating journal titles also work on the journaltitle field
     - Change default behaviour to be more non-invasive: timestamps and owners are NOT set by default per entry.
     - \"Open Folder\" works again
     - newline separator can now be configured globally
@@ -13,6 +12,8 @@
     - Fixes bug 880 \"PubMed Import broken\" (pull request #11 by vegeziel)
     - Fixes bug #959 \"StringIndexOutOfBoundsException with invalid Preview text\" (pull request #13 by IngvarJackal)
     - Fixes bug #960 \"FileNotFoundException in Journal abbreviations window\" (pull request #13 by IngvarJackal)
+    - Make (un)abbreviating journal titles also work on the journaltitle field
+    - Fix error when setting a previously unset field via the source panel of the entry editor
 2.10
     - Made IEEEXploreFetcher author parsing work again.
     - Added a few more characters in the HTML/Unicode to LaTeX conversion., @@ -840,15 +840,14 @@ public boolean storeSource(boolean showError) {
 
             // Then set all fields that have been set by the user.
             for (String field : nu.getAllFields()){
-                if (!entry.getField(field).equals(nu.getField(field))) {
-                    String toSet = nu.getField(field);
-
+                String oldValue = entry.getField(field);
+                String newValue = nu.getField(field);
+                if (oldValue == null || !oldValue.equals(newValue)) {
                     // Test if the field is legally set.
-                    (new LatexFieldFormatter()).format(toSet, field);
+                    (new LatexFieldFormatter()).format(newValue, field);
 
-                    compound.addEdit(new UndoableFieldChange(entry, field, entry
-                        .getField(field), toSet));
-                    entry.setField(field, toSet);
+                    compound.addEdit(new UndoableFieldChange(entry, field, oldValue, newValue));
+                    entry.setField(field, newValue);
                     anyChanged = true;
                 }
             }, ]"	"When the user tries to set a previously unset field of an entry via the
source panel of the entry editor, the program complains with an error
message and refuses to store the field values.
This change fixes that behaviour.
"	"Fix error when setting unset field in source panel"
"18"	"Joerg Lenhard"	"[build.gradle, gradle/wrapper/gradle-wrapper.properties, ]"	"[@@ -95,7 +95,7 @@ sourceCompatibility = 1.6
 mainClassName = \"net.sf.jabref.JabRefMain\"
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.0'
+    gradleVersion = '2.1'
 }
 
 compileJava {, @@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.0-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.1-all.zip, ]"	"Just a minor update to the gradle version.
"	"Update to gradle 2.1"
"19"	"Thiago Toledo"	"[src/main/resources/resource/log4j.properties, ]"	"[@@ -1,6 +1,6 @@
 #Uncomment next line for debugging
-log4j.rootCategory=ALL,stderr
-#log4j.rootCategory=WARN,stderr
+#log4j.rootCategory=ALL,stderr
+log4j.rootCategory=WARN,stderr
 log4j.appender.stderr=org.apache.log4j.ConsoleAppender
 log4j.appender.stderr.target=System.err
 log4j.appender.stderr.layout=org.apache.log4j.PatternLayout, ]"	"The getBasePath() was returning NullPointerException, because the method was trying to create a File using a null basePath. I changed the getBasePath method to return a String, create a getFileFromBasePath and where the old getBasePath was called, I changed it to getFileFromBasePath, verifying if basePath was null. 
"	"Fix bug 950"
"20"	"Tobias"	"[src/main/java/net/sf/jabref/imports/BibtexParser.java, ]"	"[@@ -979,7 +979,8 @@ public void checkEntryTypes(ParserResult _pr) {
 					// \"+be.getType().getName());
 					_pr
 						.addWarning(Globals.lang(\"unknown entry type\") + \": \"
-							+ be.getType().getName() + \". \" + Globals.lang(\"Type set to 'other'\")
+							+ be.getType().getName() + \":\" + be.getField(BibtexFields.KEY_FIELD)
+							+ \" . \" + Globals.lang(\"Type set to 'other'\")
 							+ \".\");
 					be.setType(BibtexEntryType.OTHER);
 				}, ]"	"I had problems locating which entry had this unknown entry type and hence extended the error message to also include the bibtex key.
"	"Extended the 'unknown entry type' error message "
"21"	"rmmsilva"	"[CHANGELOG, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Fix for bug 949: Exception properly logged
 	- Fix for bug 950: NullPointerException on \"Manage custom imports\"
 	- Feature 850: Keyboard shortcut for 'Cleanup entries' (by eduardogreco)
     - Change default behaviour to be more non-invasive: timestamps and owners are NOT set by default per entry., @@ -91,7 +91,8 @@ <h2>Contributions from:</h2>
         John Zedlewski,
         Waluyo Adi Siswanto,
 		Eduardo Roberto Greco,
-		Thiago Gomes Toledo</p>
+		Thiago Gomes Toledo,
+		Renato Massao Maeda da Silva</p>
 
         <h2>Thanks to:</h2>
 , ]"	"An IOException is caught when the user tries to load an invalid jar file in the menu Options/\"Manage custom imports\", but this exception is not properly treated, because its stack trace is thrown into the stdout. Now it is being properly logged and not thrown into the stdout.  
"	"Fixed bug 949"
"22"	"Tobias"	"[src/main/java/net/sf/jabref/BibtexEntry.java, ]"	"[@@ -371,6 +371,8 @@ public String getFieldOrAlias(String name) {
         if(name.equals(\"year\") || name.equals(\"month\"))
         {
         	String date = getField(\"date\");
+        	if(date == null)
+        		return null;
         	
         	// Create date format matching dates with year and month
         	DateFormat df = new DateFormat() {, ]"	"- Added support for aliased fields. For example, the content in the 'journaltitle' field is also shown in the 'journal' table.
- Added cleanup option to convert to the new BibLatex format
- Modified the required/optional fields for BibLatex entries to reflect the above changes (the 'year' field is no longer required)
"	"Extend BibLatex: support for alias fields"
"23"	"Mattias Ulbrich"	"[src/main/java/net/sf/jabref/imports/DBLPHelper.java, ]"	"[@@ -66,7 +66,7 @@ public String cleanDBLPQuery(String query) {
 	 */
 	public List<BibtexEntry> getBibTexFromPage(final String page) {
 		final List<BibtexEntry> bibtexList = new ArrayList<BibtexEntry>();
-		final String startPattern = \"<pre>\";
+		final String startPattern = \"<pre class=\\"verbatim select-on-click\\">\";
 		final String endPattern = \"</pre>\";
 
 		String tmpStr = page;, ]"	"DBLP seems to send `<pre class=\"verbatim select-on-click\">` now instead of only `<pre>`.
"	"adapted a pattern to parse DBLP entries."
"24"	"lucianamelo"	"[CHANGELOG, src/main/java/net/sf/jabref/ContentSelectorDialog2.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Fix for bug 958: ArrayIndexOutOfBoundsException on \"Content Selector Dialog\"
 	- Fix for bug 949: Exception properly logged
 	- Fix for bug 950: NullPointerException on \"Manage custom imports\"
 	- Feature 850: Keyboard shortcut for 'Cleanup entries' (by eduardogreco), @@ -251,8 +251,14 @@ public void actionPerformed(ActionEvent e) {
 
 	ok.addActionListener(new ActionListener() {
 		public void actionPerformed(ActionEvent e) {
-		    applyChanges();
-		    dispose();
+			try {
+				applyChanges();
+				dispose();
+			}
+			catch (Exception ex) {
+				Globals.logger(\"Could not apply changes in \\"Setup selectors\\"\");
+				JOptionPane.showMessageDialog(frame, Globals.lang(\"Could not apply changes.\"));
+			}
 		}
 	    });
 
@@ -262,7 +268,13 @@ public void actionPerformed(ActionEvent e) {
             if (!wordEditField.getText().equals(\"\")) {
                 wordEditFieldListener.actionPerformed(null);
             }
-		    applyChanges();
+            try {
+            	applyChanges();
+            }
+            catch (Exception ex) {
+				Globals.logger(\"Could not apply changes in \\"Setup selectors\\"\");
+				JOptionPane.showMessageDialog(frame, Globals.lang(\"Could not apply changes.\"));
+			}
 		}
 	    });
 	, @@ -92,7 +92,8 @@ <h2>Contributions from:</h2>
         Waluyo Adi Siswanto,
 		Eduardo Roberto Greco,
 		Thiago Gomes Toledo,
-		Renato Massao Maeda da Silva</p>
+		Renato Massao Maeda da Silva
+		Luciana de Melo e Abud</p>
 
         <h2>Thanks to:</h2>
 , ]"	"ArrayIndexOutOfBoundsException was produced when the user  tried to apply changes in \"Setup selectors\" right after closing all databases. Now the exception is caught and a message is shown, telling the user that the changes could not be applied.
"	"Fix for bug #958: ArrayIndexOutOfBoundsException "
"25"	"Yara Grassi Gouffon"	"[CHANGELOG, src/main/java/net/sf/jabref/export/OOCalcDatabase.java, src/main/java/net/sf/jabref/export/OpenDocumentRepresentation.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Partial fix for bug 913: fixed export for .ods and .sxc (by yaragg)
 	- Fix for bug 949: Exception properly logged
 	- Fix for bug 950: NullPointerException on \"Manage custom imports\"
 	- Feature 850: Keyboard shortcut for 'Cleanup entries' (by eduardogreco), @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 JabRef contributors.
+/*  Copyright (C) 2003-2014 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or, @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 JabRef contributors.
+/*  Copyright (C) 2003-2014 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or, @@ -92,7 +92,8 @@ <h2>Contributions from:</h2>
         Waluyo Adi Siswanto,
 		Eduardo Roberto Greco,
 		Thiago Gomes Toledo,
-		Renato Massao Maeda da Silva</p>
+		Renato Massao Maeda da Silva,
+		Yara Grassi Gouffon</p>
 
         <h2>Thanks to:</h2>
 , ]"	"Realized many fields were not being exported, not only in .csv and .ods formats as stated in the bug report, but in .sxc as well. I fixed the export for both .ods and .sxc, but couldn't figure out how to fix it for .csv.
"	"Partial fix for bug #913"
"26"	"Leonardo Haddad"	"[CHANGELOG, src/main/java/net/sf/jabref/BibtexString.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Fix for bug 1240: Accepting string with length of one character (by lhaddad).
 	- Fix for bug 949: Exception properly logged
 	- Fix for bug 950: NullPointerException on \"Manage custom imports\"
 	- Feature 850: Keyboard shortcut for 'Cleanup entries' (by eduardogreco), @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 JabRef contributors.
+/*  Copyright (C) 2003-2014 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -67,7 +67,7 @@
         }
 
         public static final Type get(String name) {
-        	if (name.length() == 0) {
+        	if (name.length() <= 1) {
         		return OTHER;
         	}
             if (!(name.charAt(1) + \"\").toUpperCase().equals(, @@ -92,7 +92,8 @@ <h2>Contributions from:</h2>
         Waluyo Adi Siswanto,
 		Eduardo Roberto Greco,
 		Thiago Gomes Toledo,
-		Renato Massao Maeda da Silva</p>
+		Renato Massao Maeda da Silva
+		Leonardo Haddad Carlos</p>
 
         <h2>Thanks to:</h2>
 , ]"	"Fixed bug #1240, about an error thrown when trying to add a string with length of one character.
"	"Fixed bug #1240. 1-char strings working correctly."
"27"	"Thorsten Dahlheimer"	"[src/main/java/net/sf/jabref/gui/CleanUpAction.java, ]"	"[@@ -680,8 +680,8 @@ private void doConvertToBiblatex(BibtexEntry entry, NamedCompound ce) {
     		entry.setField(\"month\", null);
     		
     		ce.addEdit(new UndoableFieldChange(entry, \"date\", null, newDate));
-    		ce.addEdit(new UndoableFieldChange(entry, \"date\", oldYear, null));
-    		ce.addEdit(new UndoableFieldChange(entry, \"date\", oldMonth, null));
+    		ce.addEdit(new UndoableFieldChange(entry, \"year\", oldYear, null));
+    		ce.addEdit(new UndoableFieldChange(entry, \"month\", oldMonth, null));
     	}
     }
 , ]"	"When Cleanup/Convert to Biblatex converted year/month fields to a date
field, it used to store erroneous undo information. This change fixes
it.
"	"Fix undoing Cleanup/Convert to Biblatex"
"28"	"Thorsten Dahlheimer"	"[CHANGELOG, src/main/java/net/sf/jabref/FieldComparator.java, ]"	"[@@ -34,6 +34,7 @@
         - Feature #685 Highlight new entries that were \"forgotten\"
         - Feature #602 could add the mark as read feature
         - Feature #225 read? checkbox
+    - Take aliased fields into account when sorting entries
 2.10
     - Made IEEEXploreFetcher author parsing work again.
     - Added a few more characters in the HTML/Unicode to LaTeX conversion., @@ -180,7 +180,7 @@ public int compare(BibtexEntry e1, BibtexEntry e2) {
 
     private Object getField(BibtexEntry entry) {
         for (String aField : field) {
-            Object o = entry.getField(aField);
+            Object o = entry.getFieldOrAlias(aField);
             if (o != null)
                 return o;
         }, ]"	""	"Take aliased fields into account when sorting entries"
"29"	"Tobias"	"[src/main/java/net/sf/jabref/BibtexEntry.java, src/main/java/net/sf/jabref/gui/CleanUpAction.java, ]"	"[@@ -365,7 +365,7 @@ public String getFieldOrAlias(String name) {
         		if(month == 0)
         			return year;
         		else
-        			return year + \"-\" + month;
+        			return year + \"-\" + String.format(\"%02d\", month);
         	}
         }
         if(name.equals(\"year\") || name.equals(\"month\")), @@ -16,7 +16,16 @@
 package net.sf.jabref.gui;
 
 import java.io.File;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.time.format.DateTimeParseException;
+import java.time.temporal.TemporalAccessor;
 import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.logging.Logger;
@@ -683,6 +692,42 @@ private void doConvertToBiblatex(BibtexEntry entry, NamedCompound ce) {
     		ce.addEdit(new UndoableFieldChange(entry, \"date\", oldYear, null));
     		ce.addEdit(new UndoableFieldChange(entry, \"date\", oldMonth, null));
     	}
+    	
+    	// Dates: format dates correctly (yyyy-mm-dd or yyyy-mm)
+    	if(entry.getField(\"date\") != null)
+    	{
+    		String oldDate = entry.getField(\"date\");
+    	
+    		TemporalAccessor parsedDate = tryParseDate(oldDate);
+	    	if(parsedDate != null)
+	    	{
+	    		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(\"uuuu-MM[-dd]\");
+	    		String formatedDate = dateFormatter.format(parsedDate);
+	    		
+	    		 if (!oldDate.equals(formatedDate)) {
+    	            entry.setField(\"date\", formatedDate);
+    	            ce.addEdit(new UndoableFieldChange(entry, \"date\", oldDate, formatedDate));
+    	        }
+	    	}
+    	}
     }
+    
+    TemporalAccessor tryParseDate(String dateString)
+    {
+    	// The following code is essentially copied from http://stackoverflow.com/questions/4024544/how-to-parse-dates-in-multiple-formats-using-simpledateformat
+    	// Try to parse the following formats
+    	// 	\"M/y\" (covers 9/09, 9/2009, and 09/2009)
+    	// 	\"yyyy-MM-dd\" (covers 2009-1-15)
+    	String[] formatStrings = {\"uuuu-MM-dd\", \"uuuu-MM\", \"uuuu-M\"};
+        for (String formatString : formatStrings)
+        {
+            try
+            {
+            	return DateTimeFormatter.ofPattern(formatString).parse(dateString);
+            }
+            catch (DateTimeParseException e) {}
+        }
 
+        return null;
+    }
 }, ]"	"Fixed bug where conversion of a bibtex year/month representation to the biblatex date field an invalid date would be generated (i.e. 2013-1 instead of 2013-01)

Added basic formating of date fields in cleanup
"	"Small bugfixes/improvements for biblatex support"
"30"	"Philip Johnson"	"[CHANGELOG, src/main/java/net/sf/jabref/imports/MedlineHandler.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+    - Feature #809: import pubmed central id (pmc) field from medline
     - Fix undoing Cleanup/Convert to Biblatex
     - Adapted pattern to parse DBLP entries
     - Partial fix for bug 913: fixed export for .ods and .sxc (by yaragg), @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2011 JabRef contributors.
+/*  Copyright (C) 2003-2014 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -38,14 +38,14 @@
 		inMedlineID = false,		inURL=false,
 		inIssue = false,			inPubDate = false,
         inUrl=false, inForename=false, inAbstractText=false, inMedlineDate=false,
-		inPubMedID=false, inDescriptorName=false,inDoi=false,inPii=false,
+		inPubMedID=false, inDescriptorName=false,inDoi=false,inPii=false,inPmc=false,
         inAffiliation=false, inMeshHeader=false, inQualifierName=false,
         inLanguage=false, inPst=false;
     String title=\"\", journal=\"\", keywords =\"\",author=\"\",
 		lastName=\"\",suffix=\"\",year=\"\",forename=\"\", abstractText=\"\", affiliation=\"\";
     String month=\"\",volume=\"\",lastname=\"\",initials=\"\",number=\"\",page=\"\",medlineID=\"\",url=\"\",MedlineDate=\"\";
     String series=\"\",editor=\"\",booktitle=\"\",type=\"article\",key=\"\",address=\"\",
-		pubmedid=\"\",doi=\"\",pii=\"\", majorTopic = \"\", minorTopics = \"\", language = \"\", pst= \"\";
+        pubmedid=\"\",doi=\"\",pii=\"\", pmc=\"\",majorTopic = \"\", minorTopics = \"\", language = \"\", pst= \"\";
     ArrayList<String> authors=new ArrayList<String>();
     TreeSet<String> descriptors = new TreeSet<String>(); // To gather keywords
     int rowNum=0;
@@ -117,6 +117,8 @@ else if(localName.equals(\"ArticleId\")){
 					inDoi=true;
 				else if(value.equals(\"pii\"))
 					inPii=true;
+				else if(value.equals(\"pmc\"))
+					inPmc=true;
 
 			}
 		}
@@ -194,6 +196,8 @@ public void endElement( String uri, String localName, String qName ) {
 			}
 			if(!pii.equals(\"\"))
 			    b.setField(\"pii\",pii);
+			if(!pmc.equals(\"\"))
+			    b.setField(\"pmc\",pmc);
             if(!affiliation.equals(\"\")) {
                 b.setField(\"institution\",affiliation.replaceAll(\"#\", \"\\\\#\"));
             }
@@ -212,7 +216,7 @@ public void endElement( String uri, String localName, String qName ) {
 			title=\"\";
 			journal=\"\";
 			keywords =\"\";
-            doi=\"\"; pii=\"\";
+                        doi=\"\"; pii=\"\"; pmc=\"\";
 			year=\"\";
 			forename=\"\";
 			lastName=\"\";
@@ -293,7 +297,9 @@ else if(localName.equals(\"ArticleId\")){
 			if(inDoi)
 				inDoi=false;
 			else if(inPii)
-				inPii=false;}
+				inPii=false;
+			else if(inPmc)
+				inPmc=false;}
     }
 
     public void characters( char[] data, int start, int length ) {
@@ -332,6 +338,7 @@ else if(inForename){
 		else if(inMedlineDate){ MedlineDate += new String(data,start,length);}
 		else if(inDoi){ doi=new String(data,start,length);}
 		else if(inPii){ pii=new String(data,start,length);}
+		else if(inPmc){ pmc=new String(data,start,length);}
         else if(inAffiliation){ affiliation = new String(data,start,length);}
     }
 , @@ -67,6 +67,7 @@ <h2>Contributions from:</h2>
         Yara Grassi Gouffon,
         Leonardo Haddad Carlos
         Sascha Hunold,
+        Philip Johnson,
         Bernd Kalbfuss,
         Martin K&auml;hmer,
         Ervin Kolenovic,, ]"	"Import \"pmc\" field into bibtex from pubmed/medline records.  This field is analogous to other pubmed identifiers (pubmed id, doi, pii) and is used in NIH grant applications when listing publications produced by NIH-funded work.

I was working on my grant progress report and realized this change was easy to make, so I went ahead and did it.  Since there was already a feature request, seems others are interested too.
"	"Feature 809: import Pubmed Central ID"
"31"	"Brian Quistorff"	"[CHANGELOG, src/main/java/net/sf/jabref/imports/DOItoBibTeXFetcher.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+    - Fix for bug 1213 (sourceforge): Fix encoding for DOI import
     - Feature #809: import pubmed central id (pmc) field from medline
     - Fix undoing Cleanup/Convert to Biblatex
     - Adapted pattern to parse DBLP entries, @@ -1,4 +1,4 @@
-/*  Copyright (C) 2012 JabRef contributors.
+/*  Copyright (C) 2014 JabRef contributors.
     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or, @@ -83,6 +83,7 @@ <h2>Contributions from:</h2>
         Alex Montgomery,
         Saverio Mori,
         Ambrogio Oliva,
+        Brian Quistorff,
         Stephan Rave,
         John Relph,
         Hannes Restel,, ]"	"Get the right encoding for the data from DOI import. Then, for
convenience, also replace the en-dash so that most entries can compile
under latex without modification.
Fixes: http://sourceforge.net/p/jabref/bugs/1213/
"	"Fix encoding for DOI import"
"32"	"Alexsandro Lauber"	"[src/main/java/net/sf/jabref/JabRefPreferences.java, ]"	"[@@ -885,10 +885,9 @@ public KeyStroke getKey(String bindName) {
             // So, if this happens, we add the default value to the current
             // hashmap, so this doesn't happen again, and so this binding
             // will appear in the KeyBindingsDialog.
-            keyBinds.put(bindName, s);
-        }
-        if (s == null) {
             Globals.logger(\"Could not get key binding for \\"\" + bindName + \"\\"\");
+            s = \"Not associated\"; // if the item of menu not in defKeyBind list
+            keyBinds.put(bindName, s);
         }
 
         if (Globals.ON_MAC) {, ]"	"After checking the bug '1248 Key bindings not modified', it was Identified que the creation of the hashmap list 'defKeyBinds' that sets the standard keyboard shortcuts, the feature 'Open folder' was not included in the 'defineDefaultKeyBindings ( )' method in 'JabRefPreferences' class .
In the creation of the menu item in the 'JabRefFrame' class for the item 'Open folder', it was not possible to recover the value of the item in the list 'defKeyBinds', occurring error 'NullPointerException' in the 'String makeEscape (String s) 'method in 'JabRefPreferences' class, which shouldnt return the value of 'String' to fill out the menu item.
When the 'User' tried to change and save the list, the error 'NullPointerException' not allow the execution of the procedure.
To solve the bug , was included in the verification of the presence of null in 'keyBinds' list (copy of 'defKeyBinds'), the value 'Not associated' being passed to the 'String' return.
The warning that menu feature is created in the 'JabRefFrame' class without associated keyboard shortcut, was moved to the method mentioned before, as was duplicated.
"	"Solve the bug '1248 Key bindings not modified'"
"33"	"Ruy Minoru Ito Takata"	"[CHANGELOG, src/main/java/net/sf/jabref/imports/HTMLConverter.java, src/main/resources/help/About.html, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Fix for bug #1253: Cleanup entries error 2 (by ruy.takata)
     - Fix for bug 1213 (sourceforge): Fix encoding for DOI import
     - Feature #809: import pubmed central id (pmc) field from medline
     - Fix undoing Cleanup/Convert to Biblatex, @@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2012 JabRef contributors.
+/*  Copyright (C) 2003-2015 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -107,7 +107,7 @@
         //                                 U+00C3 ISOlat1 
         {\"196\", \"Auml\", \"\\{\\\\\\"\\{A\\}\\}\"}, // latin capital letter A with diaeresis, 
         //                                 U+00C4 ISOlat1 
-        {\"197\", \"Aring\", \"\\{\\\\AA\\}\"}, // latin capital letter A with ring above 
+        {\"197\", \"Aring\", \"\\{\\{\\\\AA\\}\\}\"}, // latin capital letter A with ring above 
         //                                 = latin capital letter A ring,
         //                                 U+00C5 ISOlat1 
         {\"198\", \"AElig\", \"\\{\\\\AE\\}\"}, // latin capital letter AE 
@@ -173,7 +173,7 @@
         //                                 U+00E3 ISOlat1 
         {\"228\", \"auml\", \"\\{\\\\\\"\\{a\\}\\}\"}, // latin small letter a with diaeresis, 
         //                                 U+00E4 ISOlat1 
-        {\"229\", \"aring\", \"\\{\\\\aa\\}\"}, // latin small letter a with ring above 
+        {\"229\", \"aring\", \"\\{\\{\\\\aa\\}\\}\"}, // latin small letter a with ring above 
         //                                 = latin small letter a ring,
         //                                 U+00E5 ISOlat1 
         {\"230\", \"aelig\", \"\\{\\\\ae\\}\"}, // latin small letter ae , @@ -101,7 +101,8 @@ <h2>Contributions from:</h2>
         Mattias Ulbrich,
         David Weitzman,
         Seb Wills,
-        John Zedlewski</p>
+        John Zedlewski,
+        Ruy Minoru Ito Takata</p>
 
         <h2>Thanks to:</h2>
 , ]"	"Committer: Ruy Minoru Ito Takata ruy.takata@gmail.com

When using the \"Cleanup entries\" function, the special character Å should be converted to {{\AA}} to preserve the capital when generating the PDF.
"	"Fix for bug #1253: Cleanup entries error 2"
"34"	"NS"	"[src/main/resources/help/About.html, ]"	"[@@ -90,6 +90,7 @@ <h2>Contributions from:</h2>
         Moritz Ringler,
         Andreas Rudert,
         Mark Schenk,
+        Nathan Sheffield,
         Rudolf Seemann,
         Toralf Senger,
         Manuel Siebeneicher,, ]"	"Changes the CrossRef content negotiation method to yield more complete bibtex entries. This fixes an issue with DOI import from papers with many authors, which previously yielded truncated results.
"	"Change DOI importer to use application/x-bibtex"
"35"	"Ruy Minoru Ito Takata - SUPCD/CDISO/CDSSP"	"[CHANGELOG, src/main/java/net/sf/jabref/imports/HTMLConverter.java, ]"	"[@@ -1,4 +1,5 @@
 [master]
+	- Fix for bug #1270: Cleanup entries error 3
     - Fix for bug #919: Accents don't export to RTF (by ruy.takata)
     - Change the CrossRef content negotiation for bibtex DOI import (by sheffien)
     - Fix for bug #1253: Cleanup entries error 2 (by ruy.takata), @@ -188,13 +188,13 @@
         //                                 U+00EA ISOlat1 
         {\"235\", \"euml\", \"\\{\\\\\\"\\{e\\}\\}\"}, // latin small letter e with diaeresis, 
         //                                 U+00EB ISOlat1 
-        {\"236\", \"igrave\", \"\\{\\\\`\\{\\\\i\\}\\}\"}, // latin small letter i with grave,
+        {\"236\", \"igrave\", \"\\{\\\\`\\{i\\}\\}\"}, // latin small letter i with grave,
         //                                 U+00EC ISOlat1 
-        {\"237\", \"iacute\", \"\\{\\\\'\\{\\\\i\\}\\}\"}, // latin small letter i with acute, 
+        {\"237\", \"iacute\", \"\\{\\\\'\\{i\\}\\}\"}, // latin small letter i with acute, 
         //                                 U+00ED ISOlat1 
-        {\"238\", \"icirc\", \"\\{\\\\\\^\\{\\\\i\\}\\}\"}, // latin small letter i with circumflex, 
+        {\"238\", \"icirc\", \"\\{\\\\\\^\\{i\\}\\}\"}, // latin small letter i with circumflex, 
         //                                 U+00EE ISOlat1 
-        {\"239\", \"iuml\", \"\\{\\\\\\"\\{\\\\i\\}\\}\"}, // latin small letter i with diaeresis, 
+        {\"239\", \"iuml\", \"\\{\\\\\\"\\{i\\}\\}\"}, // latin small letter i with diaeresis, 
         //                                 U+00EF ISOlat1 
         {\"240\", \"eth\", \"\\{\\\\dh\\}\"}, // latin small letter eth, U+00F0 ISOlat1  
         {\"241\", \"ntilde\", \"\\{\\\\~\\{n\\}\\}\"}, // latin small letter n with tilde, 
@@ -227,6 +227,8 @@
         //                                 U+00FE ISOlat1 
         {\"255\", \"yuml\", \"\\{\\\\\\"\\{y\\}\\}\"}, // latin small letter y with diaeresis, 
         //                                 U+00FF ISOlat1 
+        {\"332\", \"Omacro\", \"\\{\\\\=\\{O\\}\\}\"}, // the small letter o with macron
+        {\"333\", \"omacro\", \"\\{\\\\=\\{o\\}\\}\"}, // the big letter O with macron
         {\"402\", \"fnof\", \"\\$f\\$\"}, // latin small f with hook = function 
         //                                   = florin, U+0192 ISOtech 
 , ]"	"Tests with various accented characters were made. The result was: 
Ç ü é ã á ä à å ç ê ë è ï í ì î Ä Å É æ Æ ô ö ò û ù ÿ Ö Ü ó ú ñ Ñ Ã Á Â À Ð Ê Ë È Í Î Ï Ì Ó Ô Ò õ Õ Ú Û Ù ý Ý ø Ø ï
"	"Fix for bug #919: Accents don't export to RTF"
"36"	"Igor Steinmacher"	"[]"	"[]"	"Fix for a bug. Patch sent via other fork. Changed  class BibtexParser to accommodate the fix
"	"Fix for bug #1269 (SF)"
"37"	"Oliver Kopp"	"[CHANGELOG, ]"	"[@@ -1,5 +1,5 @@
 [master]
-	- Fix for bug #1270: Cleanup entries error 3
+    - Fix for bug #1270: Cleanup entries error 3
     - Fix for bug #919: Accents don't export to RTF (by ruy.takata)
     - Change the CrossRef content negotiation for bibtex DOI import (by sheffien)
     - Fix for bug #1253: Cleanup entries error 2 (by ruy.takata), ]"	"Previously, JabRef couldn't be pinned to the taskbar ([bug report](https://sourceforge.net/p/jabref/bugs/876/)). The reason is that, by wrapping JabRef with Launch4j, Windows thinks only Java is running and does not recognize JabRef as something separate.

Based on a [stackoverflow question](http://stackoverflow.com/questions/9330209/whats-the-best-way-to-start-java-applications-on-windows-7) the fix proceeds in two stages:
- During the setup, we create a (dummy) shortcut and set the [Application User Model Id](https://msdn.microsoft.com/en-us/library/windows/desktop/dd378459%28v=vs.85%29.aspx). For this, we use the [WinShell plugin](http://nsis.sourceforge.net/WinShell_plug-in) for NSIS.
- At program start, we notify Windows that this JabRef instance has the AppUserModelId specified in the setup. In order to do this, we invoke native commands using the Java Native Access (JNA) library. 
"	"Fix for bug #876: Windows 7/8/10 - Pinning Jabref to the taskbar"
"38"	"Tobias"	"[README.md, jabref-launch4j.xml, ]"	"[@@ -128,7 +128,8 @@ To get a list of all targets, use `gradlew tasks`.
 To compile, use the command `gradlew generateSource antTargets.jars`.
 After the build is finished, you can find the executable jar file
 named `JabRef-$VERSION.jar` (where $VERSION is the current version of the
-source tree) in the `build/lib` directory. Enjoy!
+source tree) in the `buildant\lib` directory. Enjoy!
+The setup files are created by invoking the command `gradlew generateSource antTargets.release`.
 
 On Mac OS X you should include the targets osx and osxjar,
 making the correct command `gradlew generateSource antTargets.compile antTargets.unjarlib antTargets.osx antTargets.jars antTargets.osxjar`., @@ -2,7 +2,7 @@
   <dontWrapJar>true</dontWrapJar>
   <headerType>gui</headerType>
   <jar>JabRef-1.1.1.jar</jar>
-  <outfile>.\src\windows\nsis\dist\JabRef.exe</outfile>
+  <outfile>./src/main/resources/windows/nsis/dist/JabRef.exe</outfile>
   <errTitle></errTitle>
   <cmdLine></cmdLine>
   <chdir></chdir>
@@ -12,7 +12,7 @@
   <customProcName>false</customProcName>
   <stayAlive>false</stayAlive>
   <manifest></manifest>
-  <icon>./src/resources/images/JabRef.ico</icon>
+  <icon>./src/main/resources/images/JabRef.ico</icon>
   <jre>
     <path></path>
     <minVersion>1.6.0</minVersion>, ]"	"In order that the Launch4j build task works, some paths in the configuration file have to be changed.
"	"Updated some paths in Launch4j configuration file"
"39"	"Tobias"	"[CHANGELOG, src/main/java/net/sf/jabref/AppearancePrefsTab.java, src/main/java/net/sf/jabref/BasePanel.java, src/main/java/net/sf/jabref/JabRefPreferences.java, src/main/java/net/sf/jabref/gui/MainTable.java, ]"	"[@@ -1,5 +1,5 @@
 [master]
-    - Some UI updates
+    - Feature: Gridlines are now optional (and disabled by default)
     - Fix for bug #1270: Cleanup entries error 3
     - Fix for bug #919: Accents don't export to RTF (by ruy.takata)
     - Change the CrossRef content negotiation for bibtex DOI import (by sheffien), @@ -31,12 +31,12 @@
 class AppearancePrefsTab extends JPanel implements PrefsTab {
 
     JabRefPreferences _prefs;
-    private JCheckBox colorCodes, overrideFonts;//, useCustomIconTheme;
+    private JCheckBox colorCodes, overrideFonts, showGrid;//, useCustomIconTheme;
     private ColorSetupPanel colorPanel = new ColorSetupPanel();
     private Font font = GUIGlobals.CURRENTFONT;
     private int oldMenuFontSize;
     private boolean oldOverrideFontSize;
-    private JTextField fontSize;//, customIconThemeFile;
+    private JTextField fontSize, gridPadding;//, customIconThemeFile;
 
     /**
      * Customization of appearance parameters.
@@ -57,6 +57,9 @@ public AppearancePrefsTab(JabRefPreferences prefs) {
                   (\"Use antialiasing font\"));*/
         overrideFonts = new JCheckBox(Globals.lang(\"Override default font settings\"));
 
+        gridPadding = new JTextField(5);
+        showGrid = new JCheckBox(Globals.lang(\"Show gridlines\"));
+        
         //useCustomIconTheme = new JCheckBox(Globals.lang(\"Use custom icon theme\"));
         //customIconThemeFile = new JTextField();
         FormLayout layout = new FormLayout
@@ -79,6 +82,14 @@ public AppearancePrefsTab(JabRefPreferences prefs) {
         //builder.nextLine();
         builder.append(colorCodes);
         builder.nextLine();
+        builder.append(showGrid);
+        builder.nextLine();
+        JPanel panelGridPadding = new JPanel();
+        lab = new JLabel(Globals.lang(\"Additional cell padding (in px)\") + \":\");
+        panelGridPadding.add(lab);
+        panelGridPadding.add(gridPadding);
+        builder.append(panelGridPadding);
+        builder.nextLine();
         JButton fontButton = new JButton(Globals.lang(\"Set table font\"));
         builder.append(fontButton);
         builder.nextLine();
@@ -149,6 +160,8 @@ public void setValues() {
         fontSize.setEnabled(overrideFonts.isSelected());
         //useCustomIconTheme.setSelected(_prefs.getBoolean(\"useCustomIconTheme\"));
         //customIconThemeFile.setText(_prefs.get(\"customIconThemeFile\"));
+        showGrid.setSelected(_prefs.getBoolean(\"tableShowGrid\"));
+        gridPadding.setText(\"\" + _prefs.getInt(\"tablePadding\"));
         colorPanel.setValues();
     }
 
@@ -167,6 +180,7 @@ public void storeSettings() {
         _prefs.putBoolean(\"overrideDefaultFonts\", overrideFonts.isSelected());
         GUIGlobals.CURRENTFONT = font;
         colorPanel.storeSettings();
+        _prefs.putBoolean(\"tableShowGrid\", showGrid.isSelected());
         try {
             int size = Integer.parseInt(fontSize.getText());
             if ((overrideFonts.isSelected() != oldOverrideFontSize) ||
@@ -179,6 +193,7 @@ public void storeSettings() {
                         Globals.lang(\"Changed font settings\"),
                         JOptionPane.WARNING_MESSAGE);
             }
+           _prefs.putInt(\"tablePadding\", Integer.parseInt(gridPadding.getText()));
 
         } catch (NumberFormatException ex) {
             ex.printStackTrace();
@@ -196,6 +211,16 @@ public boolean readyToClose() {
                             JOptionPane.ERROR_MESSAGE);
             return false;
         }
+        try {
+            // Test if table padding is a number:
+            Integer.parseInt(gridPadding.getText());
+        } catch (NumberFormatException ex) {
+            JOptionPane.showMessageDialog
+                    (null, Globals.lang(\"You must enter an integer value in the text field for\") + \" '\" +
+                            Globals.lang(\"Additional cell padding (in px)\") + \"'\", Globals.lang(\"Changed table settings\"),
+                            JOptionPane.ERROR_MESSAGE);
+            return false;
+        }
         return true;
 
     }, @@ -45,8 +45,6 @@
 import java.util.Vector;
 import java.util.logging.Logger;
 
-import javafx.scene.Parent;
-
 import javax.swing.AbstractAction;
 import javax.swing.BorderFactory;
 import javax.swing.JComponent;, @@ -401,6 +401,8 @@ private JabRefPreferences() {
         defaults.put(\"tableReqFieldBackground\", \"230:235:255\");
         defaults.put(\"tableOptFieldBackground\", \"230:255:230\");
         defaults.put(\"tableText\", \"0:0:0\");
+        defaults.put(\"tablePadding\", 0);
+        defaults.put(\"tableShowGrid\", Boolean.FALSE);
         defaults.put(\"gridColor\", \"210:210:210\");
         defaults.put(\"grayedOutBackground\", \"210:210:210\");
         defaults.put(\"grayedOutText\", \"40:40:40\");, @@ -114,9 +114,14 @@ public MainTable(MainTableFormat tableFormat, EventList<BibtexEntry> list, JabRe
         pane = new JScrollPane(this);
         pane.setBorder(BorderFactory.createEmptyBorder());
         pane.getViewport().setBackground(Globals.prefs.getColor(\"tableBackground\"));
-        //setGridColor(Globals.prefs.getColor(\"gridColor\"));
-        setShowGrid(false);
-        setIntercellSpacing(new Dimension(0, 0));
+        setGridColor(Globals.prefs.getColor(\"gridColor\"));
+        if(Globals.prefs.getBoolean(\"tableShowGrid\"))
+        	setShowGrid(true);
+        else
+        {
+	        setShowGrid(false);
+	        setIntercellSpacing(new Dimension(0, 0));
+        }
         
         this.setTableHeader(new PreventDraggingJTableHeader(this.getColumnModel()));
 
@@ -532,7 +537,7 @@ public void scrollTo(int y) {
      */
     public void updateFont() {
         setFont(GUIGlobals.CURRENTFONT);
-        setRowHeight(GUIGlobals.TABLE_ROW_PADDING + GUIGlobals.CURRENTFONT.getSize());
+        setRowHeight(GUIGlobals.TABLE_ROW_PADDING + Globals.prefs.getInt(\"tablePadding\") + GUIGlobals.CURRENTFONT.getSize());
     }
 
     public void ensureVisible(int row) {, ]"	"I tried to remove some 'clutter' in the UI by removing the gridlines and a few borders.
Before:
![before](https://cloud.githubusercontent.com/assets/5037600/7570437/936bc8a8-f810-11e4-9dc9-29e9c948c879.JPG)
After:
![after](https://cloud.githubusercontent.com/assets/5037600/7570438/936bd99c-f810-11e4-909e-7c0f729541d8.JPG)
"	"Update to UI: Remove some borders"
"40"	"Tobias"	"[CHANGELOG, src/main/java/net/sf/jabref/BasePanel.java, src/main/java/net/sf/jabref/JabRefFrame.java, src/main/java/net/sf/jabref/JabRefPreferences.java, ]"	"[@@ -1,4 +1,5 @@
 [master]
+    - Feature: Make it possible to hide the toolbar
     - Fix for bug #1270: Cleanup entries error 3
     - Fix for bug #919: Accents don't export to RTF (by ruy.takata)
     - Change the CrossRef content negotiation for bibtex DOI import (by sheffien), @@ -691,6 +691,12 @@ public void action() {
             }
         });
 
+        // The action for toggling the visibility of the toolbar
+        actions.put(\"toggleToolbar\", new BaseAction() {
+            public void action() {
+            	frame.tlb.setVisible(! frame.tlb.isVisible());
+            }
+        });
 
         // action for collecting database strings from user
         actions.put(\"dbConnect\", new DbConnectAction(this));, @@ -270,6 +270,9 @@ void addAction(Action a) {
       editStrings = new GeneralAction(\"editStrings\", \"Edit strings\",
                                       Globals.lang(\"Edit strings\"),
                                       prefs.getKey(\"Edit strings\")),
+	  toggleToolbar = new GeneralAction(\"toggleToolbar\", \"Hide/show toolbar\",
+              Globals.lang(\"Hide/show toolbar\"),
+	          prefs.getKey(\"Hide/show toolbar\")),
       toggleGroups = new GeneralAction(\"toggleGroups\",
                                        \"Toggle groups interface\",
                                        Globals.lang(\"Toggle groups interface\"),
@@ -470,6 +473,8 @@ public void windowClosing(WindowEvent e) {
         
         initActions();
 
+        // Show the toolbar if it was visible at last shutdown:
+        tlb.setVisible(Globals.prefs.getBoolean(\"toolbarVisible\"));
       
       setBounds(GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds());
       if ( !prefs.getBoolean(\"windowMaximised\") ) {
@@ -809,6 +814,7 @@ public void quit() {
       //prefs.putBoolean(\"windowMaximised\", (getExtendedState()&MAXIMIZED_BOTH)>0);
       prefs.putBoolean(\"windowMaximised\", (getExtendedState() == Frame.MAXIMIZED_BOTH));
       
+      prefs.putBoolean(\"toolbarVisible\", tlb.isVisible());
       prefs.putBoolean(\"searchPanelVisible\", sidePaneManager.isComponentVisible(\"search\"));
       // Store divider location for side pane:
       int width = contentPane.getDividerLocation();
@@ -1394,6 +1400,7 @@ private void fillMenu() {
       view.add(increaseFontSize);
       view.add(decreseFontSize);
       view.addSeparator();
+      view.add(toggleToolbar);
       view.add(toggleGroups);
       view.add(togglePreview);
       view.add(switchPreview);
@@ -1649,7 +1656,6 @@ private void createToolBar() {
     //Insets margin = new Insets(0, 0, 0, 0);
     //for (int i=0; i<tlb.getComponentCount(); i++)
     //  ((JButton)tlb.getComponentAtIndex(i)).setMargin(margin);
-
   }
 
   , @@ -373,6 +373,7 @@ private JabRefPreferences() {
         defaults.put(EDIT_GROUP_MEMBERSHIP_MODE, Boolean.FALSE);
         defaults.put(\"highlightGroupsMatchingAny\", Boolean.FALSE);
         defaults.put(\"highlightGroupsMatchingAll\", Boolean.FALSE);
+        defaults.put(\"toolbarVisible\", Boolean.TRUE);
         defaults.put(\"searchPanelVisible\", Boolean.FALSE);
         defaults.put(\"defaultEncoding\", System.getProperty(\"file.encoding\"));
         defaults.put(\"groupsVisibleRows\", 8);, ]"	"In addition, I would suggest to hide the toolbar by default. 
"	"Add entry under the 'View' menu to hide the toolbar"
"41"	"Adam Rehn"	"[src/main/java/net/sf/jabref/AppearancePrefsTab.java, src/main/java/net/sf/jabref/JabRefPreferences.java, src/main/java/net/sf/jabref/gui/MainTable.java, ]"	"[@@ -36,7 +36,7 @@
     private Font font = GUIGlobals.CURRENTFONT;
     private int oldMenuFontSize;
     private boolean oldOverrideFontSize;
-    private JTextField fontSize;//, customIconThemeFile;
+    private JTextField fontSize, rowPadding;//, customIconThemeFile;
 
     /**
      * Customization of appearance parameters.
@@ -50,6 +50,8 @@ public AppearancePrefsTab(JabRefPreferences prefs) {
         // Font sizes:
         fontSize = new JTextField(5);
 
+        // Row padding size:
+        rowPadding = new JTextField(5);
 
         colorCodes = new JCheckBox(
                    Globals.lang(\"Color codes for required and optional fields\"));
@@ -77,6 +79,11 @@ public AppearancePrefsTab(JabRefPreferences prefs) {
         builder.appendSeparator(Globals.lang(\"Table appearance\"));
         //builder.append(antialias);
         //builder.nextLine();
+        JPanel p2 = new JPanel();
+        p2.add(new JLabel(Globals.lang(\"Table row height padding\") + \":\"));
+        p2.add(rowPadding);
+        builder.append(p2);
+        builder.nextLine();
         builder.append(colorCodes);
         builder.nextLine();
         JButton fontButton = new JButton(Globals.lang(\"Set table font\"));
@@ -143,6 +150,7 @@ public void setValues() {
         colorCodes.setSelected(_prefs.getBoolean(\"tableColorCodesOn\"));
         //antialias.setSelected(_prefs.getBoolean(\"antialias\"));
         fontSize.setText(\"\" + _prefs.getInt(\"menuFontSize\"));
+        rowPadding.setText(\"\" + _prefs.getInt(\"tableRowPadding\"));
         oldMenuFontSize = _prefs.getInt(\"menuFontSize\");
         overrideFonts.setSelected(_prefs.getBoolean(\"overrideDefaultFonts\"));
         oldOverrideFontSize = overrideFonts.isSelected();
@@ -183,20 +191,41 @@ public void storeSettings() {
         } catch (NumberFormatException ex) {
             ex.printStackTrace();
         }
+        try {
+            int padding = Integer.parseInt(rowPadding.getText());
+                _prefs.putInt(\"tableRowPadding\", padding);
+        } catch (NumberFormatException ex) {
+            ex.printStackTrace();
+        }
     }
 
-    public boolean readyToClose() {
+    private boolean validateIntegerField(String fieldName, String fieldValue, String errorTitle)
+    {
         try {
-            // Test if font size is a number:
-            Integer.parseInt(fontSize.getText());
+            // Test if the field value is a number:
+            Integer.parseInt(fieldValue);
         } catch (NumberFormatException ex) {
             JOptionPane.showMessageDialog
                     (null, Globals.lang(\"You must enter an integer value in the text field for\") + \" '\" +
-                            Globals.lang(\"Menu and label font size\") + \"'\", Globals.lang(\"Changed font settings\"),
+                            Globals.lang(fieldName) + \"'\", Globals.lang(errorTitle),
                             JOptionPane.ERROR_MESSAGE);
             return false;
         }
         return true;
+    }
+
+    public boolean readyToClose() {
+        // Test if font size is a number:
+        if (validateIntegerField(\"Menu and label font size\", fontSize.getText(), \"Changed font settings\") == false) {
+            return false;
+        }
+
+        // Test if row padding is a number:
+        if (validateIntegerField(\"Table row height padding\", rowPadding.getText(), \"Changed table appearance settings\") == false) {
+            return false;
+        }
+        
+        return true;
 
     }
 , @@ -396,6 +396,7 @@ private JabRefPreferences() {
         defaults.put(\"menuFontFamily\", \"Times\");
         defaults.put(\"menuFontStyle\", java.awt.Font.PLAIN);
         defaults.put(\"menuFontSize\", 11);
+        defaults.put(\"tableRowPadding\", GUIGlobals.TABLE_ROW_PADDING);
         // Main table color settings:
         defaults.put(\"tableBackground\", \"255:255:255\");
         defaults.put(\"tableReqFieldBackground\", \"230:235:255\");, @@ -525,7 +525,7 @@ public void scrollTo(int y) {
      */
     public void updateFont() {
         setFont(GUIGlobals.CURRENTFONT);
-        setRowHeight(GUIGlobals.TABLE_ROW_PADDING + GUIGlobals.CURRENTFONT.getSize());
+        setRowHeight(Globals.prefs.getInt(\"tableRowPadding\") + GUIGlobals.CURRENTFONT.getSize());
     }
 
     public void ensureVisible(int row) {, ]"	"Previously, the padding added to the row height for the main table was hardcoded.
The padding value can now be modified by the user through the preferences dialog.
The old hardcoded value is used as the default value for the new preference.
"	"Added the option to change the table row height padding."
"42"	"Tobias"	"[CHANGELOG, src/main/java/net/sf/jabref/AppearancePrefsTab.java, src/main/java/net/sf/jabref/BasePanel.java, src/main/java/net/sf/jabref/EntryEditorTab.java, src/main/java/net/sf/jabref/FieldNameLabel.java, src/main/java/net/sf/jabref/GUIGlobals.java, src/main/java/net/sf/jabref/JabRefFrame.java, src/main/java/net/sf/jabref/JabRefPreferences.java, src/main/java/net/sf/jabref/SidePaneComponent.java, src/main/java/net/sf/jabref/gui/MainTable.java, ]"	"[@@ -1,4 +1,6 @@
 [master]
+    - Some UI updates (mainly removing unnecessary boundaries)
+    - Feature: Gridlines are now optional (and disabled by default)
     - Fix for bug #1248: Key bindings not modified
     - Fix for bug #876: Windows 7/8/10 - Pinning Jabref to the taskbar
     - Feature: Option to change the table row height padding, @@ -31,7 +31,7 @@
 class AppearancePrefsTab extends JPanel implements PrefsTab {
 
     JabRefPreferences _prefs;
-    private JCheckBox colorCodes, overrideFonts;//, useCustomIconTheme;
+    private JCheckBox colorCodes, overrideFonts, showGrid;//, useCustomIconTheme;
     private ColorSetupPanel colorPanel = new ColorSetupPanel();
     private Font font = GUIGlobals.CURRENTFONT;
     private int oldMenuFontSize;
@@ -59,6 +59,8 @@ public AppearancePrefsTab(JabRefPreferences prefs) {
                   (\"Use antialiasing font\"));*/
         overrideFonts = new JCheckBox(Globals.lang(\"Override default font settings\"));
 
+        showGrid = new JCheckBox(Globals.lang(\"Show gridlines\"));
+        
         //useCustomIconTheme = new JCheckBox(Globals.lang(\"Use custom icon theme\"));
         //customIconThemeFile = new JTextField();
         FormLayout layout = new FormLayout
@@ -86,6 +88,8 @@ public AppearancePrefsTab(JabRefPreferences prefs) {
         builder.nextLine();
         builder.append(colorCodes);
         builder.nextLine();
+        builder.append(showGrid);
+        builder.nextLine();
         JButton fontButton = new JButton(Globals.lang(\"Set table font\"));
         builder.append(fontButton);
         builder.nextLine();
@@ -157,6 +161,7 @@ public void setValues() {
         fontSize.setEnabled(overrideFonts.isSelected());
         //useCustomIconTheme.setSelected(_prefs.getBoolean(\"useCustomIconTheme\"));
         //customIconThemeFile.setText(_prefs.get(\"customIconThemeFile\"));
+        showGrid.setSelected(_prefs.getBoolean(\"tableShowGrid\"));
         colorPanel.setValues();
     }
 
@@ -175,6 +180,7 @@ public void storeSettings() {
         _prefs.putBoolean(\"overrideDefaultFonts\", overrideFonts.isSelected());
         GUIGlobals.CURRENTFONT = font;
         colorPanel.storeSettings();
+        _prefs.putBoolean(\"tableShowGrid\", showGrid.isSelected());
         try {
             int size = Integer.parseInt(fontSize.getText());
             if ((overrideFonts.isSelected() != oldOverrideFontSize) ||
@@ -187,7 +193,6 @@ public void storeSettings() {
                         Globals.lang(\"Changed font settings\"),
                         JOptionPane.WARNING_MESSAGE);
             }
-
         } catch (NumberFormatException ex) {
             ex.printStackTrace();
         }, @@ -16,6 +16,7 @@
 package net.sf.jabref;
 
 import java.awt.BorderLayout;
+import java.awt.Color;
 import java.awt.Component;
 import java.awt.GridBagConstraints;
 import java.awt.GridBagLayout;
@@ -45,6 +46,7 @@
 import java.util.logging.Logger;
 
 import javax.swing.AbstractAction;
+import javax.swing.BorderFactory;
 import javax.swing.JComponent;
 import javax.swing.JFileChooser;
 import javax.swing.JOptionPane;
@@ -2084,6 +2086,10 @@ protected boolean accept(Component c) {
 
         splitPane.setTopComponent(mainTable.getPane());
 
+        // Remove borders
+        splitPane.setBorder(BorderFactory.createEmptyBorder());
+        setBorder(BorderFactory.createEmptyBorder());
+                
         //setupTable();
         // If an entry is currently being shown, make sure it stays shown,
         // otherwise set the bottom component to null., @@ -26,6 +26,7 @@
 import java.util.List;
 
 import javax.swing.ActionMap;
+import javax.swing.BorderFactory;
 import javax.swing.InputMap;
 import javax.swing.JComponent;
 import javax.swing.JPanel;
@@ -129,7 +130,7 @@ void setupPanel(JabRefFrame frame, BasePanel bPanel, boolean addKeyField,
 
         DefaultFormBuilder builder = new DefaultFormBuilder
                 (new FormLayout(colSpec, rowSpec), panel);
-
+        
         for (int i = 0; i < fields.length; i++) {
             // Create the text area:
             int editorType = BibtexFields.getEditorType(fields[i]);, @@ -30,8 +30,9 @@ public FieldNameLabel(String name) {
       setVerticalAlignment(TOP);
     //setFont(GUIGlobals.fieldNameFont);
     setForeground(GUIGlobals.entryEditorLabelColor);
-      setBorder(BorderFactory.createMatteBorder(1,0,0,0, Color.GRAY));
+    //  setBorder(BorderFactory.createMatteBorder(1,0,0,0, Color.GRAY));
     //setBorder(BorderFactory.createEtchedBorder());
+    setBorder(BorderFactory.createEmptyBorder());
   }
 
   public void paintComponent(Graphics g) {, @@ -78,7 +78,7 @@
 	public static final int
 	SPLIT_PANE_DIVIDER_SIZE = 4,
 	SPLIT_PANE_DIVIDER_LOCATION = 145 + 15, // + 15 for possible scrollbar.
-	TABLE_ROW_PADDING = 4,
+	TABLE_ROW_PADDING = 8,
 	KEYBIND_COL_0 = 200,
 	KEYBIND_COL_1 = 80, // Added to the font size when determining table
 	MAX_CONTENT_SELECTOR_WIDTH = 240; // The max width of the combobox for content selectors., @@ -1797,7 +1797,7 @@ public void addTab(BasePanel bp, File file, boolean raisePanel) {
         } else {
             title = file.getName();
         }
-        tabbedPane.add(title, bp);
+        tabbedPane.add(\"<html><div style='padding:2px 5px;'>\" + title + \"</div></html>\", bp);
         tabbedPane.setToolTipTextAt(tabbedPane.getTabCount()-1,
                 file != null ? file.getAbsolutePath() : null);
         if (raisePanel) {, @@ -398,6 +398,7 @@ private JabRefPreferences() {
         defaults.put(\"menuFontStyle\", java.awt.Font.PLAIN);
         defaults.put(\"menuFontSize\", 11);
         defaults.put(\"tableRowPadding\", GUIGlobals.TABLE_ROW_PADDING);
+        defaults.put(\"tableShowGrid\", Boolean.FALSE);
         // Main table color settings:
         defaults.put(\"tableBackground\", \"255:255:255\");
         defaults.put(\"tableReqFieldBackground\", \"230:235:255\");, @@ -21,6 +21,7 @@
 import java.awt.event.ActionListener;
 import java.net.URL;
 
+import javax.swing.BorderFactory;
 import javax.swing.ImageIcon;
 import javax.swing.JButton;
 import javax.swing.JToolBar;
@@ -50,7 +51,7 @@ public SidePaneComponent(SidePaneManager manager, URL icon, String title) {
 		close.addActionListener(new CloseButtonListener());
 		setToolBar(tlb);
 		// setBorder(BorderFactory.createEtchedBorder());
-
+		setBorder(BorderFactory.createEmptyBorder());
 		// setBorder(BorderFactory.createMatteBorder(1,1,1,1,java.awt.Color.green));
 		// setPreferredSize(new java.awt.Dimension
 		// (GUIGlobals.SPLIT_PANE_DIVIDER_LOCATION, 200));, @@ -16,6 +16,7 @@
 package net.sf.jabref.gui;
 
 import java.awt.Color;
+import java.awt.Dimension;
 import java.awt.Rectangle;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
@@ -25,6 +26,7 @@
 
 import javax.swing.*;
 import javax.swing.plaf.TableUI;
+import javax.swing.table.DefaultTableCellRenderer;
 import javax.swing.table.TableCellRenderer;
 import javax.swing.table.TableColumnModel;
 
@@ -84,6 +86,7 @@ public MainTable(MainTableFormat tableFormat, EventList<BibtexEntry> list, JabRe
 
         addFocusListener(Globals.focusListener);
         setAutoResizeMode(Globals.prefs.getInt(\"autoResizeMode\"));
+      
         this.tableFormat = tableFormat;
         this.panel = panel;
         // This SortedList has a Comparator controlled by the TableComparatorChooser
@@ -109,8 +112,16 @@ public MainTable(MainTableFormat tableFormat, EventList<BibtexEntry> list, JabRe
         selectionModel = new EventSelectionModel<BibtexEntry>(sortedForGrouping);
         setSelectionModel(selectionModel);
         pane = new JScrollPane(this);
+        pane.setBorder(BorderFactory.createEmptyBorder());
         pane.getViewport().setBackground(Globals.prefs.getColor(\"tableBackground\"));
         setGridColor(Globals.prefs.getColor(\"gridColor\"));
+        if(Globals.prefs.getBoolean(\"tableShowGrid\"))
+        	setShowGrid(true);
+        else
+        {
+	        setShowGrid(false);
+	        setIntercellSpacing(new Dimension(0, 0));
+        }
 
         this.setTableHeader(new PreventDraggingJTableHeader(this.getColumnModel()));
 
@@ -217,7 +228,7 @@ public JScrollPane getPane() {
     public TableCellRenderer getCellRenderer(int row, int column) {
         
         int score = -3;
-        TableCellRenderer renderer = defRenderer;
+        DefaultTableCellRenderer renderer = defRenderer;
 
         int status = getCellStatus(row, column);
 
@@ -256,14 +267,15 @@ else if (column == 0) {
                 } else
                     renderer = compRenderer;
             }
+            renderer.setHorizontalAlignment( JLabel.CENTER );
         }
         else if (tableColorCodes) {
             if (status == REQUIRED)
                 renderer = reqRenderer;
             else if (status == OPTIONAL)
                 renderer = optRenderer;
             else if (status == BOOLEAN)
-                renderer = getDefaultRenderer(Boolean.class);
+                renderer = (DefaultTableCellRenderer) getDefaultRenderer(Boolean.class);
         }
 
         // For MARKED feature:, ]"	"Cleaned-up version of older pull request https://github.com/JabRef/jabref/pull/43
"	"Add option to hide/show gridlines in the main table"
"43"	"Adam Rehn"	"[src/main/java/net/sf/jabref/SidePaneManager.java, ]"	"[@@ -205,10 +205,12 @@ public PreferredIndexSort() {
 		public int compare(SidePaneComponent comp1, SidePaneComponent comp2) {
 			String comp1Name = getComponentName(comp1);
 			String comp2Name = getComponentName(comp2);
-			return Integer.compare(
-					preferredPositions.getOrDefault(comp1Name, 0),
-					preferredPositions.getOrDefault(comp2Name, 0)
-			);
+			
+			// Manually provide default values, since getOrDefault() doesn't exist prior to Java 8
+			int pos1 = (preferredPositions.containsKey(comp1Name) ? preferredPositions.get(comp1Name) : 0);
+			int pos2 = (preferredPositions.containsKey(comp2Name) ? preferredPositions.get(comp2Name) : 0);
+			
+			return Integer.compare(pos1, pos2);
 		}
 	}
 	, ]"	"Side pane panels now feature an up arrow button and a down arrow button immediately to the left of the close button. These buttons allow panes to be swapped with the pane above or below them, respectively.

Whenever the panes are reordered, the current position of each visible pane is recorded in the application preferences, so the user's custom ordering can be preserved when JabRef is next run.
"	"Added the ability to reorder the panels in the side pane."
"44"	"Adam Rehn"	"[src/main/java/net/sf/jabref/BasePanel.java, src/main/java/net/sf/jabref/export/FileActions.java, src/main/java/net/sf/jabref/export/SaveDatabaseAction.java, ]"	"[@@ -70,6 +70,7 @@
 import net.sf.jabref.export.SaveDatabaseAction;
 import net.sf.jabref.export.SaveException;
 import net.sf.jabref.export.SaveSession;
+import net.sf.jabref.export.FileActions.DatabaseSaveType;
 import net.sf.jabref.export.layout.Layout;
 import net.sf.jabref.export.layout.LayoutHelper;
 import net.sf.jabref.external.AttachFileAction;
@@ -411,9 +412,9 @@ public void action() throws Throwable {
             }
         });
 
-        actions.put(\"saveSelectedAs\", new SaveSelectedAction(false));
+        actions.put(\"saveSelectedAs\", new SaveSelectedAction(FileActions.DatabaseSaveType.DEFAULT));
         
-        actions.put(\"saveSelectedAsPlain\", new SaveSelectedAction(true));
+        actions.put(\"saveSelectedAsPlain\", new SaveSelectedAction(FileActions.DatabaseSaveType.PLAIN_BIBTEX));
         
         // The action for copying selected entries.
         actions.put(\"copy\", new BaseAction() {
@@ -1696,7 +1697,7 @@ public void runCommand(String _command) {
       //}).start();
     }
 
-    private boolean saveDatabase(File file, boolean selectedOnly, String encoding, boolean savePlainBibtex) throws SaveException {
+    private boolean saveDatabase(File file, boolean selectedOnly, String encoding, FileActions.DatabaseSaveType saveType) throws SaveException {
         SaveSession session;
         frame.block();
         try {
@@ -1705,7 +1706,7 @@ private boolean saveDatabase(File file, boolean selectedOnly, String encoding, b
                                            Globals.prefs, false, false, encoding, false);
             else
                 session = FileActions.savePartOfDatabase(database, metaData, file,
-                                               Globals.prefs, mainTable.getSelectedEntries(), encoding, savePlainBibtex);
+                                               Globals.prefs, mainTable.getSelectedEntries(), encoding, saveType);
 
         } catch (UnsupportedCharsetException ex2) {
             JOptionPane.showMessageDialog(frame, Globals.lang(\"Could not save file. \"
@@ -1755,7 +1756,7 @@ private boolean saveDatabase(File file, boolean selectedOnly, String encoding, b
                         JOptionPane.QUESTION_MESSAGE, null, Globals.ENCODINGS, encoding);
                 if (choice != null) {
                     String newEncoding = (String)choice;
-                    return saveDatabase(file, selectedOnly, newEncoding, savePlainBibtex);
+                    return saveDatabase(file, selectedOnly, newEncoding, saveType);
                 } else
                     commit = false;
             } else if (answer == JOptionPane.CANCEL_OPTION)
@@ -3078,10 +3079,10 @@ public void setBackAndForwardEnabledState() {
 
     private class SaveSelectedAction extends BaseAction {
     	
-    	private boolean savePlainBibtex;
+    	private DatabaseSaveType saveType;
     	
-    	public SaveSelectedAction(boolean savePlainBibtex) {
-    		this.savePlainBibtex = savePlainBibtex;
+    	public SaveSelectedAction(DatabaseSaveType saveType) {
+    		this.saveType = saveType;
     	}
     	
         public void action() throws Throwable {
@@ -3097,7 +3098,7 @@ public void action() throws Throwable {
                     Globals.lang(\"Save database\"), JOptionPane.OK_CANCEL_OPTION)
                    == JOptionPane.OK_OPTION)) {
 
-                saveDatabase(expFile, true, Globals.prefs.get(\"defaultEncoding\"), savePlainBibtex);
+                saveDatabase(expFile, true, Globals.prefs.get(\"defaultEncoding\"), saveType);
                 //runCommand(\"save\");
                 frame.getFileHistory().newFile(expFile.getPath());
                 frame.output(Globals.lang(\"Saved selected to\")+\" '\", @@ -55,7 +55,11 @@
 import ca.odell.glazedlists.SortedList;
 
 public class FileActions {
-
+	
+	public enum DatabaseSaveType {
+		DEFAULT, PLAIN_BIBTEX
+	}
+	
     private static Pattern refPat = Pattern.compile(\"(#[A-Za-z]+#)\"); // Used to detect string references in strings
     private static BibtexString.Type previousStringType;
 
@@ -357,7 +361,7 @@ public SaveSettings(boolean isSaveOperation, MetaData metaData) {
      * @return A List containing warnings, if any.
      */
     public static SaveSession savePartOfDatabase(BibtexDatabase database, MetaData metaData,
-            File file, JabRefPreferences prefs, BibtexEntry[] bes, String encoding, boolean writePlainBibtex) throws SaveException {
+            File file, JabRefPreferences prefs, BibtexEntry[] bes, String encoding, DatabaseSaveType saveType) throws SaveException {
 
         TreeMap<String, BibtexEntryType> types = new TreeMap<String, BibtexEntryType>(); // Map
         // to
@@ -382,7 +386,7 @@ public static SaveSession savePartOfDatabase(BibtexDatabase database, MetaData m
             // Define our data stream.
             VerifyingWriter fw = session.getWriter();
 
-            if (!writePlainBibtex) {
+            if (saveType != DatabaseSaveType.PLAIN_BIBTEX) {
             	// Write signature.
             	writeBibFileHeader(fw, encoding);
             }
@@ -425,7 +429,7 @@ public static SaveSession savePartOfDatabase(BibtexDatabase database, MetaData m
             }
 
             // Write meta data.
-            if (!writePlainBibtex && metaData != null) {
+            if (saveType != DatabaseSaveType.PLAIN_BIBTEX && metaData != null) {
                 metaData.writeMetaData(fw);
             }
 , @@ -218,7 +218,7 @@ private boolean saveDatabase(File file, boolean selectedOnly, String encoding) t
                         Globals.prefs, false, false, encoding, false);
             else
                 session = FileActions.savePartOfDatabase(panel.database(), panel.metaData(), file,
-                        Globals.prefs, panel.getSelectedEntries(), encoding, false);
+                        Globals.prefs, panel.getSelectedEntries(), encoding, FileActions.DatabaseSaveType.DEFAULT);
 
         } catch (UnsupportedCharsetException ex2) {
             JOptionPane.showMessageDialog(frame, Globals.lang(\"Could not save file. \", ]"	"Adds a new menu option called \"Save selected as plain BibTeX ...\".

This option behaves the same way as the existing \"Save selected as ...\" option, except that the JabRef metadata and signature comment are not written to the resulting output file.
"	"Add the option to save selected entries as plain BibTeX."
"45"	"Adam Rehn"	"[src/main/java/net/sf/jabref/JabRefFrame.java, ]"	"[@@ -1686,7 +1686,7 @@ public void stopShowingSearchResults() {
     protected void initActions() {
         openDatabaseOnlyActions = new LinkedList<Object>();
         openDatabaseOnlyActions.addAll(Arrays.asList(manageSelectors,
-                mergeDatabaseAction, newSubDatabaseAction, close, save, saveAs, saveSelectedAs, undo,
+                mergeDatabaseAction, newSubDatabaseAction, close, save, saveAs, saveSelectedAs, saveSelectedAsPlain, undo,
                 redo, cut, delete, copy, paste, mark, unmark, unmarkAll, editEntry,
                 selectAll, copyKey, copyCiteKey, copyKeyAndTitle, editPreamble, editStrings, toggleGroups, toggleSearch,
                 makeKeyAction, normalSearch,, ]"	"The \"Save selected as plain BibTeX...\" menu option is now correctly enabled and disabled based on whether or not a database is currently open.

I haven't included a CHANGELOG entry, since this commit effectively just corrects a minor oversight on my behalf when adding this menu entry in [a previous pull request](https://github.com/JabRef/jabref/pull/48), but I'm happy to add one if deemed necessary.
"	"Minor UI Fix: Add \"Save selected as plain BibTeX...\" to the list of open database-only actions."
